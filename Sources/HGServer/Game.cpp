// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////

#include "Game.h"
#include "LoginServer.h"

class CDebugWindow *DbgWnd;

extern void PutLogList(char * cMsg);
extern char G_cTxt[512];
extern char	G_cData50000[50000];

extern void PutLogFileList(char * cStr);
extern void PutAdminLogFileList(char * cStr);
extern void PutItemLogFileList(char * cStr);
extern void PutLogEventFileList(char * cStr);
extern void PutHackLogFileList(char * cStr);
extern void PutPvPLogFileList(char * cStr);

// extern void PutDebugMsg(char * cStr);	// 2002-09-09 #2

extern FILE * pLogFile;
extern HWND	G_hWnd;

// Move lock para 800 x 600
int _tmp_iMoveLocX[9][46] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0},
	 // 1
	 {0,1,2,3,4,5,6,7,8,9,
	  10,11,12,13,14,15,16,17,18,19,
	  20,21,22,23,24,25,-1,0,0,0,
	  0,0,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0},
	  // 2
	  {0,1,2,3,4,5,6,7,8,9,
	   10,11,12,13,14,15,16,17,18,19,
	   20,21,22,23,24,25,25,25,25,25,
	   25,25,25,25,25,25,25,25,25,25,
	   25,25,25,25,25,-1},
	   // 3
	   {25,25,25,25,25,25,25,25,25,25,
		25,25,25,25,25,25,25,25,25,25,
		-1,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0},
		// 4
		{25,25,25,25,25,25,25,25,25,25,
		 25,25,25,25,25,25,25,25,25,25,
		 24,23,22,21,20,19,18,17,16,15,
		 14,13,12,11,10, 9, 8, 7, 6, 5,
		 4, 3, 2, 1, 0, -1},
		 // 5
		 {0,1,2,3,4,5,6,7,8,9,
		  10,11,12,13,14,15,16,17,18,19,
		  20,21,22,23,24,25,-1,0,0,0,
		  0,0,0,0,0,0,0,0,0,0,
		  0,0,0,0,0,0},
		  // 6
		  {0,0,0,0,0,0,0,0,0,0,
		   0,0,0,0,0,0,0,0,0,0,
		   1,2,3,4,5,6,7,8,9,10,
		   11,12,13,14,15,16,17,18,19,20,
		   21,22,23,24,25,-1},
		   // 7
		   {0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,
			-1,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0},
			// 8
			{0,1,2,3,4,5,6,7,8,9,
			 10,11,12,13,14,15,16,17,18,19,
			 20,21,22,23,24,25,0,0,0,0,
			 0,0,0,0,0,0,0,0,0,0,
			 0,0,0,0,0,-1}
};

int _tmp_iMoveLocY[9][46] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0},
	 // 1
	 {0,0,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,-1,0,0,0,
	  0,0,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0},
	  // 2
	  {0,0,0,0,0,0,0,0,0,0,
	   0,0,0,0,0,0,0,0,0,0,
	   0,0,0,0,0,0,1,2,3,4,
	   5,6,7,8,9,10,11,12,13,14,
	   15,16,17,18,19,-1},
	   // 3
	   {0,1,2,3,4,5,6,7,8,9,
		10,11,12,13,14,15,16,17,18,19,
		-1,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0},
		// 4
		{0,1,2,3,4,5,6,7,8,9,
		 10,11,12,13,14,15,16,17,18,19,
		 19,19,19,19,19,19,19,19,19,19,
		 19,19,19,19,19,19,19,19,19,19,
		 19,19,19,19,19,-1},
		 // 5
		 {19,19,19,19,19,19,19,19,19,19,
		  19,19,19,19,19,19,19,19,19,19,
		  19,19,19,19,19,19,-1,0,0,0,
		  0,0,0,0,0,0,0,0,0,0,
		  0,0,0,0,0,0},
		  // 6
		  {0,1,2,3,4,5,6,7,8,9,
		   10,11,12,13,14,15,16,17,18,19,
		   19,19,19,19,19,19,19,19,19,19,
		   19,19,19,19,19,19,19,19,19,19,
		   19,19,19,19,19,-1},
		   // 7
		   {0,1,2,3,4,5,6,7,8,9,
			10,11,12,13,14,15,16,17,18,19,
			-1,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0},
			// 8
			{0,0,0,0,0,0,0,0,0,0,
			 0,0,0,0,0,0,0,0,0,0,
			 0,0,0,0,0,0,1,2,3,4,
			 5,6,7,8,9,10,11,12,13,14,
			 15,16,17,18,19,-1}
};

char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

extern bool	G_bIsThread;
extern void ThreadProc(void *ch);

CGame::CGame(HWND hWnd)
{
 int i, x;
	
	m_bIsGameStarted = false;
	m_hWnd           = hWnd;
	/*m_pMainLogSock   = 0;
	m_pGateSock      = 0;
	m_bIsLogSockAvailable   = false;
	m_bIsGateSockAvailable  = false;
	m_bIsItemAvailable      = false;
	m_bIsBuildItemAvailable = false;
	m_bIsNpcAvailable       = false;
	m_bIsMagicAvailable     = false;
	m_bIsSkillAvailable     = false;
	m_bIsQuestAvailable     = false;
	m_bIsPortionAvailable   = false;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));*/

	_lsock = 0; 
	g_login = new LoginServer;

	m_iPlayerMaxLevel = DEF_PLAYERMAXLEVEL;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = 0;

	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = 0;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = 0;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = 0;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = 0;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = 0;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = 0;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = 0;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = 0;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = 0;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = 0;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = 0;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = 0;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = 0;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		m_pPortionConfigList[i] = 0;
		m_pCraftingConfigList[i] = 0;// Crafting
	}

//	/for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
//		m_pTeleportConfigList[i] = 0;

	/*for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = 0;
		m_bIsSubLogSockAvailable[i] = false;
	}*/

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = 0;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
		m_pDupItemIDList[i] = 0;

	// New 06/05/2004
	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		m_stPartyInfo[i].iTotalMembers = 0;
		for(x = 0; x < DEF_MAXPARTYMEMBERS; x++)
			m_stPartyInfo[i].iIndex[x] = 0;
	}

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = false;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds  = 0;
	m_stCityStatus[1].iWins   = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds  = 0;
	m_stCityStatus[2].iWins   = 0;

	m_iAutoRebootingCount	= 0;
	m_bEnemyKillMode		= false; 
	m_iEnemyKillAdjust      = 1; 
	m_bAdminSecurity		= true; 
	m_sRaidTimeMonday		= 0; 
	m_sRaidTimeTuesday      = 0; 
	m_sRaidTimeWednesday	= 0; 
	m_sRaidTimeThursday     = 0; 
	m_sRaidTimeFriday		= 0; 
	m_sRaidTimeSaturday     = 0; 
	m_sRaidTimeSunday		= 0;
	m_sCharPointLimit		= 0;
	m_sSlateSuccessRate		= 0;
	m_sForceRecallTime = 0;
	
	//Show Debug Window
	//DbgWnd = new CDebugWindow();
	//DbgWnd->Startup();
	//DbgWnd->AddEventMsg("CGame Startup");
	// 2002-09-09 #1
	m_bReceivedItemList = false;

	for (i = 0; i < DEF_MAXCLIENTLOGINSOCK; i++)
		_lclients[i] = nullptr;

	m_pPartyManager = new class PartyManager(this);

}

CGame::~CGame()
{
	//DbgWnd->Shutdown();
	//delete DbgWnd;

	for (int i = 0; i < DEF_MAXCLIENTLOGINSOCK; i++)
	{
		if (_lclients[i])
		{
			delete _lclients[i];
			_lclients[i] = nullptr;
		}
	}

	delete m_pPartyManager;
}

bool CGame::bAcceptLogin(XSocket* sock)
{
	if (m_bIsGameStarted == false)
	{
		PutLogList("Closed Connection, not initialized");
		goto CLOSE_ANYWAY;
	}

	for (int i = 0; i < DEF_MAXCLIENTLOGINSOCK; i++)
	{
		auto& p = _lclients[i];
		if (!p)
		{
			p = new LoginClient(m_hWnd);
			sock->bAccept(p->_sock, WM_USER_BOT_ACCEPT + i + 1);
			//	PutLogList("Login Client Acepted");
			ZeroMemory(p->_ip, sizeof(p->_ip));
			p->_sock->iGetPeerAddress(p->_ip);
			return true;
		}
	}

CLOSE_ANYWAY:

	auto pTmpSock = new XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	sock->bAccept(pTmpSock, 0);
	delete pTmpSock;

	return false;
}

bool CGame::bAccept(class XSocket * pXSock)
{
 int i, iTotalip = 0, a;
 class XSocket * pTmpSock;
 char cIPtoBan[21];
 FILE* pFile;

	if (m_bIsGameStarted == false)
		goto CLOSE_ANYWAY;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] == 0) {
		
		m_pClientList[i] = new class CClient(m_hWnd);
		bAddClientShortCut(i);
		m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime = 
			m_pClientList[i]->m_dwHPTime = m_pClientList[i]->m_dwAutoSaveTime = 
				m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime = 
					m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = m_pClientList[i]->m_dwSpeedHackCheckTime = timeGetTime();
		
		pXSock->bAccept(m_pClientList[i]->m_pXSock, WM_ONCLIENTSOCKETEVENT + i); 
	
		ZeroMemory(m_pClientList[i]->m_cIPaddress, sizeof(m_pClientList[i]->m_cIPaddress));
		m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);
		
		a = i;

		for (int v = 0; v < DEF_MAXBANNED; v++)
		{
			if (strcmp(m_stBannedList[v].m_cBannedIPaddress, m_pClientList[i]->m_cIPaddress) == 0)
			{
				goto CLOSE_CONN;
			}
		}
		//centu: Anti-Downer
		for (int j = 0; j < DEF_MAXCLIENTS; j++) {
			if (m_pClientList[j] != 0) {
				if (strcmp(m_pClientList[j]->m_cIPaddress, m_pClientList[i]->m_cIPaddress) == 0) iTotalip++;
			}
		}
		if (iTotalip > 9) {
			ZeroMemory(cIPtoBan, sizeof(cIPtoBan));
			strcpy(cIPtoBan, m_pClientList[i]->m_cIPaddress);
			//opens cfg file
			pFile = fopen("GameConfigs\\BannedList.cfg", "a");
			//shows log
			wsprintf(G_cTxt, "<%d> IP Banned: (%s)", i, cIPtoBan);
			PutLogList(G_cTxt);
			//modifys cfg file
			fprintf(pFile, "banned-ip = %s", cIPtoBan);
			fprintf(pFile, "\n");
			fclose(pFile);

			//updates BannedList.cfg on the server
			for (int x = 0; x < DEF_MAXBANNED; x++)
				if (strlen(m_stBannedList[x].m_cBannedIPaddress) == 0)
					strcpy(m_stBannedList[x].m_cBannedIPaddress, cIPtoBan);

			goto CLOSE_CONN;
		}

		wsprintf(G_cTxt,"<%d> Client Connected: (%s)", i, m_pClientList[i]->m_cIPaddress);
		PutLogList(G_cTxt);

		m_iTotalClients++;

		if (m_iTotalClients > m_iMaxClients) { 
			m_iMaxClients = m_iTotalClients;
			//GetLocalTime(&m_MaxUserSysTime);
			//wsprintf(cTxt, "Maximum Players: %d", m_iMaxClients);
			//PutLogFileList(cTxt);
		}

		//m_pClientList[iClientH]->m_bIsInitComplete °ªÀ» ÂüÁ¶ÇØ¾ß ÇÑ´Ù.
		return true;
	}

CLOSE_ANYWAY:

	pTmpSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	pXSock->bAccept(pTmpSock, 0); 
	delete pTmpSock;

	return false;

CLOSE_CONN:
	delete m_pClientList[a];
	m_pClientList[a] = 0;
	RemoveClientShortCut(a);
	return false;
}


void CGame::OnClientSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 int iClientH, iRet;
 DWORD dwTime = timeGetTime();

	iTmp = WM_ONCLIENTSOCKETEVENT;
	iClientH = (int)(message - iTmp);

	if (iClientH <= 0) return;
	
	if (m_pClientList[iClientH] == 0) return;

	iRet = m_pClientList[iClientH]->m_pXSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnClientRead(iClientH);
		m_pClientList[iClientH]->m_dwTime = timeGetTime();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		PutLogList("Socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		wsprintf(G_cTxt,"<%d> Confirmcode notmatch!", iClientH);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, false, true);
		break;

	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		wsprintf(G_cTxt,"<%d> Client Disconnected! (%s)", iClientH, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(G_cTxt); 
		if ((dwTime - m_pClientList[iClientH]->m_dwLogoutHackCheck) < 1000) {
				try
				{
					wsprintf(G_cTxt, "Logout Hack: (%s) Player: (%s) - disconnected within 10 seconds of most recent damage. Hack? Lag?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
					PutHackLogFileList(G_cTxt);
				}
				catch(...)
				{
				}
		}

		DeleteClient(iClientH, true, true);
		break;
	}													    
}

bool CGame::bInit()		   
{
 char * cp, cTxt[120];
 DWORD * dwp;
 WORD * wp;
 int  i;
 SYSTEMTIME SysTime;
 DWORD dwTime = timeGetTime();

	//m_Misc.Temp();

	PutLogList("(!) INITIALIZING GAME SERVER...");
	//

	for (i = 0; i < DEF_MAXCLIENTS+1; i++)
		m_iClientShortCut[i] = 0;

	/*if (m_pMainLogSock != 0) delete m_pMainLogSock;
	if (m_pGateSock != 0) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != 0) delete m_pSubLogSock[i];*/

	if (_lsock != 0) 
		delete _lsock;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != 0) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != 0) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != 0) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != 0) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != 0) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != 0) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != 0) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != 0) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != 0) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != 0) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
	if (m_pNoticeMsgList[i] != 0) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != 0) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != 0) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		if (m_pPortionConfigList[i] != 0) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != 0) delete m_pCraftingConfigList[i];	// Crafting
	}

//	for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
//	if (m_pTeleportConfigList[i] != 0) delete m_pTeleportConfigList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != 0) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = 0;
	

	for (i = 0; i < DEF_MAXSCHEDULE; i++) {
		m_stCrusadeWarSchedule[i].iDay = -1;
		m_stCrusadeWarSchedule[i].iHour = -1;
		m_stCrusadeWarSchedule[i].iMinute = -1;
	}
	
	for (i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleStart[i].iDay = -1;
		m_stApocalypseScheduleStart[i].iHour = -1;
		m_stApocalypseScheduleStart[i].iMinute = -1;
	}
	
	for (i = 0; i < DEF_MAXHELDENIAN; i++) {
		m_stHeldenianSchedule[i].iDay = -1;
		m_stHeldenianSchedule[i].StartiHour = -1;
		m_stHeldenianSchedule[i].StartiMinute = -1;
		m_stHeldenianSchedule[i].EndiHour = -1;
		m_stHeldenianSchedule[i].EndiMinute = -1;
	}

	for (i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleEnd[i].iDay = -1;
		m_stApocalypseScheduleEnd[i].iHour = -1;
		m_stApocalypseScheduleEnd[i].iMinute = -1;
	}

	m_iNpcConstructionPoint[1]  = 100; // MS
	m_iNpcConstructionPoint[2]  = 100; // MS
	m_iNpcConstructionPoint[3]  = 100; // MS
	m_iNpcConstructionPoint[4]  = 100; // MS
	m_iNpcConstructionPoint[5]  = 100; // MS
	m_iNpcConstructionPoint[6]  = 100; // MS
		
	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000; // TK
	m_iNpcConstructionPoint[47] = 3000; // BG
	m_iNpcConstructionPoint[51] = 1500; // Catapult
	//

	m_bIsGameStarted = false;

	/*m_pMainLogSock  = 0;
	m_pGateSock = 0;
	m_bIsLogSockAvailable   = false;
	m_bIsGateSockAvailable  = false;
	m_bIsItemAvailable      = false;
	m_bIsBuildItemAvailable = false;
	m_bIsNpcAvailable       = false;
	m_bIsMagicAvailable     = false;
	m_bIsSkillAvailable     = false;
	m_bIsQuestAvailable     = false;
	m_bIsPortionAvailable   = false;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));*/

	_lsock = 0;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = 0;

	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = 0;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = 0;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = 0;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = 0;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = 0;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = 0;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = 0;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = 0;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = 0;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = 0;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = 0;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = 0;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = 0;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		m_pPortionConfigList[i] = 0;
		m_pCraftingConfigList[i] = 0;	// Crafting
	}

//	for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
//		m_pTeleportConfigList[i] = 0;

	/*for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = 0;
		m_bIsSubLogSockAvailable[i] = false;
	}*/

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = 0;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		ZeroMemory(m_stCrusadeStructures[i].cMapName, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = 0;
		m_stCrusadeStructures[i].dX    = 0;
		m_stCrusadeStructures[i].dY    = 0;
	}

	for (i = 0; i < DEF_MAXADMINS; i++) {
		ZeroMemory(m_stAdminList[i].m_cGMName, sizeof(m_stAdminList[i].m_cGMName));
	}

	for (i = 0; i < DEF_MAXBANNED; i++) {
		ZeroMemory(m_stBannedList[i].m_cBannedIPaddress, sizeof(m_stBannedList[i].m_cBannedIPaddress));
	}
	
	for (i = 0; i < DEF_MAXGUILDS; i++)
		m_pGuildTeleportLoc[i].m_iV1 = 0;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		m_stMiddleCrusadeStructureInfo[i].cType = 0;
		m_stMiddleCrusadeStructureInfo[i].cSide = 0;
		m_stMiddleCrusadeStructureInfo[i].sX = 0;
		m_stMiddleCrusadeStructureInfo[i].sY = 0;
	}
	m_iTotalMiddleCrusadeStructures = 0;
	
	m_pNoticementData = 0;

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = false;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex    = -1;
	m_iElvineMapIndex     = -1;
	m_iGodHMapIndex	      = -1;
	m_iBTFieldMapIndex    = -1;

	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_iSubLogSockInitIndex   = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds  = 0;
	m_stCityStatus[1].iWins   = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds  = 0;
	m_stCityStatus[2].iWins   = 0;
 
	m_iStrategicStatus = 0;

	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;

	m_iAresdenMana = 0;
	m_iElvineMana  = 0;

	m_dwSpecialEventTime = m_dwWhetherTime = m_dwGameTime1 =
		m_dwGameTime2 = m_dwGameTime3 = m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = dwTime;

	m_bIsSpecialEventTime = false;

	GetLocalTime(&SysTime);
	m_dwCanFightzoneReserveTime =  dwTime -  ((SysTime.wHour%2)*60*60 + SysTime.wMinute*60) *1000 ;
		
	for(i =0; i < DEF_MAXFIGHTZONE; i++) 
		m_iFightZoneReserve[i] = 0 ;

	m_iFightzoneNoForceRecall = 0;
	
	for (i = 1; i < 1000; i++) {
		m_iLevelExpTable[i] = iGetLevelExp(i);
		//testcode
		//wsprintf(G_cTxt, "Level:%d --- Exp:%d", i, m_iLevelExpTable[i]);
		//PutLogFileList(G_cTxt);
	}

	m_iLimitedUserExp = m_iLevelExpTable[DEF_LEVELLIMIT+1];
	m_iLevelExp20     = m_iLevelExpTable[20]; 

	m_iGameServerMode = 0;
	if (bReadProgramConfigFile("GServer.cfg", false) == false) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! GServer.cfg file contents error!");
		return false;	
	}
	if (bReadProgramConfigFile("GMaps.cfg", true) == false) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! GMaps.cfg file contents error!");
		return false;
	}
	if (bReadSettingsConfigFile("GameConfigs\\Settings.cfg") == false) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Settings.cfg file contents error!");
		return false;
	}
	if (bReadAdminListConfigFile("GameConfigs\\AdminList.cfg") == false) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! AdminList.cfg file contents error!");
		return false;
	}
	if (bReadBannedListConfigFile("GameConfigs\\BannedList.cfg") == false) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! BannedList.cfg file contents error!");
		return false;
	}
	if (bReadAdminSetConfigFile("GameConfigs\\AdminSettings.cfg") == false) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! AdminSettings.cfg file contents error!");
		return false;
	}	
	srand( (unsigned)time( 0 ) );   
	//m_pMainLogSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	//m_pMainLogSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_ONLOGSOCKETEVENT);
	//m_pMainLogSock->bInitBufferSize(DEF_MSGBUFFERSIZE);

	//wsprintf(cTxt, "(!) Try to Connect main-log-socket... Addr:%s  Port:%d", m_cLogServerAddr, m_iLogServerPort);
	//PutLogList(cTxt);
	////Sleep(100);

	//m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	//m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
	//m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	//m_iGateSockConnRetryTimes = 1;

	//wsprintf(cTxt, "(!) Try to Connect Gate Server... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	//PutLogList(cTxt);

	_lsock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	_lsock->bConnect(m_cGameServerAddr, m_iLogServerPort, WM_ONLOGSOCKETEVENT);
	_lsock->bInitBufferSize(DEF_MSGBUFFERSIZE);

	m_bF1pressed = m_bF4pressed = m_bF12pressed = m_bF5pressed = false;
	
	m_bOnExitProcess = false;
	
	for (i = 0; i <= 100; i++) {
		m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);
	}

	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= DEF_NIGHTTIME) 
		 m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	bReadNotifyMsgListFile("GameConfigs\\notice.txt");
	m_dwNoticeTime = dwTime;

	/*m_iCurSubLogSockIndex    = 0;
	m_iSubLogSockFailCount   = 0;
	m_iSubLogSockActiveCount = 0;*/

	m_pNoticementData      = 0;
	m_dwNoticementDataSize = 0;

	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;

	m_iCrusadeCount  = 0;
	m_bIsCrusadeMode = false;
	m_bIsApocalypseMode = false;
	//m_wServerID_GSS = iDice(1,65535);

	/*ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
	cp = (char *)m_cGateServerStockMsg;
	dwp = (DWORD *)cp;
	*dwp = MSGID_SERVERSTOCKMSG;
	cp += 4;
	wp = (WORD *)cp;
	*wp = DEF_MSGTYPE_CONFIRM;
	cp += 2;*/

	m_iIndexGSS = 6;
	m_dwCrusadeGUID = 0;
	m_iCrusadeWinnerSide = 0;
	m_iLastCrusadeWinner = 0;
	m_sLastHeldenianWinner = 0;
	m_sLastCrusadeDate = -1;
	m_iFinalShutdownCount = 0;
	m_bIsCrusadeWarStarter = false;
	m_bIsApocalypseStarter = false;
	m_iLatestCrusadeDayOfWeek = -1;

	m_bHeldenianInitiated = false;
	m_cHeldenianType = false;
	m_bIsHeldenianMode = false;
	m_bHeldenianRunning	= false;
	m_iHeldenianAresdenLeftTower = 0;
	m_cHeldenianModeType = -1;
	m_sLastHeldenianWinner = -1;
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower = 0;
	m_iHeldenianAresdenDead = 0;
	m_iHeldenianElvineDead = 0;

	int dwMsgSize = 0;
	m_bIsItemAvailable = _bDecodeItemConfigFileContents("GameConfigs\\Item.cfg", dwMsgSize);
	m_bIsItemAvailable = _bDecodeItemConfigFileContents("GameConfigs\\Item2.cfg", dwMsgSize);
	m_bIsItemAvailable = _bDecodeItemConfigFileContents("GameConfigs\\Item3.cfg", dwMsgSize);
	m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents("GameConfigs\\builditem.cfg", dwMsgSize);
	m_bIsNpcAvailable = _bDecodeNpcConfigFileContents("GameConfigs\\NPC.cfg", dwMsgSize);
	m_bIsMagicAvailable = _bDecodeMagicConfigFileContents("GameConfigs\\Magic.cfg", dwMsgSize);
	m_bIsSkillAvailable = _bDecodeSkillConfigFileContents("GameConfigs\\Skill.cfg", dwMsgSize);
	m_bIsQuestAvailable = _bDecodeQuestConfigFileContents("GameConfigs\\Quest.cfg", dwMsgSize);
	m_bIsPortionAvailable = _bDecodePortionConfigFileContents("GameConfigs\\potion.cfg", dwMsgSize);
	_bDecodeDupItemIDFileContents("GameConfigs\\DupItemID.cfg", dwMsgSize);

	return true;
}

void CGame::OnClientRead(int iClientH)
{
 char  * pData, cKey;
 DWORD  dwMsgSize;
	
	if (m_pClientList[iClientH] == 0) return;
 
	pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointer(&dwMsgSize, &cKey); // v1.4
	
	if (bPutMsgQuene(DEF_MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey) == false) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}


void CGame::DisplayInfo(HDC hdc)
{
 char cTxt[350], cDave[350];  
 int  i, iLine;

	wsprintf(cTxt, "Server-Name(%s) Max.Level(%d) Players(%d/%d - %d/%d)", m_cServerName, m_iPlayerMaxLevel, m_iTotalClients, m_iMaxClients, m_iTotalGameServerClients, m_iTotalGameServerMaxClients);
	TextOut(hdc, 5, 10, cTxt, strlen(cTxt));

//#ifdef DEF_TESTSERVER
//	ZeroMemory(cTxt, sizeof(cTxt));
//	strcpy(cTxt, "인접한 클라이언트들에게 방향전환 이벤트를 알린다. ********** TEST SERVER MODE **********");
//	TextOut(hdc, 5, 25, cTxt, strlen(cTxt));
//#endif

	GayDave(cDave, "Bobobob");
	TextOut(hdc, 5, 25, cDave, strlen(cDave));


	iLine = 0;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != 0) {

		ZeroMemory(G_cTxt, sizeof(G_cTxt));
		wsprintf(G_cTxt, "Map(%s)    Object(%d)    P(%d, %d)    N(%d, %d)    A(%d, %d)    E(%d, %d)    M(%d, %d)", 
			     m_pMapList[i]->m_cName, m_pMapList[i]->m_iTotalActiveObject,  m_pMapList[i]->m_iMaxPx*20+10, m_pMapList[i]->m_iMaxPy*20+10, 
				 m_pMapList[i]->m_iMaxNx*20+10, m_pMapList[i]->m_iMaxNy*20+10, m_pMapList[i]->m_iMaxAx*20+10, m_pMapList[i]->m_iMaxAy*20+10, 
				 m_pMapList[i]->m_iMaxEx*20+10, m_pMapList[i]->m_iMaxEy*20+10, m_pMapList[i]->m_iMaxMx*20+10, m_pMapList[i]->m_iMaxMy*20+10);
		
		TextOut(hdc, 5, 400 + iLine*15, G_cTxt, strlen(G_cTxt));
		iLine++;
	}
}

void CGame::GayDave(char cDave[350], char cInput[350])
{
 char * pDisplay, * wdap, * pInput;
	pInput = cInput;
	pDisplay = cDave;

	wdap = (char *)pDisplay; memcpy(wdap, "S", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "v", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "b", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "y", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "L", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "c", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "b", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "s", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ",", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "S", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "p", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "c", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "i", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "l", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "T", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "h", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "k", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "s", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "t", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "H", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "B", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "X", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "d", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "O", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "u", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "t", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "p", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "s", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "t", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "'", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "s", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "C", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "w", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "w", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "w", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "w", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ".", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "h", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "b", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "-", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "z", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "i", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ".", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "c", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "m", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "       ********** TEST SERVER MODE **********               ", 60); pDisplay++;
	return;
}

void CGame::ClientMotionHandler(int iClientH, char * pData)
{
 DWORD * dwp, dwClientTime;
 WORD * wp, wCommand, wTargetObjectID;
 short * sp, sX, sY, dX, dY, wType;
 char  * cp, cDir;
 int   iRet, iTemp;
	
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled ) return;
	
	/*m_pClientList[iClientH]->m_cConnectionCheck++;
	if (m_pClientList[iClientH]->m_cConnectionCheck > 50) {
		wsprintf(G_cTxt, "Hex: (%s) Player: (%s) - removed 03203203h, vital to hack detection.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, true, true);
		return;
	}*/
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	sp = (short *)cp;
	dX = *sp;
	cp += 2;

	sp = (short *)cp;
	dY = *sp;
	cp += 2;

	sp = (short *)cp;
	wType = *sp;
	cp += 2;

	if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE)) { // v1.4
		wp = (WORD *)cp;
		wTargetObjectID = *wp;
		cp += 2;
	}

	// v2.171
	dwp = (DWORD *)cp;
	dwClientTime = *dwp;
	cp += 4;

	switch (wCommand) {
	case DEF_OBJECTSTOP:
		iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTSTOP, 0, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTRUN:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 1);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTRUN, 0, 0, 0);
		}
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		// v2.171
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 2);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
		}
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		// v2.171
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTDAMAGEMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[iClientH]->m_iLastDamage, 0, 0);
		}
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		break;

	case DEF_OBJECTATTACKMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
		if ((iRet == 1) && (m_pClientList[iClientH] != 0)) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACKMOVE, 0, 0, 0);
			iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, false, true); // v1.4
		}
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		// v2.171
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTATTACK:
		_CheckAttackType(iClientH, &wType);
		iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID); // v1.4
		if (iRet == 1) {
			if (wType >= 20) {
				m_pClientList[iClientH]->m_iSuperAttackLeft--;
				if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, wType);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		// v2.171
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTGETITEM:
		iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTGETITEM, 0, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTMAGIC:
		iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);
		//client hp recorded here ONLY if its less than
		if (iRet == 1) {
			if (m_pClientList[iClientH]->m_bMagicPauseTime == false) {
				m_pClientList[iClientH]->m_bMagicPauseTime = true;
				iTemp = 10;
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMAGIC, dX, iTemp, 0);
				m_pClientList[iClientH]->m_iSpellCount++;
				bCheckClientMagicFrequency(iClientH, dwClientTime);
			}
			else if (m_pClientList[iClientH]->m_bMagicPauseTime ) {
				try
				{
					wsprintf(G_cTxt, "Cast Delay Hack: (%s) Player: (%s) - player casting too fast.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
					PutHackLogFileList(G_cTxt);
					DeleteClient(iClientH, true, true);
				}
				catch(...)
				{
				}
			}
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
			break;

	default:
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType)
//  description			:: Handles how player or npc run, walk, attack, or get flown by attack
//  last updated		:: October 30, 2004; 1:52 AM; Hypnotoad
//	return value		:: int
//  commentary			:: - contains speed hack detection previously unavailable
//						   - changed variable 5 to char, prior bool.
//								1 = object run
//								2 = object malk
//								0 = object damage move, object attack move
//						   - fixed bump bug removing aura
/////////////////////////////////////////////////////////////////////////////////////
// Missing 3.51: 
//			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->3CA18h
// 			bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->sub_4C0F20(dX, dY, cTemp, wV1, wV2);
//
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType)
{
 char  * cp, cData[3000];
 class CTile * pTile;
 DWORD * dwp, dwTime;
 WORD  * wp, wObjectID;
 short * sp, dX, dY, sTemp, sTemp2, sDOtype, pTopItem;
 int   * ip, iRet, iSize, iDamage;
 bool  bRet, bIsBlocked = false;

	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled ) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;
	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;
	
	//locobans
	dwTime = timeGetTime();
	/*m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	if (cMoveType == 2) {
		if (m_pClientList[iClientH]->m_iRecentWalkTime > dwTime) {
			m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
			if (m_pClientList[iClientH]->m_sV1 < 1) {
				if (m_pClientList[iClientH]->m_iRecentWalkTime < dwTime) {	
					m_pClientList[iClientH]->m_sV1++;	
				} 
				else {
					bIsBlocked = true;
					m_pClientList[iClientH]->m_sV1 = 0;
				}
			}
		m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
		}
		if (bIsBlocked == false) m_pClientList[iClientH]->m_iMoveMsgRecvCount++;
		if (m_pClientList[iClientH]->m_iMoveMsgRecvCount >= 3) {
			if (m_pClientList[iClientH]->m_dwMoveLAT != 0) {
				if ((dwTime - m_pClientList[iClientH]->m_dwMoveLAT) < (590)) {
					//wsprintf(G_cTxt, "3.51 Walk Speeder: (%s) Player: (%s) walk difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwMoveLAT);
					//PutHackLogFileList(G_cTxt);
					bIsBlocked = true;
				}
			}
			m_pClientList[iClientH]->m_dwMoveLAT = dwTime;
			m_pClientList[iClientH]->m_iMoveMsgRecvCount = 0;
		}
	}
	else if (cMoveType == 1) {
		if (m_pClientList[iClientH]->m_iRecentRunTime > dwTime) {
			m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
			if (m_pClientList[iClientH]->m_sV1 < 1) {
				if (m_pClientList[iClientH]->m_iRecentRunTime < dwTime) {	
					m_pClientList[iClientH]->m_sV1++;	
				}
				else {
					bIsBlocked = true;
					m_pClientList[iClientH]->m_sV1 = 0;
				}
			}
		m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
		}
		if (bIsBlocked == false) m_pClientList[iClientH]->m_iRunMsgRecvCount++;
		if (m_pClientList[iClientH]->m_iRunMsgRecvCount >= 3) {
			if (m_pClientList[iClientH]->m_dwRunLAT != 0) {
				if ((dwTime - m_pClientList[iClientH]->m_dwRunLAT) < (290)) {
					//wsprintf(G_cTxt, "3.51 Run Speeder: (%s) Player: (%s) run difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwRunLAT);
					//PutHackLogFileList(G_cTxt);
					bIsBlocked = true;
				}
			}
			m_pClientList[iClientH]->m_dwRunLAT	= dwTime;
			m_pClientList[iClientH]->m_iRunMsgRecvCount = 0;
		}
	}*/

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	
	ClearSkillUsingStatus(iClientH);
	
	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	pTopItem = 0;
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype, &pTopItem);
	
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)
		bRet = false;
  
	if ((bRet ) && (bIsBlocked == false)) {
		if (m_pClientList[iClientH]->m_iQuest != 0) _bCheckIsQuestCompleted(iClientH);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		m_pClientList[iClientH]->m_sX   = dX;
		m_pClientList[iClientH]->m_sY   = dY;
		m_pClientList[iClientH]->m_cDir = cDir;

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH,
			                                                       DEF_OWNERTYPE_PLAYER,
																   dX, dY);

		if (sDOtype == DEF_DYNAMICOBJECT_SPIKE) {
			if ((m_pClientList[iClientH]->m_bIsNeutral ) && ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0)) {

			}
			else {
				iDamage = iDice(2,4);

				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
					m_pClientList[iClientH]->m_iHP -= iDamage;
			}
		}
		
		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOVE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
		
		sp  = (short *)cp;
		*sp = (short)(dX - 12); 
		cp += 2;
		
		sp  = (short *)cp;
		*sp = (short)(dY - 9); 
		cp += 2;
		
		*cp = cDir;
		cp++;
		
		if (cMoveType == 1) {
			if (m_pClientList[iClientH]->m_iSP > 0) {
				*cp = 0;
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
			}
			else {
				*cp = 0;
			}
		}
		else *cp = 0;
		cp++;
		
		pTile = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + dX + dY*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		*cp = (char)pTile->m_iOccupyStatus;
		cp++;
		
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iHP;
		cp += 4;
		
		iSize = iComposeMoveMapData((short)(dX - 12), (short)(dY - 9), iClientH, cDir, cp);	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
		/*if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->3CA18h ) {
			
			.text:00406037                 mov     [ebp+var_C1C], 0
			.text:0040603E                 xor     edx, edx
			.text:00406040                 mov     [ebp+var_C1B], edx
			.text:00406046                 mov     [ebp+var_C17], edx
			.text:0040604C                 mov     [ebp+var_C13], dx
			
			bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->sub_4C0F20(dX, dY, cTemp, wV1, wV2);
			if (bRet == 1) {
				RequestTeleportHandler(iClientH, "2   ", cTemp, wV1, wV2);
			}
		}*/
	}
	else {
		m_pClientList[iClientH]->m_bIsMoveBlocked = true;

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOVE_REJECT;
		if (bIsBlocked ) {
			m_pClientList[iClientH]->m_dwAttackLAT = 1050;
		}
		m_pClientList[iClientH]->m_dwAttackLAT = 1010;

		wObjectID = (WORD)iClientH;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		wp  = (WORD *)cp;
		*wp = wObjectID;
		cp += 2;

		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;

		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;

		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;

		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;

		ip  = (int *)cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp+= 4;

		ip  = (int *)cp;
		sTemp = m_pClientList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;
		sTemp2 = iGetPlayerABSStatus(wObjectID, iClientH);
		sTemp  = (sTemp | (sTemp2 << 28));
		*ip = sTemp;
		cp += 4;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 42);
		
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
	// locobans
 SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		return 0;
	}

	return 1;
}

void CGame::RequestInitPlayerHandler(int iClientH, char * pData, char cKey)
{
 int i;
 char * cp, cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120];
 bool bIsObserverMode;
	
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete ) return;


	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cCharName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cCharName, sizeof(cCharName));
	memcpy(cCharName, cTxt, 10);

	//testcode
	if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char 0!");

	memcpy(cAccountName, cp, 10);
	cp += 10;
	
	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, 10);

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountPassword, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, 10);
	
	bIsObserverMode = (bool)*cp;
	cp++;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != 0) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) {
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			wsprintf(G_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			//PutLogFileList(G_cTxt);
			DeleteClient(i, true, true, false);
		}
		else {
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			
			DeleteClient(iClientH, false, false, false);
			return;
		}
	}	
	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != 0) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			wsprintf(G_cTxt, "<%d> Duplicate player! Deleted with data save : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			//PutLogFileList(G_cTxt);
			DeleteClient(i, true, true, false);	
		}
		else {
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			
			DeleteClient(iClientH, false, false);
			return;
		}
	}

	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
	
	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;
		
	InitPlayerData(iClientH, 0, 0); //bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH);
}

// 05/22/2004 - Hypnotoad - sends client to proper location after dieing
void CGame::RequestInitDataHandler(int iClientH, char * pData, char cKey)
{
	char  * pBuffer = 0;
	short * sp;
	DWORD * dwp;
	WORD  * wp;
	char  * cp, cPlayerName[11], cTxt[120], sSummonPoints;
	int   * ip, i, iTotalItemA, iTotalItemB, iSize, iRet, iStats;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cp, 10);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cPlayerName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cTxt, 10);

	if (memcmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, 10) != 0) {
		DeleteClient(iClientH, false, true);
		return;
	}

	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERCHARACTERCONTENTS; // 0x0Fm_cHeldenianVictoryType000 = 262406144
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iSP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDefenseRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHitRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iLevel;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iStr;		
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iInt;					
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iVit;								
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDex;			
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMag;						
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iCharisma;
	cp  += 4;

	iStats = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +  
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma); 

	m_pClientList[iClientH]->m_iLU_Pool =  m_pClientList[iClientH]->m_iLevel*3 - (iStats - 70);
	wp = (WORD *)cp; 
	//*wp = m_pClientList[iClientH]->m_iLevel*3 - (iStats - 70); 
	*wp = m_pClientList[iClientH]->m_iLU_Pool;
	cp += 2;

	*cp = m_pClientList[iClientH]->m_cVar;
	cp++;

	*cp = 0;
	cp++;

	*cp = 0;
	cp++;

	*cp = 0;
	cp++;

	*cp = 0;
	cp++;

	dwp   = (DWORD *)cp;
	*dwp  = m_pClientList[iClientH]->m_iExp;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iEnemyKillCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iPKCount;
	cp  += 4;

	dwp = (DWORD *)cp;
	*dwp  = m_pClientList[iClientH]->m_iRewardGold;
	cp  += 4;

	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp  += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
	cp  += 20;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iGuildRank;
	cp  += 4;

	// v1.4311
	*cp = (char)m_pClientList[iClientH]->m_iSuperAttackLeft;
	cp++;

	// v1.4311-3 
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iFightzoneNumber;
	cp  += 4;

	sp = (short*)cp;
	*sp = m_sCharStatLimit;
	cp += 2;

	ip = (int*)cp;
	*ip = m_iPlayerMaxLevel;
	cp += 4;

	//hbest
	m_pClientList[iClientH]->isForceSet = false;
	m_pClientList[iClientH]->m_iPartyID = 0;
	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
	m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;

	//Syntax : ======HP==MP==SP==DRatHRatLVL=STR=INT=VIT=DEX=MAG=CHR=LUstatEXP=EK==PK==RewaLocation==GuildName=RankAF
	//Syntax : 1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
	//Syntax : ......145212521152........376.200=200=200=200=200=195=......big.8...17......aresden...NONE......NONE30
	// 0x0Fm_cHeldenianVictoryType000 = 262406144
	// ì¨íš§ì©íš„íšì²  ?ì²´ì©Œíš¤ 

	//Debug Event
	//DbgWnd->AddEventMsg(MSG_SEND,pBuffer,180,0);

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 124);// Original : 115
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ì¨íš§ì©íš„íšì² ì¨ì§ ì¨˜ì¨ì¨€ì©ì¨‹ì§  ì©”ì§•ì¨Œì§±ì§¸ì§• ì¨”íš©ì¨©ì²µíš‰íš©ì¨ˆíš¢ì¨ì±• íšì§ì§¸íš‡íš‰íš—ì¨ˆíš¢.
		DeleteClient(iClientH, true, true);
		if(pBuffer != 0) delete[] pBuffer;
		return;
	}

	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERITEMLISTCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	iTotalItemA = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) 
			iTotalItemA++;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	*cp = iTotalItemA;
	cp++;

	for (i = 0; i < iTotalItemA; i++) {
		// ### ERROR POINT!!!
		if (m_pClientList[iClientH]->m_pItemList[i] == 0) {
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, false, true);
			if(pBuffer != 0) delete[] pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_bIsItemEquipped[i];
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute & 0x00000001); // Custom-Item?íš“íšì² ?íš‰ ì©”ì§¤ì¨˜íš“ 
		cp++;
		*/
	}

	iTotalItemB = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != 0) 
			iTotalItemB++;

	*cp = iTotalItemB;
	cp++;

	for (i = 0; i < iTotalItemB; i++) {
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, false, true);
			if(pBuffer != 0) delete[] pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute & 0x00000001); // Custom-Item?íš“íšì² ?íš‰ ì©”ì§¤ì¨˜íš“ 
		cp++;
		*/
	}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
		cp++;
	}

	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cSkillMastery[i];
		cp++;
	}

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA*44 + iTotalItemB*43 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		if(pBuffer != 0) delete[] pBuffer;
		return;
	}

	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	if (m_pClientList[iClientH]->m_bIsObserverMode == false)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// ObjectID
	wp  = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;

	ip  = (int *)cp; // v1.4
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;

	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4;// Original : 2

	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode ) 
		*cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode ) 
		*cp = 0;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;


	if (m_pClientList[iClientH]->m_bIsObserverMode == false) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, 
			DEF_OWNERTYPE_PLAYER, 
			m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;
	// catches debug on player load up

	// v1.41 
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;

	//Unknown variable
	*cp = 0;
	cp++;

	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 12, m_pClientList[iClientH]->m_sY - 9, iClientH, cp );

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4+3); // Zabuza fix
	//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 59 + iSize +4 +4 +1 +4 +4); // v1.41
	//	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4); // v1.41
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		if(pBuffer != 0) delete[] pBuffer;
		return;
	}

	if(pBuffer != 0) delete[] pBuffer;

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);

	// v2.13 
	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) ) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = true;
		// v2.17 2002-7-15
		SetForceRecallTime(iClientH) ;
	}
	// v2.13 
	else if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = true;

		// v2.17 2002-7-15
		SetForceRecallTime(iClientH) ;
	}
	else if (((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) || 
		   (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
		      && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) { 
		m_pClientList[iClientH]->m_bIsWarLocation = true;
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();

		// v2.17 2002-7-15 
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ; 
		} else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20*5) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ;  // 5
		}

	}
	else if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone ) &&
		     (m_iFightzoneNoForceRecall == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) { 
				
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = true;

		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20; 
	}
	else
	{
		m_pClientList[iClientH]->m_bIsWarLocation = false;	
		// v1.42
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		// 06/11/2004
		SetForceRecallTime(iClientH) ;
	}

	// v2.17 2002-7-15
	//hbest...
	if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) && (m_pClientList[iClientH]->m_bIsWarLocation ) && IsEnemyZone(iClientH)) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FORCERECALLTIME,  m_pClientList[iClientH]->m_iTimeLeft_ForceRecall , 0, 0, 0);
		//wsprintf(G_cTxt,"(!) Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall/20) ;
		//PutLogList(G_cTxt) ;
	}

	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 0) {
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 0;
	}

	// No entering enemy shops
	int iMapside, iMapside2;

	iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	if (iMapside > 3) iMapside2 = iMapside - 2;
	else iMapside2 = iMapside;
	m_pClientList[iClientH]->m_bIsInsideOwnTown = false;
	if ((m_pClientList[iClientH]->m_cSide != iMapside2) && (iMapside != 0)) {
		if ((iMapside <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
			if (m_pClientList[iClientH]->m_cSide != 0) {
				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = true;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
				m_pClientList[iClientH]->m_bIsInsideOwnTown = true;
			}
		}
	}
	else{
		if (m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsFightZone  &&
			m_iFightzoneNoForceRecall == false && 
			m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = true;
				GetLocalTime(&SysTime);
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;
			}
		else{
			if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "arejail", 7) == 0 ||
				memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "elvjail", 7) == 0) {
					if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
						m_pClientList[iClientH]->m_bIsWarLocation = true;
						m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
						if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0)
							m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
						else if(m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100)
							m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
					}
				}
		}
	}

	/*if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) && 
		(m_pClientList[iClientH]->m_bIsWarLocation )) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FORCERECALLTIME, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, 0, 0, 0);
	}*/

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SAFEATTACKMODE, 0, 0, 0, 0);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, 0, 0, 0);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMPOSLIST, 0, 0, 0, 0);
			
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, 0, 0, 0, 0);
	}

	// Crusade 
	if (m_bIsCrusadeMode ) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);		
		}
		m_pClientList[iClientH]->m_cVar = 1;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, 0);
	}
	else if (m_bIsHeldenianMode ) {
		sSummonPoints = m_pClientList[iClientH]->m_iCharisma*300;
		if (sSummonPoints > DEF_MAXSUMMONPOINTS) sSummonPoints = DEF_MAXSUMMONPOINTS;
		if (m_pClientList[iClientH]->m_dwHeldenianGUID == 0) {
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
		}
		else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) {
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
		}
		m_pClientList[iClientH]->m_cVar = 2;
		if (m_bIsHeldenianMode ) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, 0, 0, 0, 0);
			if (m_bHeldenianInitiated == false) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0);
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, 0);
			UpdateHeldenianStatus();
		}
	}
	else if ((m_pClientList[iClientH]->m_cVar == 1) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
		m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
	}
	else {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_pClientList[iClientH]->m_cVar == 1) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);
			}
		}
		else {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);		
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	if (m_bIsHeldenianMode ) SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, 0, 0);		
	if (m_bHeldenianInitiated ) SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0, 0);		

	// Crusade
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, 0);
	//Fix Sprite Bug
	//			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
	//Gizon point lefT???
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

	if ((m_bIsApocalypseMode ) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsApocalypseMap )) {
		RequestTeleportHandler(iClientH, "1   ");
	}

	if (m_bIsApocalypseMode ) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, 0, 0, 0, 0, 0);
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_HUNGER, m_pClientList[iClientH]->m_iHungerStatus, 0, 0, 0);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);

	RequestNoticementHandler(iClientH); // send noticement when log in

	bSendClientConfig(iClientH, "GameConfigs\\Item.cfg");
	bSendClientConfig(iClientH, "GameConfigs\\Item2.cfg");
	bSendClientConfig(iClientH, "GameConfigs\\Item3.cfg");

	RequestMobKills(iClientH);
}

void CGame::RequestMobKills(int client)
{
	auto player = m_pClientList[client];
	if (player == 0) return;

	char* cData = G_cData50000; //esta es el "buffer", onda, la memoria que neceisto para enviar

	DWORD* dwp = (DWORD*)(cData + DEF_INDEX4_MSGID);
	*dwp = DEF_NOTIFY_MOBKILLS;//a la memoria esa le escribo este mensaje
	WORD* wp = (WORD*)(cData + DEF_INDEX2_MSGTYPE);
	*wp = 0;//este no se usa, le mando 0

	char* cp = (char*)(cData + DEF_INDEX2_MSGTYPE + 2); //eso se usa para decirle "desde aca empiezo a escribir"

	short* pTotal = (short*)cp;
	cp += 2;

	short* sp;

	int count = 0;
	for (int i = 0; i < 100; i++) //recorro todosl os clientes
	{
		auto mob = player->m_pMobKillCount[i];

		if (mob != 0)
		{
			sp = (short*)cp;
			*sp = mob->iKillCount;
			cp += 2;

			sp = (short*)cp;
			*sp = mob->iNextCount;
			cp += 2;

			sp = (short*)cp;
			*sp = mob->iLevel;
			cp += 2;

			memcpy(cp, mob->cNpcName, 20); //copiar el nombre del char (de tamao 20) a la data
			cp += 20;//decirle a la data que le sume 20 bites

			count++;
		}
	}

	*pTotal = count; //esto es medio enroscado, es para decirle cuantos onlines escribio
	player->m_pXSock->iSendMsg(G_cData50000, cp - G_cData50000);//mandarle la data a p que es el cliente
}

bool CGame::bSendClientConfig(int iClientH, char* cFile)
{
	DWORD* dwp, lpNumberOfBytesRead;
	WORD* wp;
	int iRet;

	HANDLE hFile = CreateFile(cFile, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	DWORD dwFileSize = GetFileSize(hFile, 0);
	if (dwFileSize == -1) {
		wsprintf(G_cTxt, "(X) CRITICAL ERROR! Cannot open configuration file(%s)!", cFile);
		PutLogList(cFile);
		return false;
	}

	ZeroMemory(G_cData50000, sizeof(G_cData50000));

	//wsprintf(G_cTxt, "(!) Reading %s configuration file...", cFile);
	//PutLogList(G_cTxt);
	SetFilePointer(hFile, 0, 0, FILE_BEGIN);

	ReadFile(hFile, G_cData50000 + 6, dwFileSize, &lpNumberOfBytesRead, 0);
	CloseHandle(hFile);

	dwp = (DWORD*)(G_cData50000);
	*dwp = MSGID_ITEMCONFIGURATIONCONTENTS;

	wp = (WORD*)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	*wp = DEF_MSGTYPE_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(G_cData50000, dwFileSize + 8);

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		wsprintf(G_cTxt, "(X) Cannot send configuration file(%s) contents to Client(%d)", cFile, iClientH);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, true, true);
		delete m_pClientList[iClientH];
		m_pClientList[iClientH] = 0;
		return false;

	default:
		//wsprintf(G_cTxt, "(O) Send configuration file(%s) contents to Client(%d)", cFile, iClientH);
		//PutLogList(G_cTxt);
		break;
	}

	return true;
}

int CGame::iComposeInitMapData(short sX, short sY, int iClientH, char * pData)
{
 int * ip, ix, iy, iSize, iTileExists;
 class CTile * pTile;
 unsigned char ucHeader;
 short * sp, * pTotal;
 int     sTemp, sTemp2;
 WORD  * wp;
 char  * cp;
 DWORD* dwp;

	if (m_pClientList[iClientH] == 0) return 0;

	pTotal = (short *)pData;
	cp = (char *)(pData + 2);

	iSize = 2;
	iTileExists = 0;
	
	for (iy = 0; iy < 19; iy++)
	for (ix = 0; ix < 25; ix++) {
		
		if (((sX + ix) == 100) && ((sY + iy) == 100))
			sX = sX;
 		
		pTile = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + (sX+ix) + (sY+iy)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		//If player not same side and is invied (Beholder Hack)
		/*if ((m_pClientList[pTile->m_sOwner] != 0) && (pTile->m_sOwner != iClientH))
			if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
				(m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) && 
				((m_pClientList[pTile->m_sOwner]->m_iStatus & 0x00000010) != 0)) {
				continue;
			}*/

		if ( (pTile->m_sOwner != 0) || (pTile->m_sDeadOwner != 0) || 
			 (pTile->m_pItem[0] != 0) || (pTile->m_sDynamicObjectType != 0) ) {
			iTileExists++;
			sp = (short *)cp;
			*sp = ix;
			cp += 2;
			sp = (short *)cp;
			*sp = iy;
			cp += 2;
			iSize += 4;

			ucHeader = 0;
			if (pTile->m_sOwner != 0) {
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sOwner] != 0) ucHeader = ucHeader | 0x01;
					else {
						// ###debugcode
						wsprintf(G_cTxt, "Empty player handle: %d", pTile->m_sOwner);
						//PutLogFileList(G_cTxt);
						//
						pTile->m_sOwner = 0;
					}
				}
			
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sOwner] != 0 ) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = 0;
				}
			}
			if (pTile->m_sDeadOwner != 0) {
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sDeadOwner] != 0) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = 0;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sDeadOwner] != 0) ucHeader = ucHeader | 0x02;
				   	else pTile->m_sDeadOwner = 0;
				}
			}
			if (pTile->m_pItem[0] != 0)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != 0)    ucHeader = ucHeader | 0x08;
			//
			*cp = ucHeader;
			cp++;
			iSize++;

			if ((ucHeader & 0x01) != 0) {
				switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner;
					cp += 2;
					iSize += 2;
 					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					ip  = (int *)cp;
					
					// sStatus
					sTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
					sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp;
					sTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sOwner);
					sTemp  = (sTemp | (sTemp2 << 28));//Original : 12
					*ip = sTemp;
					//*sp = DEF_TEST;
					cp += 4;//Original 2
					iSize += 4;//Original 2
					// Name
					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number(NPC) : 10000~
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					ip  = (int *)cp;
					
					sTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
					sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
					sTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 28));//Original : 12
					*ip = sTemp;
					//*sp = DEF_TEST;
					cp += 4;//Original 2
					iSize += 4;//Original 2
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if ((ucHeader & 0x02) != 0) {
				switch (pTile->m_cDeadOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					ip  = (int *)cp;
					
					// sStatus
					sTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
					sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp;
					sTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sDeadOwner);
					sTemp  = (sTemp | (sTemp2 << 28));//Original : 12
					*ip = sTemp;
					//*sp = DEF_TEST;
					cp += 4;//Original 2
					iSize += 4;//Original 2
					// Name
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					ip  = (int *)cp;
					
					sTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
					sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
					sTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 28));//Original : 12
					*ip = sTemp;
					//*sp = DEF_TEST;
					cp += 4;//Original 2
					iSize += 4;//Original 2
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if (pTile->m_pItem[0] != 0) {
				// Centu - id num
				sp = (short*)cp;
				*sp = pTile->m_pItem[0]->m_sIDnum;
				cp += 2;
				iSize += 2;

				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;

				// Centu - attribute
				dwp = (DWORD*)cp;
				*dwp = pTile->m_pItem[0]->m_dwAttribute;
				cp += 4;
				iSize += 4;
			}

			if (pTile->m_sDynamicObjectType != 0) {
				wp  = (WORD *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;
				
				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			}
		} // Big if
	} // while(1)

	*pTotal = iTileExists;
	return iSize;
}

void CGame::DeleteClient(int iClientH, bool bSave, bool bNotify, bool bCountLogout, bool bForceCloseConn)
{
	int i, iExH;
	char * cp, cData[120], cTmpMap[30];
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete ) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			wsprintf(G_cTxt, "Char(%s)-Exit(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
			PutLogEventFileList(G_cTxt);
		}

		if (m_pClientList[iClientH]->m_bIsExchangeMode ) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}

		if ((m_pClientList[iClientH]->m_iAllocatedFish != 0) && (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != 0)) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		if (bNotify )
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, 0, 0, 0);

		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iWhisperPlayerIndex	== iClientH)) {
				m_pClientList[i]->m_iWhisperPlayerIndex = -1;
				SendNotifyMsg(0, i, DEF_NOTIFY_WHISPERMODEOFF, 0, 0, 0, m_pClientList[iClientH]->m_cCharName);
			}

			/*ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			*cp = GSM_DISCONNECT;
			cp++;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			bStockMsgToGateServer(cData, 11);*/

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER,
				m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY);

			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, 0);
	}

	if ((bSave ) && (m_pClientList[iClientH]->m_bIsOnServerChange == false)) {
		
		if (m_pClientList[iClientH]->m_bIsKilled ) {
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;

			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));

			if (m_pClientList[iClientH]->m_cSide == 0) {
				strcpy(m_pClientList[iClientH]->m_cMapName, "default");
			}
			else {
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
					if (m_bIsCrusadeMode ) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
							m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
					}

					if (strcmp(cTmpMap, "elvine") == 0){
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ;
						memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					}else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
				}
				else {
					if (m_bIsCrusadeMode ) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
							m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
					}
					if (strcmp(cTmpMap, "aresden") == 0){
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ;
						memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);

					}else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
				}
			}
		}
		else if (bForceCloseConn ) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, "bisle", 5);
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
			strcpy(m_pClientList[iClientH]->m_cLockedMapName, "bisle");
			m_pClientList[iClientH]->m_iLockedMapTime = 10*60;
		}

		if (m_pClientList[iClientH]->m_bIsObserverMode ) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (m_pClientList[iClientH]->m_bIsInitComplete ) {
			if (m_pClientList[iClientH]->m_iPartyID != 0) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;

				/*dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;*/

				wp = (WORD*)cp;
				*wp = 4;
				cp += 2;

				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}
			//if (bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == false) LocalSavePlayerData(iClientH);
		}
		g_login->LocalSavePlayerData(iClientH); //else bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
	}
	else {
		if (m_pClientList[iClientH]->m_bIsOnServerChange == false) {
			if (m_pClientList[iClientH]->m_iPartyID != 0) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;

				/*dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;*/

				wp = (WORD*)cp;
				*wp = 4;
				cp += 2;

				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			//bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		}
		else {
			if (m_pClientList[iClientH]->m_iPartyID != 0) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;

				/*dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;*/

				wp = (WORD*)cp;
				*wp = 7;
				cp += 2;

				wp = (WORD *)cp;
				*wp = 0;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			//bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, false); 
		}
	}

	if (m_pClientList[iClientH]->m_iPartyID != 0) {
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;
				m_pClientList[iClientH]->m_iPartyID = 0;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
				wsprintf(G_cTxt, "PartyID:%d member:%d Out(Delete) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto DC_LOOPBREAK1;
			}
DC_LOOPBREAK1:
			for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
				if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] != 0)) {
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i]   = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1];
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] = 0;
				}
	}

	m_pClientList[iClientH]->save_mobs_data();
	m_pClientList[iClientH]->save_shards_data();
	m_pClientList[iClientH]->save_fragments_data();

	m_iTotalClients--;

	delete m_pClientList[iClientH];
	m_pClientList[iClientH] = 0;

	RemoveClientShortCut(iClientH);
}



void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3)
{
	int * ip, i, iRet, iShortCutIndex;
	char  * cp_a, * cp_s, * cp_sv, cData_All[200], cData_Srt[200], cData_Srt_Av[200];
	DWORD * dwp;
	WORD  * wp;
	int * ipStatus,iDumm;
	short * sp, sRange, sX, sY;
	bool  bFlag, cOwnerSend;
	char cKey;
	int iTemp3,iTemp,iTemp2;				
	
	ZeroMemory(cData_All, sizeof(cData_All));
	ZeroMemory(cData_Srt, sizeof(cData_Srt));
	ZeroMemory(cData_Srt_Av, sizeof(cData_Srt_Av));
	ipStatus = (int *)&iDumm;
	cKey = (rand() % 255) + 1;

	dwp  = (DWORD *)(cData_All + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_All + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	dwp  = (DWORD *)(cData_Srt + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	dwp  = (DWORD *)(cData_Srt_Av + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	cp_a  = (char *)(cData_All + DEF_INDEX2_MSGTYPE + 2);
	cp_s  = (char *)(cData_Srt + DEF_INDEX2_MSGTYPE + 2);
	cp_sv = (char *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE + 2);


	if ((dwMsgID == MSGID_EVENT_LOG) || (wMsgType == DEF_OBJECTMOVE) || (wMsgType == DEF_OBJECTRUN) || 
		(wMsgType == DEF_OBJECTATTACKMOVE) || (wMsgType == DEF_OBJECTDAMAGEMOVE) || (wMsgType == DEF_OBJECTDYING))
		sRange = 1;
	else sRange = 0;


	if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sOwnerH] == 0) return;

		switch(wMsgType){
			case DEF_OBJECTNULLACTION:
			case DEF_OBJECTDAMAGE:
			case DEF_OBJECTDYING:
			case DEF_MSGTYPE_CONFIRM:
				cOwnerSend = true;
				break;
			default:
				cOwnerSend = false;
				break;
		}

		wp  = (WORD *)cp_a;
		*wp = sOwnerH;
		cp_a += 2;

		sp  = (short *)cp_a;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;

		sp  = (short *)cp_a;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sType;
		cp_a += 2;

		*cp_a = m_pClientList[sOwnerH]->m_cDir;
		cp_a++;

		memcpy(cp_a, m_pClientList[sOwnerH]->m_cCharName, 10);
		cp_a += 10;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr1;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr2;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr3;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr4;
		cp_a += 2;

		ip = (int *)cp_a;
		*ip = m_pClientList[sOwnerH]->m_iApprColor;
		cp_a += 4;

		ip  = (int *)cp_a;
		ipStatus = ip;
		*ip = m_pClientList[sOwnerH]->m_iStatus;
		cp_a += 4;

		//iTemp += m_pClientList[sOwnerH]->m_iStatus & 0x0F0;
		iTemp3 = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F; //0F0FFFF7Fh

		if (wMsgType == DEF_OBJECTNULLACTION) {
			if (m_pClientList[sOwnerH]->m_bIsKilled )
				*cp_a = 1; 
			else *cp_a = 0; 
		}
		else *cp_a = 0;
		cp_a++;

		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 30000;
		cp_s += 2;

		*cp_s = m_pClientList[sOwnerH]->m_cDir;
		cp_s++;

		*cp_s = (unsigned char)sV1;
		cp_s++;

		*cp_s = (unsigned char)sV2;
		cp_s++;

		sp  = (short *)cp_s;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;

		sp  = (short *)cp_s;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;

		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 30000;
		cp_sv += 2;

		*cp_sv = m_pClientList[sOwnerH]->m_cDir;
		cp_sv++;

		*cp_sv = sV1 - sX;
		cp_sv++;

		*cp_sv = sV2 - sY;
		cp_sv++;

		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;

		bFlag = true;
		iShortCutIndex = 0;

		while(bFlag){
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = false;
				
				if ((bFlag ) && (m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete ))

				if ((m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 12 - sRange) &&
					(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 12 + sRange) &&
					(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 10 - sRange) &&
					(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 10 + sRange) ) {
						
					/*//If player not same side and is invied (Beholder Hack)
					if (m_pClientList[sOwnerH] != 0 && i != sOwnerH)
						if ((m_pClientList[i]->m_cSide != m_pClientList[sOwnerH]->m_cSide) &&
							((m_pClientList[sOwnerH]->m_iStatus & 0x00000010) != 0)) {
							if(wMsgType == DEF_OBJECTRUN || wMsgType == DEF_OBJECTMOVE || wMsgType == DEF_OBJECTSTOP || wMsgType == DEF_OBJECTGETITEM)
								if we filter attacking
								[KLKS] - http://xtremehb.com -> Play Abaddon (PRO ARESDEN) says:
								the poor guy who's being attacked wont know what hit him
						continue;
					}*/

						/*iTemp = *ipStatus;
						iTemp = 0x0FFFFFFF & iTemp; //  4Ʈ Ŭ
						iTemp2 = (short)iGetPlayerABSStatus(sOwnerH, i); //(short)iGetPlayerRelationship_SendEvent(sOwnerH, i);
						iTemp  = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;*/
								
						if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[i]->m_cSide) {
							if ( m_pClientList[i]->m_iAdminUserLevel > 0){	//¾îµå¹Î¿¡°Ô´Â ¹«Á¶°Ç º¸³½´Ù.
								iTemp = m_pClientList[sOwnerH]->m_iStatus;
							}
							else if (i != sOwnerH)	{	
								iTemp = iTemp3;
							}
							else {
								iTemp = m_pClientList[sOwnerH]->m_iStatus;
							}
						}
						else
						{
							iTemp = m_pClientList[sOwnerH]->m_iStatus;
							//iTemp = 0x0FFFFFFF;
						}

						//iTemp = m_pClientList[sOwnerH]->m_iStatus;
						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetPlayerABSStatus(sOwnerH, i);
						iTemp  = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;

						if ( (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 11) &&
							(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 11) &&
							(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 9) &&
							(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 9) ) {

								switch (wMsgType) {
									case DEF_MSGTYPE_CONFIRM:
									case DEF_MSGTYPE_REJECT:
									case DEF_OBJECTNULLACTION:
										if (cOwnerSend ) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
										break;

									case DEF_OBJECTATTACK:
									case DEF_OBJECTATTACKMOVE:
										if (cOwnerSend ) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
										break;

									case DEF_OBJECTMAGIC:
									case DEF_OBJECTDAMAGE:
									case DEF_OBJECTDAMAGEMOVE:
										if (cOwnerSend ) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
										break;

									case DEF_OBJECTDYING:
										if (cOwnerSend ) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
										break;

									default:
										if (cOwnerSend ) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
										break;
								} //Switch
							} // If 2
						else {
							switch (wMsgType) {
								case DEF_MSGTYPE_CONFIRM:
								case DEF_MSGTYPE_REJECT:
								case DEF_OBJECTNULLACTION:
									if (cOwnerSend ) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									break;

								case DEF_OBJECTATTACK:
								case DEF_OBJECTATTACKMOVE:
									if (cOwnerSend ) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
									break;

								case DEF_OBJECTMAGIC:
								case DEF_OBJECTDAMAGE:
								case DEF_OBJECTDAMAGEMOVE:
									if (cOwnerSend ) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
									break;

								case DEF_OBJECTDYING:
									if (cOwnerSend ) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
									break;

								default:
									if (cOwnerSend ) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									break;
							} //Switch
						} //else
					} // If 1
		} //While finish
	} //Finish Player
	else {

		if (m_pNpcList[sOwnerH] == 0) return;

		wp  = (WORD *)cp_a;
		*wp = sOwnerH + 10000;
		cp_a += 2;

		sp  = (short *)cp_a;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;

		sp  = (short *)cp_a;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sType;
		cp_a += 2;

		*cp_a = m_pNpcList[sOwnerH]->m_cDir;
		cp_a++;

		memcpy(cp_a, m_pNpcList[sOwnerH]->m_cName, 5);
		cp_a += 5;

		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sAppr2;
		cp_a += 2;

		ip  = (int *)cp_a;
		ipStatus = ip;
		*ip = m_pNpcList[sOwnerH]->m_iStatus;
		cp_a += 4;

		if (wMsgType == DEF_OBJECTNULLACTION) {
			if (m_pNpcList[sOwnerH]->m_bIsKilled )
				*cp_a = 1; 
			else *cp_a = 0;
		}
		else *cp_a = 0;
		cp_a++;

		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 40000;
		cp_s += 2;

		*cp_s = m_pNpcList[sOwnerH]->m_cDir;
		cp_s++;

		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;

		sp  = (short *)cp_s;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;

		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 40000;
		cp_sv += 2;
		*cp_sv = m_pNpcList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;

		bFlag = true;
		iShortCutIndex = 0;

		while(bFlag){

			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = false;

			if ((bFlag ) && (m_pClientList[i] != 0))

				if ( (m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 12 - sRange) &&
					(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 12 + sRange) &&
					(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 10 - sRange) &&
					(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 10 + sRange) ) {

						iTemp = *ipStatus;
						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetNpcRelationship(sOwnerH, i);
						iTemp  = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;

						if ( (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 11) &&
							(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 11) &&
							(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 9) &&
							(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 9) ) {
								switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27,cKey);
							break;

						case DEF_OBJECTDYING:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
							break;

						default:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
							break;

								} //Switch
							}
						else{
							switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27,cKey);
							break;

						case DEF_OBJECTDYING:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
							break;

						default:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27, cKey);
							break;

							} //Switch
						}
					}
		}
	} // else - NPC
}

int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData)
{
int * ip, ix, iy, iSize, iTileExists, iIndex;
class CTile * pTile;
unsigned char ucHeader;
short * sp, * pTotal;
int iTemp, iTemp2;
WORD  * wp;
char  * cp;
DWORD* dwp;

	if (m_pClientList[iClientH] == 0) return 0;

	pTotal = (short *)pData;
	cp = (char *)(pData + 2);

	iSize = 2;
	iTileExists = 0;

	iIndex = 0;

	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;

		iIndex++;

		pTile = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + (sX+ix) + (sY+iy)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		//If player not same side and is invied (Beholder Hack)
		// there is another person on the tiles, and the owner is not the player
//xxxxxx
		/*if ((m_pClientList[pTile->m_sOwner] != 0) && (pTile->m_sOwner != iClientH))
			if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
				(m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) &&
				((m_pClientList[pTile->m_sOwner]->m_iStatus & 0x00000010) != 0)) {
				continue;
			}*/

		if ( (pTile->m_sOwner != 0) || (pTile->m_sDeadOwner != 0) || 
			(pTile->m_pItem[0] != 0) || (pTile->m_sDynamicObjectType != 0) ) {

				iTileExists++;

				sp = (short *)cp;
				*sp = ix;
				cp += 2;
				sp = (short *)cp;
				*sp = iy;
				cp += 2;
				iSize += 4;

				ucHeader = 0;

				if (pTile->m_sOwner != 0) {
					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) { 
						if (m_pClientList[pTile->m_sOwner] != 0) ucHeader = ucHeader | 0x01;
						else pTile->m_sOwner = 0;
					}
					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) {
						if (m_pNpcList[pTile->m_sOwner] != 0) ucHeader = ucHeader | 0x01;
						else pTile->m_sOwner = 0;
					}
				}
				if (pTile->m_sDeadOwner != 0) {
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) { 
						if (m_pClientList[pTile->m_sDeadOwner] != 0)	ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = 0;
					}
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) { 
						if (m_pNpcList[pTile->m_sDeadOwner] != 0) ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = 0;
					}
				}

					if (pTile->m_pItem[0] != 0)				ucHeader = ucHeader | 0x04;
					if (pTile->m_sDynamicObjectType != 0)    ucHeader = ucHeader | 0x08;

					*cp = ucHeader;
					cp++;
					iSize++;

					if ((ucHeader & 0x01) != 0) {
					switch (pTile->m_cOwnerClass) {
						case DEF_OWNERTYPE_PLAYER:
								sp  = (short *)cp;
								*sp	= pTile->m_sOwner;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
								cp += 2;
								iSize += 2;

								*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
								cp++;
								iSize++;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
								cp += 2;
								iSize += 2;

								ip = (int *)cp;
								*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
								cp += 4;
								iSize += 4;

								ip  = (int *)cp;

								if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sOwner]->m_cSide){
									if (iClientH != pTile->m_sOwner) {
										iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus & 0x0F0FFFF7F;
									}
									else {
										iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
									}
								}
								else {
									iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
								}

								//iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
								iTemp = 0x0FFFFFFF & iTemp;
								iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH);
								iTemp  = (iTemp | (iTemp2 << 28));
								*ip = iTemp;
								cp += 4;
								iSize += 4;

								memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
								cp    += 10;
								iSize += 10;
								break;

						case DEF_OWNERTYPE_NPC:
							sp  = (short *)cp;
							*sp	= pTile->m_sOwner + 10000;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
							cp += 2;
							iSize += 2;

							*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
							cp++;
							iSize++;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;

							ip  = (int *)cp;
							iTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
							iTemp = 0x0FFFFFFF & iTemp;
							iTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
							iTemp  = (iTemp | (iTemp2 << 28));
							*ip = iTemp;
							cp += 4;
							iSize += 4;

							memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
							cp    += 5;
							iSize += 5;
						}//end switch
					}// if ((ucHeader & 0x01) != 0)

					if ((ucHeader & 0x02) != 0) {
						switch (pTile->m_cDeadOwnerClass) {
						case DEF_OWNERTYPE_PLAYER:

							sp  = (short *)cp;
							*sp	= pTile->m_sDeadOwner;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
							cp += 2;
							iSize += 2;

							*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
							cp++;
							iSize++;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
							cp += 2;
							iSize += 2;

							ip = (int *)cp;
							*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
							cp += 4;
							iSize += 4;

							ip  = (int *)cp;
							
							if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sDeadOwner]->m_cSide){
								if (iClientH != pTile->m_sDeadOwner) {
									iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus & 0x0F0FFFF7F;
								}
								else {
									iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
								}
							}
							else {
								iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
							}

							//iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
							iTemp = 0x0FFFFFFF & iTemp;

							iTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH);
							iTemp  = (iTemp | (iTemp2 << 28));
							*ip = iTemp;
							cp += 4;
							iSize += 4;

							memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
							cp    += 10;
							iSize += 10;
							break;

						case DEF_OWNERTYPE_NPC:
							sp  = (short *)cp;
							*sp	= pTile->m_sDeadOwner + 10000;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
							cp += 2;
							iSize += 2;

							*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
							cp++;
							iSize++;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;

							ip  = (int *)cp;

							iTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
							iTemp = 0x0FFFFFFF & iTemp;
							iTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
							iTemp  = (iTemp | (iTemp2 << 28));
							*ip = iTemp;

							cp += 4;
							iSize += 4;

							memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
							cp    += 5;
							iSize += 5;
							break;
						}//End Switch
					}// if ((ucHeader & 0x02) != 0)

					if (pTile->m_pItem[0] != 0) {
						sp = (short*)cp;
						*sp = pTile->m_pItem[0]->m_sIDnum; 
						cp += 2;
						iSize += 2;

						*cp = pTile->m_pItem[0]->m_cItemColor;
						cp++;
						iSize++;

						dwp = (DWORD*)cp;
						*dwp = pTile->m_pItem[0]->m_dwAttribute;
						cp += 4;
						iSize += 4;
					}

					if (pTile->m_sDynamicObjectType != 0) {

						wp  = (WORD *)cp;
						*wp = pTile->m_wDynamicObjectID;
						cp += 2;
						iSize += 2;

						sp  = (short *)cp;
						*sp	= pTile->m_sDynamicObjectType;
						cp += 2;
						iSize += 2;
					} //(pTile->m_sDynamicObjectType != 0)

				} //(pTile->m_sOwner != 0)
		} // end While(1)
		*pTotal = iTileExists;
		return iSize;
}

void CGame::CheckClientResponseTime()
{
 int i, iPlusTime, iMaxSuperAttack, iValue;
 short sTemp;
 DWORD dwTime;
 short sItemIndex;
 //locobans
 //int iMapside, iMapside2;
 //SYSTEMTIME SysTime;

	/*
	GetLocalTime(&SysTime);
	switch (SysTime.wDayOfWeek) {
	case 1:	iWarPeriod = 30; break; //¿ù¿äÀÏ 
	case 2:	iWarPeriod = 30; break; //È­¿äÀÏ 
	case 3:	iWarPeriod = 60; break; //¼ö¿äÀÏ 
	case 4:	iWarPeriod = 60*2;  break; //¸ñ¿äÀÏ 
	case 5:	iWarPeriod = 60*5;  break; //±Ý¿äÀÏ 
	case 6:	iWarPeriod = 60*10; break; //Åä¿äÀÏ 
	case 0:	iWarPeriod = 60*20; break; //ÀÏ¿äÀÏ 
	}
	*/
	
   	dwTime = timeGetTime();
	
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			
			if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT ) {
				if (m_pClientList[i]->m_bIsInitComplete ) {
					//Testcode 
					wsprintf(G_cTxt, "Client Timeout: %s", m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);

					DeleteClient(i, true, true);
				}
				else if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT) {
					DeleteClient(i, false, false); 
				}
			}
			else if (m_pClientList[i]->m_bIsInitComplete ) {
				m_pClientList[i]->m_iTimeLeft_ShutUp--;
				if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;
				
				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;
				
				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > DEF_HUNGERTIME) && (m_pClientList[i]->m_bIsKilled == false)) {
					// v2.03
					if ((m_pClientList[i]->m_iLevel < DEF_LEVELLIMIT) || (m_pClientList[i]->m_iAdminUserLevel >= 1 )) {
					}
					else m_pClientList[i]->m_iHungerStatus--;
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;
					
					SendNotifyMsg(0, i, DEF_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, 0, 0, 0);
				}
				
				if (_bCheckCharacterData(i) == false) {
					DeleteClient(i, true, true);
					break;	
				}
				
				if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0)) 
					iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus)*1000;
				else iPlusTime = 0;
				
				iPlusTime = abs(iPlusTime);

				// HP
				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (DWORD)(DEF_HPUPTIME + iPlusTime)) {
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}
				
				// MP
				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (DWORD)(DEF_MPUPTIME + iPlusTime)) {
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
				}
				
				// SP
				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (DWORD)(DEF_SPUPTIME + iPlusTime)) {
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}
				
				if ((m_pClientList[i]->m_bIsPoisoned ) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > DEF_POISONTIME)) {
					PoisonEffect(i, 0);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}
				
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFightZone == false) &&
					((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > (DWORD)DEF_AUTOSAVETIME)) {
					g_login->LocalSavePlayerData(i); //bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
					m_pClientList[i]->m_dwAutoSaveTime = dwTime;
				}
				
				// ExpStock
				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (DWORD)DEF_EXPSTOCKTIME) {
					m_pClientList[i]->m_dwExpStockTime = dwTime;
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
					CheckCrusadeResultCalculation(i);
					CheckHeldenianResultCalculation(i);
				}

				// AutoExe
				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (DWORD)DEF_AUTOEXPTIME) {
					iValue = (m_pClientList[i]->m_iLevel/2);
					if (iValue <= 0) iValue = 1;
					if (m_pClientList[i]->m_iAutoExpAmount < iValue) {
						if ((m_pClientList[i]->m_iExp + iValue) < m_iLevelExpTable[m_pClientList[i]->m_iLevel+1]) {
							//m_pClientList[i]->m_iExpStock += iValue;
							GetExp(i, iValue, false);
							CalcExpStock(i);
						}
					}
			
					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}
						
				// v1.432
				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
					SendNotifyMsg(0, i, DEF_NOTIFY_SPECIALABILITYENABLED, 0, 0, 0, 0);
					// New 25/05/2004
					// After the time up, add magic back
					sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					if (sItemIndex != -1) {
						if ((m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
							if((m_pClientList[i]->m_iInt+ m_pClientList[i]->m_iAngelicInt) > 99 && (m_pClientList[i]->m_iMag+ m_pClientList[i]->m_iAngelicMag) > 99){
								m_pClientList[i]->m_cMagicMastery[94] = true;
								SendNotifyMsg(0, i, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
							}
						}
					}
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;
				
				// v1.432
				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled ) {
					if (((dwTime - m_pClientList[i]->m_dwSpecialAbilityStartTime)/1000) > m_pClientList[i]->m_iSpecialAbilityLastSec) {
						SendNotifyMsg(0, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, 0, 0, 0);
						m_pClientList[i]->m_bIsSpecialAbilityEnabled = false;
						m_pClientList[i]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
						sTemp = m_pClientList[i]->m_sAppr4;
						sTemp = sTemp & 0xFF0F;
						m_pClientList[i]->m_sAppr4 = sTemp;
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}
				}
				
				//Crusade
				m_pClientList[i]->m_iLockedMapTime -= 3;
				if (m_pClientList[i]->m_iLockedMapTime < 0) {
					m_pClientList[i]->m_iLockedMapTime = 0;
					ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}
			
				// v2.04
				m_pClientList[i]->m_iDeadPenaltyTime -= 3;
				if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;
			
				if ( (m_pClientList[i]->m_bIsWarLocation ) && IsEnemyZone(i) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					// Crusade
					if (m_bIsCrusadeMode == false)
						if (m_pClientList[i]->m_bIsInsideOwnTown == false)
							m_pClientList[i]->m_iTimeLeft_ForceRecall--;

					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_dwWarBeginTime = dwTime;
						m_pClientList[i]->m_bIsWarLocation = false;
											
						SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
						RequestTeleportHandler(i, "1   ");
					}
				}
				
				if ((m_bIsHeldenianMode ) && (m_pMapList[m_pClientList[i]->m_cMapIndex] != 0)) {
					if (bCheckHeldenianMap(i, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, true);
					}
					else {
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, false);
					}
				}	

				if (m_pClientList[i] == 0) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) {
					//wsprintf(G_cTxt, "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) ¼Óµµ Á¶ÀÛ", m_pClientList[i]->m_cCharName);
					//PutLogFileList(G_cTxt);
					DeleteClient(i, true, true);
				}
				else {
					m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}

				if (m_pClientList[i] == 0) break;
				//if (m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) {
				if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}

			if (m_pClientList[i] == 0) break;
				//if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
				//	 (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) ) {
				if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
					 (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					if ((m_pClientList[i]->m_cSide == 1) && 
					(m_pClientList[i]->m_iAdminUserLevel == 0)) {
					  RequestTeleportHandler(i, "2   ", "aresden", -1, -1);
					}
					else if ((m_pClientList[i]->m_cSide == 2) && 
					(m_pClientList[i]->m_iAdminUserLevel == 0)) {
					  RequestTeleportHandler(i, "2   ", "elvine", -1, -1);
					}
				}

				if (m_pClientList[i] == 0) break;
				if ((strcmp(m_pClientList[i]->m_cLocation, "elvine") != 0) && 
					(strcmp(m_pClientList[i]->m_cLocation, "elvhunter") != 0) && 
					(strcmp(m_pClientList[i]->m_cLocation, "arehunter") != 0) && 
					(strcmp(m_pClientList[i]->m_cLocation, "aresden") != 0) &&
					(m_pClientList[i]->m_iLevel >= 20) &&
					(m_pClientList[i]->m_iAdminUserLevel == 0)) {
					wsprintf(G_cTxt, "Traveller Hack: (%s) Player: (%s) is a traveller and is greater than level 19.", m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName);
					PutHackLogFileList(G_cTxt);
					DeleteClient(i, true, true);
				}

				if (m_pClientList[i] == 0) break;
					if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap ) && 
						(m_bIsApocalypseMode == false) &&
						(m_pClientList[i]->m_iAdminUserLevel == 0)) {
								RequestTeleportHandler(i, "1   ");
					}

				//(m_bIsCrusadeMode )
				/*
				if (m_pClientList[i] == 0) break;
				if (((memcmp(m_pClientList[i]->m_cLocation, "aresden",7) == 0) || (memcmp(m_pClientList[i]->m_cLocation, "elvine",6) == 0)) ) {
					iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName);
					if (iMapside > 3) iMapside2 = iMapside - 2;
					else iMapside2 = iMapside;

					if ((m_pClientList[i]->m_cSide != iMapside2) && (iMapside != 0)) {
						if ((iMapside <= 2) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
							if (m_pClientList[i]->m_cSide != 0) {
								m_pClientList[i]->m_dwWarBeginTime = timeGetTime();
								m_pClientList[i]->m_bIsWarLocation = true;
								m_pClientList[i]->m_iTimeLeft_ForceRecall = 1;
						
								RequestTeleportHandler(i, "1   ");
								SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
							}
						}
					}
				}*/

				if (m_pClientList[i] == 0) break;
				if (((memcmp(m_pClientList[i]->m_cLocation, "arehunter",9) == 0) || (memcmp(m_pClientList[i]->m_cLocation, "elvhunter",9) == 0)) &&
					 ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "2ndmiddle") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland") == 0))) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "1   ");
				}

				if (m_bIsApocalypseMode ) {
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "abaddon", 7) == 0) 
						SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATEOPEN, 167, 169, 0, m_pClientList[i]->m_cMapName);
					else if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "icebound", 8) == 0)
						SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATEOPEN, 89, 31, 0, m_pClientList[i]->m_cMapName);
				}

				if (m_pClientList[i] == 0) break;
				if ((m_bIsApocalypseMode ) &&
					(memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "icebound", 8) == 0) &&
					((m_pClientList[i]->m_sX == 89 && m_pClientList[i]->m_sY == 31) ||
					(m_pClientList[i]->m_sX == 89 && m_pClientList[i]->m_sY == 32) ||
					(m_pClientList[i]->m_sX == 90 && m_pClientList[i]->m_sY == 31) ||
					(m_pClientList[i]->m_sX == 90 && m_pClientList[i]->m_sY == 32))) {
					  RequestTeleportHandler(i, "2   ", "druncncity", -1, -1);
				}
				
				if (m_pClientList[i] == 0) break;
				if ((memcmp(m_pClientList[i]->m_cLocation, "are",3) == 0) &&
					(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvfarm") == 0) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == 0) break;
				if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) &&
					(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "arefarm") == 0) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == 0) break;
				if ( (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland") == 0) 
					 && (strcmp(m_pClientList[i]->m_cLocation, "NONE") == 0) &&
					 (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}
				
				if ((m_pClientList[i]->m_bInRecallImpossibleMap ) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					m_pClientList[i]->m_iTimeLeft_ForceRecall--;
					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_bInRecallImpossibleMap = false;
						SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
						RequestTeleportHandler(i, "0   ");
					}
				}
					
				if (m_pClientList[i] == 0) break;
				m_pClientList[i]->m_iSuperAttackCount++;
				if (m_pClientList[i]->m_iSuperAttackCount > 12) { //39
					
					m_pClientList[i]->m_iSuperAttackCount = 0;
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;
						
					// v1.12
					SendNotifyMsg(0, i, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
				}

				// v1.42
				m_pClientList[i]->m_iTimeLeft_FirmStaminar--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStaminar < 0) m_pClientList[i]->m_iTimeLeft_FirmStaminar = 0;

				// Crusade
				if (m_pClientList[i] == 0) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus ) _SendMapStatus(i);

				if (m_pClientList[i]->m_iConstructionPoint > 0) {
					CheckCommanderConstructionPoint(i);
				}
			}
		}
	}
}

void CGame::OnMainLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 /*int   iRet;
	
	if (m_pMainLogSock == 0) return;

	iRet = m_pMainLogSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		PutLogList("(!!!) Main-log-socket connected!");
		bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, 0);
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnMainLogRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		PutLogList("(!!!) Main-log-socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		delete m_pMainLogSock;
		m_pMainLogSock = 0;
		PutLogList("(!!!) Main-log-socket connection lost!");
		m_bIsLogSockAvailable = false;

		if (m_bOnExitProcess == false) {
			m_cShutDownCode      = 3;
			m_bOnExitProcess     = true;
			m_dwExitProcessTime  = timeGetTime();
			PutLogList("(!!!) GAME SERVER SHUTDOWN PROCESS BEGIN(by main-log-socket connection Lost)!!!");
		}
		break;
	}*/
}

void CGame::OnMainLogRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = _lsock->pGetRcvDataPointer(&dwMsgSize, &cKey); //m_pMainLogSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, 0, cKey) == false) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}


bool CGame::bSendMsgToLS(DWORD dwMsg, int iClientH, bool bFlag, char* pData)
{
 DWORD * dwp;
 WORD  * wp;
 int     iRet, i, iSize;
 char    cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
 char    cGuildLoc[11], cTemp[120];
 int   * ip, iSendSize;
 

	/*
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;


	iCnt = 0;
	bLoopFlag = false;
	while (bLoopFlag == false) {
		if (m_pSubLogSock[m_iCurSubLogSockIndex] != 0) 
			 bLoopFlag = true;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			if (m_bOnExitProcess == false) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = true;
				m_dwExitProcessTime  = timeGetTime();
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost)!!!");
			}
			return false;
		}
	}
	*/
	

	// v1.41
	ZeroMemory(G_cData50000, sizeof(G_cData50000));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,   sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	ZeroMemory(cGuildLoc,  sizeof(cGuildLoc));

	char cFn[112] = {};
	SYSTEMTIME SysTime;
	FILE* pFile;

	GetLocalTime(&SysTime);
	ZeroMemory(cFn, sizeof(cFn));

	switch (dwMsg) {
	// New 07/05/2004
	//case MSGID_GAMEMASTERLOG:
	//	// Sub-log-socket
	//	if (_bCheckSubLogSocketIndex() == false) return false;

	//	if (m_pClientList[iClientH] == 0) return false;
	//	if (pData == 0) return false ;


	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_GAMEMASTERLOG;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;

	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	iSize =  strlen(pData) ;
	//	memcpy((char *)cp, pData, iSize);

	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
	//	iSendSize = 6 + iSize;
	//	break;
	//	// v2.15 

	//case MSGID_GAMEITEMLOG:
	//	// Sub-log-socket
	//	if (_bCheckSubLogSocketIndex() == false) return false;

	//	//		if (m_pClientList[iClientH] == 0) return false;
	//	if (pData == 0) return false ;

	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_GAMEITEMLOG;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;

	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	iSize =  strlen(pData) ;
	//	memcpy((char *)cp, pData, iSize);

	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
	//	iSendSize = 6 + iSize;
	//	break;

	//case MSGID_SENDSERVERSHUTDOWNMSG:
	//	if (m_pMainLogSock == 0) return false;

	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_SENDSERVERSHUTDOWNMSG;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;
	//	
	//	iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
	//	break;
	//
	//case MSGID_GAMESERVERSHUTDOWNED:
	//	if (m_pMainLogSock == 0) return false;

	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_GAMESERVERSHUTDOWNED;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;
	//	
	//	iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
	//	return true;

	//case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
	//case MSGID_REQUEST_SETACCOUNTINITSTATUS:
	//	// Sub-log-socket
	//	if (_bCheckSubLogSocketIndex() == false) return false;
	//	
	//	if (m_pClientList[iClientH] == 0) return false;
	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = dwMsg;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;
	//	
	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
	//	cp += 10;

	//	ip = (int *)cp;
	//	*ip = m_pClientList[iClientH]->m_iLevel;
	//	cp += 4;
	//
	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
	//	iSendSize = 16;
	//	break;

	//case MSGID_ENTERGAMECONFIRM:
	//	
	//	// Sub-log-socket
	//	if (_bCheckSubLogSocketIndex() == false) return false;
	//	
	//	if (m_pClientList[iClientH] == 0) return false;

	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_ENTERGAMECONFIRM;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;
	//	
	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
	//	cp += 10;

	//	memcpy(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
	//	cp += 10;

	//	memcpy(cp, m_cServerName, 10);
	//	cp += 10;

	//	ZeroMemory(cTxt, sizeof(cTxt));
	//	m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
	//	memcpy(cp, cTxt, 16);
	//	cp += 16;

	//	ip = (int *)cp;
	//	*ip = m_pClientList[iClientH]->m_iLevel;
	//	cp += 4;

	//	//testcode
	//	wsprintf(G_cTxt, "Confirmed. Account: (%s) Name: (%s) Level: (%d)", m_pClientList[iClientH]->m_cAccountName, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iLevel);
	//	PutLogList(G_cTxt);



	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
	//	iSendSize = 56;
	//	if ((m_bIsCrusadeMode == false) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
	//	break;
	//	}
	//	else
	//	m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;


	//	break;
	//
	//case MSGID_REQUEST_REGISTERGAMESERVER:
	//	if (m_pMainLogSock == 0) return false;
	//			
	//	wsprintf(cTxt, "(!) Try to register game server(%s)", m_cServerName);
	//	PutLogList(cTxt);
	//	
	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;
	//	
	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	memcpy(cAccountName, m_cServerName, 10);
	//	if (m_iGameServerMode == 1)
	//	{
	//		memcpy(cAddress, m_cGameServerAddrExternal, strlen(m_cGameServerAddrExternal));
	//	}
	//	if (m_iGameServerMode == 2)
	//	{
	//		memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
	//	}
	//	memcpy(cp, cAccountName, 10);
	//	cp += 10;

	//	memcpy(cp, cAddress, 16);
	//	cp += 16;

	//	wp  = (WORD *)cp;
	//	*wp = m_iGameServerPort;
	//	cp += 2;

	//	*cp = m_iTotalMaps;
	//	cp++;

	//	for (i = 0; i < m_iTotalMaps; i++) {
	//		memcpy(cp, m_pMapList[i]->m_cName, 11);
	//		cp += 11;
	//	}

	//	iRet = m_pMainLogSock->iSendMsg(G_cData50000, 35 + m_iTotalMaps*11); 

	//	return true;

	//case MSGID_REQUEST_PLAYERDATA:
	//	
	//	// Sub-log-socket
	//	if (_bCheckSubLogSocketIndex() == false) return false;

	//	if (m_pClientList[iClientH] == 0) return false;

	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_REQUEST_PLAYERDATA;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;

	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	//testcode
	//	if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) PutLogList("(X) CharName 0!");

	//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
	//	memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
	//	memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

	//	memcpy((char *)cp, cCharName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cAccountName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cAccountPassword, 10);
	//	cp += 10;

	//	ZeroMemory(cTemp, sizeof(cTemp));
	//	iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
	//	memcpy((char *)cp, cTemp, 15);
	//	cp += 15;
	//	
	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
	//	iSendSize = 52;
	//	break;

	//case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
	//case MSGID_REQUEST_SAVEPLAYERDATA:
	//case MSGID_REQUEST_SAVEPLAYERDATALOGOUT:

	//	// Sub-log-socket
	//	if (_bCheckSubLogSocketIndex() == false) return false;
	//	
	//	if (m_pClientList[iClientH] == 0) return false;
	//	
	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = dwMsg;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;

	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
	//	memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
	//	memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

	//	memcpy((char *)cp, cCharName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cAccountName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cAccountPassword, 10);
	//	cp += 10;

	//	*cp = (char)bFlag;
	//	cp++;
	//	
	//	iSize = _iComposePlayerDataFileContents(iClientH, cp);
	//	
	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + iSize);
	//	iSendSize = 37 + iSize;
	//	break;

	//case MSGID_REQUEST_NOSAVELOGOUT:

	//	// Sub-log-socket
	//	if (_bCheckSubLogSocketIndex() == false) return false;
	//	
	//	if (m_pClientList[iClientH] == 0) return false;
	//	
	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_REQUEST_NOSAVELOGOUT;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;

	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
	//	memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
	//	memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

	//	memcpy((char *)cp, cCharName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cAccountName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cAccountPassword, 10);
	//	cp += 10;
	//	
	//	*cp = (char)bFlag;
	//	cp++;
	//	
	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
	//	iSendSize = 37;
	//	break;
	//
	//case MSGID_REQUEST_CREATENEWGUILD:

	//	// Sub-log-socket
	//	if (_bCheckSubLogSocketIndex() == false) return false;
	//	
	//	if (m_pClientList[iClientH] == 0) return false;
	//	
	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_REQUEST_CREATENEWGUILD;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;

	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
	//	memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
	//	memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
	//	memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
	//	memcpy(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);

	//	memcpy((char *)cp, cCharName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cAccountName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cAccountPassword, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cGuildName, 20);
	//	cp += 20;
	//	memcpy((char *)cp, cGuildLoc, 10);
	//	cp += 10;

	//	ip = (int *)cp;
	//	*ip = m_pClientList[iClientH]->m_iGuildGUID;
	//	cp += 4;

	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
	//	iSendSize = 75;
	//	break;

	//case MSGID_REQUEST_DISBANDGUILD:
	//	// Sub-log-socket
	//	if (_bCheckSubLogSocketIndex() == false) return false;
	//	
	//	if (m_pClientList[iClientH] == 0) return false;
	//	
	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_REQUEST_DISBANDGUILD;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;

	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
	//	memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
	//	memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
	//	memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

	//	memcpy((char *)cp, cCharName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cAccountName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cAccountPassword, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cGuildName, 20);
	//	cp += 20;
	//	
	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
	//	iSendSize = 56;
	//	break;

	//case MSGID_REQUEST_HELDENIAN_WINNER:
	//	if (_bCheckSubLogSocketIndex() == false) return false;
	//	
	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_REQUEST_HELDENIAN_WINNER;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;

	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	if (m_cHeldenianVictoryType == 1)
	//		memcpy(cp, "aresden", 7);
	//	else if (m_cHeldenianVictoryType == 2)
	//		memcpy(cp, "elvine", 6);
	//	else 
	//		memcpy(cp, "draw", 4);

	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 21);
	//	iSendSize = 21;
	//	break;
	//
	//case MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN:

	//	// Sub-log-socket
	//	if (_bCheckSubLogSocketIndex() == false) return false;
	//	
	//	if (m_pClientList[iClientH] == 0) return false;
	//	
	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;

	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
	//	memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

	//	memcpy((char *)cp, cCharName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cGuildName, 20);
	//	cp += 20;

	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
	//	iSendSize = 36;
	//	break;

	//case MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN:

	//	// Sub-log-socket
	//	if (_bCheckSubLogSocketIndex() == false) return false;
	//	
	//	if (m_pClientList[iClientH] == 0) return false;

	//	dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN;
	//	wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;

	//	cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

	//	memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
	//	memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

	//	memcpy((char *)cp, cCharName, 10);
	//	cp += 10;

	//	memcpy((char *)cp, cGuildName, 20);
	//	cp += 20;

	//	iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
	//	iSendSize = 36;
	//	break;
	case MSGID_GAMEMASTERLOG:
		wsprintf(cFn, "GameLogs\\MasterLog-%d-%d-%d.txt", SysTime.wYear, SysTime.wMonth, SysTime.wDay);
		pFile = fopen(cFn, "at");
		if (pFile == 0) return false;
		fwrite(pData, 1, strlen(pData), pFile);
		fclose(pFile);
		break;
	case MSGID_GAMEITEMLOG:
		wsprintf(cFn, "GameLogs\\ItemLog-%d-%d-%d.txt", SysTime.wYear, SysTime.wMonth, SysTime.wDay);
		pFile = fopen(cFn, "at");
		if (pFile == 0) return false;
		fwrite(pData, 1, strlen(pData), pFile);
		fclose(pFile);
		break;
	}

	//switch (iRet) {
	//case DEF_XSOCKEVENT_QUENEFULL:
	//case DEF_XSOCKEVENT_SOCKETERROR:
	//case DEF_XSOCKEVENT_CRITICALERROR:
	//case DEF_XSOCKEVENT_SOCKETCLOSED:
	//	// Sub-log-socket
	//	wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
	//	PutLogList(G_cTxt);
	//	PutLogFileList(G_cTxt);

	//	delete m_pSubLogSock[m_iCurSubLogSockIndex];
	//	m_pSubLogSock[m_iCurSubLogSockIndex] = 0;
	//	m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = false;
	//	m_iSubLogSockActiveCount--;
	//			
	//	m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	//	m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
	//	m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);

	//	wsprintf(G_cTxt, "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
	//	PutLogList(G_cTxt);
	//	
	//	// v1.41 sub-log-socket
	//	m_iSubLogSockFailCount++;

	//	// v1.41
	//	if (_bCheckSubLogSocketIndex() == false) return false;
	//	m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);

	//	return false;
	//}

	return true;
}

void CGame::ResponsePlayerDataHandler(char * pData, DWORD dwSize)
{
 WORD * wp;
 char * cp, cCharName[11], cTxt[120];
 int  i; 
 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != 0) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
			switch (*wp) {
			case DEF_LOGRESMSGTYPE_CONFIRM:
				InitPlayerData(i, pData, dwSize); 
				break;
	
			case DEF_LOGRESMSGTYPE_REJECT:
				wsprintf(G_cTxt, "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
				PutLogList(G_cTxt);
				//PutLogFileList(G_cTxt); // v1.4

				DeleteClient(i, false, false);
				break;
			
			default:
				break;
			}				
			
			return;
		}	
	}

	wsprintf(cTxt, "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::InitPlayerData(int iClientH, char * pData, DWORD dwSize)
{
	char  * cp, cName[11], cData[256], cTxt[256], cQuestRemain;
	DWORD * dwp;
	WORD  * wp;
	int     iRet, i, iTotalPoints;
	bool    bRet, bGuildStatus;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete ) return; // ÀÌ¹Ì ÃÊ±âÈ­ µÈ Ä³¸¯ÅÍÀÇ µ¥ÀÌÅÍÀÌ´Ù. ÀÌ·±ÀÏÀÌ ÀÖÀ» ¼ö ÀÖÀ»±î?

	// Log Server
	//cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	//ZeroMemory(cName, sizeof(cName));
	//memcpy(cName, cp, 10);
	//cp += 10;

	////m_pClientList[iClientH]->m_cAccountStatus = *cp;
	//cp++;

	//cGuildStatus = *cp;
	//cp++;

	m_pClientList[iClientH]->m_iHitRatio     = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = 0;
	m_pClientList[iClientH]->m_cSide         = 0;

	char cFileName[112] = {};
	char cDir[112] = {};
	strcat(cFileName, "Characters");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	wsprintf(cDir, "AscII%d", m_pClientList[iClientH]->m_cCharName[0]);
	strcat(cFileName, cDir);
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, m_pClientList[iClientH]->m_cCharName);
	strcat(cFileName, ".txt");

	bRet = _bDecodePlayerDatafileContents(iClientH, cFileName, 0); //_bDecodePlayerDatafileContents(iClientH, cp, dwSize - 19);
	if (bRet == false) {
		wsprintf(G_cTxt, "(HACK?) Character(%s) data error!", m_pClientList[iClientH]->m_cCharName);
		DeleteClient(iClientH, false, true); //!!!
		return;
	}

	___RestorePlayerCharacteristics(iClientH);

	___RestorePlayerRating(iClientH);

	if ((m_pClientList[iClientH]->m_sX == -1) && (m_pClientList[iClientH]->m_sY == -1)) {
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
	}

	// New 17/05/2004
	SetPlayingStatus(iClientH);
	int iTemp, iTemp2;
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFFFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;

	if (m_pClientList[iClientH]->m_iLevel > 100)
		if (m_pClientList[iClientH]->m_bIsPlayerCivil )
			ForceChangePlayMode(iClientH, false);

	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

	CalcTotalItemEffect(iClientH, -1, true); //false
	iCalcTotalWeight(iClientH);

	// New 23/05/2004
	//GM Invi comes here
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
	}

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];
		if ((iTotalPoints-21 > m_sCharSkillLimit) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		try
		{
			wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) - has more than allowed skill points (%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, iTotalPoints);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch(...)
		{
		}
		return;
	}
		
	CheckSpecialEvent(iClientH);
	bCheckMagicInt(iClientH);

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_HUNGER, m_pClientList[iClientH]->m_iHungerStatus, 0, 0, 0);

	if (strcmp(m_pClientList[iClientH]->m_cGuildName, "NONE") != 0) {
		char cFn[112] = {};
		ZeroMemory(cFn, sizeof(cFn));
		wsprintf(cFn, "Guilds\\AscII%d\\%s.txt", m_pClientList[iClientH]->m_cGuildName[0], m_pClientList[iClientH]->m_cGuildName);
		HANDLE  hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		auto dwFileSize = GetFileSize(hFile, 0);

		bGuildStatus = !(hFile == INVALID_HANDLE_VALUE);
		CloseHandle(hFile);
		// GuildName
		if ((!bGuildStatus) && (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
			ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, "NONE");
			m_pClientList[iClientH]->m_iGuildRank = -1;
			m_pClientList[iClientH]->m_iGuildGUID = -1;

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GUILDDISBANDED, 0, 0, 0, m_pClientList[iClientH]->m_cGuildName);
		}
	}

	if (m_pClientList[iClientH]->m_iQuest != 0) { 
			cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, 0, 0, 0);
			_bCheckIsQuestCompleted(iClientH);
	}


	if (m_pClientList[iClientH] == 0) {
		wsprintf(cTxt, "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITPLAYER;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ## BUG POINT!!!
		wsprintf(cTxt, "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);

		DeleteClient(iClientH, false, true); //!!!!!
		return;
	}

	m_pClientList[iClientH]->m_bIsInitComplete = true;

	//bSendMsgToLS(MSGID_ENTERGAMECONFIRM, iClientH);

	/*if (m_iTotalClients > DEF_MAXONESERVERUSERS) {
		switch (iDice(1,2)) {
		case 1: 
			RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
			break;
			case 2: 
				switch (m_pClientList[iClientH]->m_cSide) {
					case 0: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
					case 1: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
					case 2: RequestTeleportHandler(iClientH, "2   ", "resurr2", -1, -1); break;
				}
				break;
		}
	}*/

	m_pClientList[iClientH]->read_mobs_data();
	m_pClientList[iClientH]->read_shards_data();
	m_pClientList[iClientH]->read_fragments_data();
}

void CGame::GameProcess()
{
	NpcProcess();
	MsgProcess();
	ForceRecallProcess();
	DelayEventProcess();
}

bool CGame::bReadProgramConfigFile(char * cFn, bool ismaps)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode, cTxt[120], cGSMode[16] = "";
	char seps[] = "= \t\n";	
	class CStrTok * pStrTok;
	bool bGateDNS = false; // bGateDNS added by snaipperi
	bool bLogDNS = false; // bLogDNS added by snaipperi

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		//	PutLogList("(!) Cannot open configuration file.");
		return false;
	}
	else {
		PutLogList("(!) Reading configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != 0 )   {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					ZeroMemory(m_cServerName, sizeof(m_cServerName));
					if (strlen(token) > 10) {
						wsprintf(cTxt, "(!!!) Game server name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					strcpy(m_cServerName, token);
					wsprintf(cTxt, "(*) Game server name : %s", m_cServerName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 2:
					m_iGameServerPort = atoi(token);
					wsprintf(cTxt, "(*) Game server port : %d", m_iGameServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 3:
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));

					if (strlen(token) > 20) {
						wsprintf(cTxt, "(!!!) Log server address(%s) must within 20 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					strcpy(m_cLogServerAddr, token);
					wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;


				case 4:
					m_iLogServerPort = atoi(token);
					wsprintf(cTxt, "(*) Log server port : %d", m_iLogServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 5:
					if (strlen(token) > 10) {
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					if (_bRegisterMap(token) == false) {
						return false;
					}
					cReadMode = 0;
					break;

				case 6:
					ZeroMemory(m_cGateServerAddr, sizeof(m_cGateServerAddr));
				
					if (strlen(token) > 20) {
						wsprintf(cTxt, "(!!!) Gate server address(%s) must within 20 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					strcpy(m_cGateServerAddr, token);
					wsprintf(cTxt, "(*) Gate server address : %s", m_cGateServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
					break;

				case 7:
					m_iGateServerPort = atoi(token);
					wsprintf(cTxt, "(*) Gate server port : %d", m_iGateServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 8:
					ZeroMemory(m_cGameServerAddrInternal, sizeof(m_cGameServerAddrInternal));
					if (strlen(token) > 15) {
						wsprintf(cTxt, "(!!!) Internal (LAN) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					strcpy(m_cGameServerAddrInternal, token);
					wsprintf(cTxt, "(*) Internal (LAN) Game server address : %s", m_cGameServerAddrInternal);
					PutLogList(cTxt);
					cReadMode = 0;
					break;


				case 9:
					ZeroMemory(m_cGameServerAddrExternal, sizeof(m_cGameServerAddrExternal));
					if (strlen(token) > 15) {
						wsprintf(cTxt, "(!!!) External (Internet) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					strcpy(m_cGameServerAddrExternal, token);
					wsprintf(cTxt, "(*) External (Internet) Game server address : %s", m_cGameServerAddrExternal);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 10:
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					if (strlen(token) > 15) {
						wsprintf(cTxt, "(!!!) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					strcpy(m_cGameServerAddr, token);
					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 11:
					if ((memcmp(token, "lan", 3) == 0) || (memcmp(token, "LAN", 3) == 0))
					{
						m_iGameServerMode = 1;
						memcpy(cGSMode, "LAN", 3);
					}
					if ((memcmp(token, "internet", 3) == 0) || (memcmp(token, "INTERNET", 3) == 0))
					{
						m_iGameServerMode = 2;
						memcpy(cGSMode, "INTERNET", 8);
					}
					if (m_iGameServerMode == 0)
					{
						wsprintf(cTxt, "(!!!) Game server mode(%s) must be either LAN/lan/INTERNET/internet", token);
						PutLogList(cTxt);
						return false;
					}
					wsprintf(cTxt, "(*) Game server mode : %s", cGSMode);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
			
				case 12: //Gate DNS by SNaipperi
					if (memcmp(token, "true", 4) == 0) {
						bGateDNS = true;
					}
					else bGateDNS = false;
					wsprintf(cTxt, "Gate DNS is set to %i",bGateDNS);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 13: //Log DNS by Snaipperi
					if (memcmp(token, "true", 4) == 0) {
						bLogDNS = true;
					}
					else bLogDNS = false;
					wsprintf(cTxt, "Log DNS is set to %i",bLogDNS);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (ismaps)
				{
					if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 5;
				}
				else
				{
					if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
					if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 2;
					if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 3;
					if (memcmp(token, "internal-log-server-port", 24) == 0) cReadMode = 4;

					if (memcmp(token, "gate-server-address", 19) == 0)		cReadMode = 6;
					if (memcmp(token, "gate-server-port", 16) == 0)			cReadMode = 7;
					if (memcmp(token, "game-server-internal-address", 28) == 0)			cReadMode = 8;
					if (memcmp(token, "game-server-external-address", 28) == 0)			cReadMode = 9;
					if (memcmp(token, "game-server-address", 19) == 0)		cReadMode = 10;
					if (memcmp(token, "game-server-mode", 16) == 0)			cReadMode = 11;
					if (memcmp(token, "gate-server-dns", 15) == 0) cReadMode = 12;
					if (memcmp(token, "log-server-dns", 14) == 0) cReadMode = 13;
				}
			}
			token = pStrTok->pGet();
			//token = strtok( 0, seps );
		}
		delete pStrTok;
		delete[] cp;
	}
	if (pFile != 0) fclose(pFile);

	if (m_iGameServerMode == 0) {
		wsprintf(cTxt, "(!!!) Game server mode cannot be empty. It must be either LAN/lan/INTERNET/internet");
		PutLogList(cTxt);
		return false;	
	}

	return true;
}

bool CGame::bReadSettingsConfigFile(char * cFn) 
{ 
   FILE * pFile; 
   HANDLE hFile; 
   DWORD  dwFileSize; 
   char * cp, * token, cReadMode, cTxt[120], cGSMode[16] = "", len; 
   char seps[] = "= \t\n"; 
   class CStrTok * pStrTok; 

   cReadMode = 0; 

   hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0); 
   dwFileSize = GetFileSize(hFile, 0); 
   if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile); 

   pFile = fopen(cFn, "rt"); 
   if (pFile == 0) { 
       //   PutLogList("(!) Cannot open configuration file."); 
      return false; 
   } 
   else { 
      PutLogList("(!) Reading settings file..."); 
      cp = new char[dwFileSize+2]; 
      ZeroMemory(cp, dwFileSize+2); 
      fread(cp, dwFileSize, 1, pFile); 

      pStrTok = new class CStrTok(cp, seps); 
      token = pStrTok->pGet(); 
      //token = strtok( cp, seps );    
      while( token != 0 )   { 

         if (cReadMode != 0) { 
            switch (cReadMode) { 

            case 1: 
               if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) 
               { 
                  m_iPrimaryDropRate = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) Primary drop rate(%s) invalid must be between 1 to 10000", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Primary drop rate: (%d)", m_iPrimaryDropRate); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 2: 
               if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) 
               { 
                  m_iSecondaryDropRate = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) Secondary drop rate(%s) invalid must be between 1 to 10000", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Secondary drop rate: (%d)", m_iSecondaryDropRate); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 3: 
               if ((memcmp(token, "classic", 7) == 0) || (memcmp(token, "CLASSIC", 7) == 0)) 
               { 
                  m_bEnemyKillMode = false; 
                  wsprintf(cTxt, "(*) Enemy Kill Mode: CLASSIC"); 
                  PutLogList(cTxt); 
               } 
               else if ((memcmp(token, "deathmatch", 10) == 0) || (memcmp(token, "DEATHMATCH", 10) == 0)) 
               { 
                  m_bEnemyKillMode = true; 
                  wsprintf(cTxt, "(*) Enemy Kill Mode: DEATHMATCH"); 
                  PutLogList(cTxt); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) ENEMY-KILL-MODE: (%s) must be either DEATHMATCH or CLASSIC", token); 
                  PutLogList(cTxt); 
                  return false; 
               } 
               cReadMode = 0; 
               break; 

            case 4: 
               if ((strlen(token) != 0) && (strlen(token) <= 100) && (strlen(token) >= 1)) 
               { 
                  m_iEnemyKillAdjust = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) ENEMY-KILL-ADJUST: (%s) invalid must be between 1 to 100", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Player gains (%d) EK per enemy kill.", m_iEnemyKillAdjust); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 5: 
               if ((memcmp(token, "on", 2) == 0) || (memcmp(token, "ON", 2) == 0)) 
               { 
                  m_bAdminSecurity = true; 
                  wsprintf(cTxt, "(*) Administator actions limited through security."); 
                  PutLogList(cTxt); 
               } 
               if ((memcmp(token, "off", 3) == 0) || (memcmp(token, "OFF", 3) == 0)) 
               { 
                  m_bAdminSecurity = false; 
                  wsprintf(cTxt, "(*) Administator vulnerability ignored."); 
                  PutLogList(cTxt); 
               } 

               cReadMode = 0; 
               break; 

            case 6: 
               m_sRaidTimeMonday = atoi(token); 
               if (m_sRaidTimeMonday == 0) m_sRaidTimeMonday = 3; 
               wsprintf(cTxt, "(*) Monday Raid Time : (%d) minutes", m_sRaidTimeMonday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 7: 
               m_sRaidTimeTuesday = atoi(token); 
               if (m_sRaidTimeTuesday == 0) m_sRaidTimeTuesday = 3; 
               wsprintf(cTxt, "(*) Tuesday Raid Time : (%d) minutes", m_sRaidTimeTuesday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 8: 
               m_sRaidTimeWednesday = atoi(token); 
               if (m_sRaidTimeWednesday == 0) m_sRaidTimeWednesday = 3; 
               wsprintf(cTxt, "(*) Wednesday Raid Time : (%d) minutes", m_sRaidTimeWednesday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 9: 
               m_sRaidTimeThursday = atoi(token); 
               if (m_sRaidTimeThursday == 0) m_sRaidTimeThursday = 3; 
               wsprintf(cTxt, "(*) Thursday Raid Time : (%d) minutes", m_sRaidTimeThursday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 10: 
               m_sRaidTimeFriday = atoi(token); 
               if (m_sRaidTimeFriday == 0) m_sRaidTimeFriday = 10; 
               wsprintf(cTxt, "(*) Friday Raid Time : (%d) minutes", m_sRaidTimeFriday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 11: 
               m_sRaidTimeSaturday = atoi(token); 
               if (m_sRaidTimeSaturday == 0) m_sRaidTimeSaturday = 45; 
               wsprintf(cTxt, "(*) Saturday Raid Time : (%d) minutes", m_sRaidTimeSaturday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 12: 
               m_sRaidTimeSunday = atoi(token); 
               if (m_sRaidTimeSunday == 0) m_sRaidTimeSunday = 60; 
               wsprintf(cTxt, "(*) Sunday Raid Time : (%d) minutes", m_sRaidTimeSunday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 
		
			case 13:
				if ((memcmp(token, "player", 6) == 0) || (memcmp(token, "PLAYER", 6) == 0))
				{
					m_bLogChatOption = 1;
					wsprintf(cTxt, "(*) Logging Player Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "gm", 2) == 0) || (memcmp(token, "GM", 2) == 0))
				{
					m_bLogChatOption = 2;
					wsprintf(cTxt, "(*) Logging GM Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "all", 3) == 0) || (memcmp(token, "ALL", 3) == 0))
				{
					m_bLogChatOption = 3;
					wsprintf(cTxt, "(*) Logging All Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "none", 4) == 0) || (memcmp(token, "NONE", 4) == 0))
				{
					m_bLogChatOption = 4;
					wsprintf(cTxt, "(*) Not Logging Any Chat.");
					PutLogList(cTxt);
				}
				cReadMode = 0;
				break;

            case 14: 
               m_iSummonGuildCost = atoi(token); 
               wsprintf(cTxt, "(*) Summoning guild costs (%d) gold", m_iSummonGuildCost); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break;
 
			case 15: 
               m_sSlateSuccessRate = atoi(token); 
               wsprintf(cTxt, "(*) Slate Success Rate (%d) percent", m_sSlateSuccessRate); 
               PutLogList(cTxt); 
			   if (m_sSlateSuccessRate == 0) m_sSlateSuccessRate = 14; 
               cReadMode = 0; 
               break;

			case 16: 
               m_sCharStatLimit = atoi(token); 
               if (m_sCharStatLimit == 0) m_sCharStatLimit = 200; 
               cReadMode = 0;
               break;

			case 17: 
               m_sCharSkillLimit = atoi(token); 
               if (m_sCharSkillLimit == 0) m_sCharSkillLimit = 700; 
               cReadMode = 0;
               break;

			case 18: 
               m_cRepDropModifier = atoi(token); 
               wsprintf(cTxt, "(*) Rep<->Drop modifier: (%d)", m_cRepDropModifier); 
               PutLogList(cTxt); 
               if (m_cRepDropModifier < 0) m_cRepDropModifier = 0;
               cReadMode = 0; 
               break;

			case 19: 
               ZeroMemory(m_cSecurityNumber, sizeof(m_cSecurityNumber));
			   len = strlen(token);
			   if(len > 10) len = 10;
			   memcpy(m_cSecurityNumber, token, len);
               wsprintf(cTxt, "(*) Security number memorized!"); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break;

			case 20: 
				m_iPlayerMaxLevel = atoi(token);
               if (m_iPlayerMaxLevel == 0) m_iPlayerMaxLevel = 180;
               cReadMode = 0;
               break;
			
			}
         } 
         else { 
            if (memcmp(token, "primary-drop-rate"      , 17) == 0)   cReadMode = 1; 
            if (memcmp(token, "secondary-drop-rate"      , 19) == 0)   cReadMode = 2; 
            if (memcmp(token, "enemy-kill-mode"         , 15) == 0)   cReadMode = 3; 
            if (memcmp(token, "enemy-kill-adjust"      , 17) == 0)   cReadMode = 4; 
            if (memcmp(token, "admin-security"         , 14) == 0)   cReadMode = 5; 
            if (memcmp(token, "monday-raid-time"      , 16) == 0)   cReadMode = 6; 
            if (memcmp(token, "tuesday-raid-time"      , 17) == 0)   cReadMode = 7; 
            if (memcmp(token, "wednesday-raid-time"      , 19) == 0)   cReadMode = 8; 
            if (memcmp(token, "thursday-raid-time"      , 18) == 0)   cReadMode = 9; 
            if (memcmp(token, "friday-raid-time"      , 16) == 0)   cReadMode = 10; 
            if (memcmp(token, "saturday-raid-time"      , 18) == 0)   cReadMode = 11; 
            if (memcmp(token, "sunday-raid-time"      , 16) == 0)   cReadMode = 12; 
			if (memcmp(token, "log-chat-settings", 17) == 0)		cReadMode = 13;
			if (memcmp(token, "summonguild-cost", 16) == 0)		cReadMode = 14;
			if (memcmp(token, "slate-success-rate", 18) == 0)		cReadMode = 15;
			if (memcmp(token, "character-stat-limit", 20) == 0)		cReadMode = 16;
			if (memcmp(token, "character-skill-limit", 21) == 0)		cReadMode = 17;
			if (memcmp(token, "rep-drop-modifier", 17) == 0)		cReadMode = 18;
			if (memcmp(token, "admin-security-code", 19) == 0)		cReadMode = 19;
			if (memcmp(token, "max-player-level", 16) == 0)		cReadMode = 20;
         } 

         token = pStrTok->pGet(); 
         //token = strtok( 0, seps ); 
      } 

      delete pStrTok; 
      delete[] cp; 
   } 
   if (pFile != 0) fclose(pFile); 

   return true; 
} 
 

bool CGame::bReadCrusadeStructureConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 int   iIndex;
 class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		PutLogList("(!) Cannot open Crusade configuration file.");
		return false;
	}
	else {
		PutLogList("(!) Reading Crusade configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != 0 ) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						if (_bGetIsStringIsNumber(token) == false) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format(1).");
							delete[] cp;
							delete pStrTok;
							return false;
						}
						iIndex = atoi(token);

						if (m_stCrusadeStructures[iIndex].cType != 0) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Duplicate portion number.");
							delete[] cp;
							delete pStrTok;
							return false;
						}
						
						cReadModeB = 2;
						break;

					case 2:
						ZeroMemory(m_stCrusadeStructures[iIndex].cMapName, sizeof(m_stCrusadeStructures[iIndex].cMapName));
						memcpy(m_stCrusadeStructures[iIndex].cMapName, token, strlen(token));
						cReadModeB = 3;
						break;

					
					case 3:
						if (_bGetIsStringIsNumber(token) == false) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete[] cp;
							delete pStrTok;
							return false;
						}
						m_stCrusadeStructures[iIndex].cType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:
						if (_bGetIsStringIsNumber(token) == false) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete[] cp;
							delete pStrTok;
							return false;
						}
						m_stCrusadeStructures[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;
	
					case 5:
						if (_bGetIsStringIsNumber(token) == false) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete[] cp;
							delete pStrTok;
							return false;
						}
						m_stCrusadeStructures[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				default: 
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			
			}
			token = pStrTok->pGet();
		}	

		delete pStrTok;
		delete[] cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			PutLogList("(!!!) CRITICAL ERROR! Crusade Structure configuration file contents error!");
			return false;
		}
	}
	
	if (pFile != 0) fclose(pFile);
	return true;
}

bool CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
	char * pContents, * token, * pOriginContents, cTmpName[11], cTxt[120];
	char   seps[] = "= \t\n";
	char   cReadModeA, cReadModeB;
	int    i, iItemIndex, iItemInBankIndex;
	class  CStrTok * pStrTok;
	short  sTmpType, sTmpAppr1;
	bool   bRet;
	int    iTemp;
	SYSTEMTIME SysTime;
	__int64 iDateSum1, iDateSum2;
	bool   bIsNotUsedItemFound = false;
	DWORD iTotalGold, iNotUsedItemPrice;

	if (m_pClientList[iClientH] == 0) return false;

	iTotalGold = 0;
	iItemIndex = 0;
	iItemInBankIndex  = 0;
	iNotUsedItemPrice = 0;

	cReadModeA = 0;
	cReadModeB = 0;

	/*pContents = new char[dwSize+2];
	ZeroMemory(pContents, dwSize+2);
	memcpy(pContents, pData, dwSize);*/

	char cData[30000];
	DWORD lpNumberOfBytesRead;
	HANDLE hFile = CreateFile(pData, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	DWORD dwFileSize = GetFileSize(hFile, 0);
	if (dwFileSize == -1) {
		wsprintf(G_cTxt, "(X) CRITICAL ERROR! Cannot open character file(%s)!", pData);
		PutLogList(pData);
		return false;
	}

	SetFilePointer(hFile, 0, 0, FILE_BEGIN);

	ReadFile(hFile, cData, dwFileSize, &lpNumberOfBytesRead, 0);
	CloseHandle(hFile);

	pContents = new char[dwFileSize + 1];
	ZeroMemory(pContents, dwFileSize + 1);
	memcpy(pContents, cData, dwFileSize);

	pOriginContents = pContents;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while( token != 0 ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				strcpy(m_pClientList[iClientH]->m_cMapName, token);
				ZeroMemory(cTmpName, sizeof(cTmpName));
				strcpy(cTmpName, token);
				for (i = 0; i < DEF_MAXMAPS; i++)
					if ((m_pMapList[i] != 0)	&& (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
						m_pClientList[iClientH]->m_cMapIndex = (char)i;
					}

					if (m_pClientList[iClientH]->m_cMapIndex == -1) {
						wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, cTmpName); 
						PutLogList(cTxt);
						delete[] pContents;
						delete pStrTok;
						return false;
					}

					cReadModeA = 0;
					break;

			case 2:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_sX = atoi(token);
				cReadModeA = 0;
				break;

			case 3:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_sY = atoi(token);
				cReadModeA = 0;
				break;

			case 4:
				/*
				if (_bGetIsStringIsNumber(token) == false) {
				wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
				PutLogList(cTxt);
				delete[] pContents;
				delete pStrTok;
				return false;
				}
				m_pClientList[iClientH]->m_cAccountStatus = atoi(token);
				*/
				cReadModeA = 0;
				break;

			case 5:
				switch(cReadModeB) {
			case 1:
				// New 07/05/2004
				// v2.12
				if (iItemIndex >= DEF_MAXITEMS) {
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				// token
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], token) == false) {
					wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
					PutLogList(cTxt);

					// Debug code @@@@@@@@@@@@@@@
					HANDLE hFile;
					DWORD  nWrite;
					hFile = CreateFile("Error.Log", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0);
					WriteFile(hFile, (char *)pContents, dwSize+2, &nWrite, 0);
					CloseHandle(hFile);

					delete[] pContents;
					delete pStrTok;
					return false;
				}
				cReadModeB = 2;
				break;

			case 2:
				// m_dwCount
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				iTemp = atoi(token);
				if (iTemp < 0) iTemp = 1;
				if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
					iTemp = 1;
					wsprintf(G_cTxt, "(!) Player(%s) Item (%s) too heavy for player to carry", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName);
					PutLogFileList(G_cTxt);
					PutLogList(G_cTxt);
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = (DWORD)iTemp;
				cReadModeB = 3;

				// v1.3
				if (memcmp(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, "Gold", 4) == 0)
					iTotalGold += iTemp;
				break;

			case 3:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// m_cItemColor
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// m_sItemSpecEffectValue1
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// m_sItemSpecEffectValue2
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// m_sItemSpecEffectValue3
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3 = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// m_wCurLifeSpan
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = atoi(token);

				cReadModeB = 12;
				break;

			case 12:
				// m_dwAttribute
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = atoi(token);

				// v1.4
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) {
					if ( (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) ) {
							wsprintf(cTxt, "(!) ´Ù¸¥ »ç¶÷ÀÇ ¾ÆÀÌÅÛ ¼ÒÁö: Player(%s) Item(%s) %d %d %d - %d %d %d", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3,
								m_pClientList[iClientH]->m_sCharIDnum1,
								m_pClientList[iClientH]->m_sCharIDnum2,
								m_pClientList[iClientH]->m_sCharIDnum3); 
							PutLogList(cTxt);
							//PutLogFileList(cTxt);
						}
				}

				cReadModeA = 0;
				cReadModeB = 0;

				// v1.41
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001 ) != 0) {
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
				}

				// v1.42
				_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[iItemIndex]);

				// v1.41
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan)
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

				// v1.433
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan == 0) && 
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¼ö¸í 0Â¥¸® Èñ»ý¼® ¼ÒÁö!", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = 1;
					}

					// v2.05
					bCheckAndConvertPlusWeaponItem(iClientH, iItemIndex);

					// v1.4
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

						// v1.41
						bIsNotUsedItemFound = true;
					}
					else
						if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemList[iItemIndex]) ) {
							// v1.42
							_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, 0, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

							iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
							delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
							m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;
						}
						else iItemIndex++;
						break;
				}
				break;

			case 6:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_cSex = atoi(token);
				cReadModeA = 0;
				break;

			case 7:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_cSkin = atoi(token);
				cReadModeA = 0;
				break;

			case 8:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_cHairStyle = atoi(token);
				cReadModeA = 0;
				break;

			case 9:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_cHairColor = atoi(token);
				cReadModeA = 0;
				break;

			case 10:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_cUnderwear = atoi(token);
				cReadModeA = 0;
				break;

			case 11:
				for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) 
					m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;

				for (i = 0; i < DEF_MAXITEMS; i++) 
					m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;

				// v1.41
				if (bIsNotUsedItemFound == false) {
					for (i = 0; i < DEF_MAXITEMS; i++) {
						wsprintf(cTxt, "%d", token[i]);
						if ((token[i] == '1') && (m_pClientList[iClientH]->m_pItemList[i] != 0)) {
							if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP) 
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = true;
							else m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;
						}
						else m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;

						if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_bIsItemEquipped[i] )) {
							if (bEquipItemHandler(iClientH, i) == false) // false
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = false; // ¸¸¾à Æ¯¼ºÄ¡ º¯µ¿À¸·Î ÀåÂøµÈ ¾ÆÀÌÅÛÀÌ ÀåÂøµÇÁö ¾Ê¾Æ¾ß ÇÑ´Ù¸é ÀåÂø ¾ÈÇÑ°ÍÀ» Ç¥½Ã 
						}
					}
				}

				cReadModeA = 0;
				break;

			case 12:
				ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
				strcpy(m_pClientList[iClientH]->m_cGuildName, token);
				cReadModeA = 0;
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iGuildRank = atoi(token);
				cReadModeA = 0;
				break;

			case 14:
				// HP 
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iHP = atoi(token);
				cReadModeA = 0;
				break;

			case 15:
				// DefenseRatio
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				//m_pClientList[iClientH]->m_iOriginDefenseRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurDefenseRatio = m_pClientList[iClientH]->m_iOriginDefenseRatio;
				cReadModeA = 0;
				break;

			case 16:
				// HitRatio
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				//m_pClientList[iClientH]->m_iOriginHitRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurHitRatio = m_pClientList[iClientH]->m_iOriginHitRatio;
				cReadModeA = 0;
				break;

			case 17:
				// Level  
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iLevel = atoi(token);
				cReadModeA = 0;
				break;

			case 18:
				// Str 
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iStr = atoi(token);
				cReadModeA = 0;
				break;

			case 19:
				// Int 
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iInt = atoi(token);
				cReadModeA = 0;
				break;

			case 20:
				// Vit 
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iVit = atoi(token);
				cReadModeA = 0;
				break;

			case 21:
				// Dex 
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iDex = atoi(token);
				cReadModeA = 0;
				break;

			case 22:
				// Mag 
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iMag = atoi(token);
				cReadModeA = 0;
				break;

			case 23:
				// Charisma 
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iCharisma = atoi(token);
				cReadModeA = 0;
				break;

			case 24:
				// Luck 
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iLuck = atoi(token);
				cReadModeA = 0;
				break;

			case 25:
				// Exp 
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iExp = atol(token);
				cReadModeA = 0;
				break;

			case 26:
				// Magic-Mastery
				for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
					m_pClientList[iClientH]->m_cMagicMastery[i] = token[i] - 48;
				}
				cReadModeA = 0;
				break;

			case 27:
				// Skill-Mastery
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_cSkillMastery[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;
				//
			case 28:
				// Warehouse
				switch(cReadModeB) {
			case 1:
				if (iItemInBankIndex >= DEF_MAXBANKITEMS) {
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				// token
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], token) == false) {
					wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
					PutLogList(cTxt);

					// Debug code @@@@@@@@@@@@@@@
					HANDLE hFile;
					DWORD  nWrite;
					hFile = CreateFile("Error.Log", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0);
					WriteFile(hFile, (char *)pOriginContents, dwSize+2, &nWrite, 0);
					CloseHandle(hFile);
					///////////// @@@@@@@@@@@@@@@

					delete[] pContents;
					delete pStrTok;
					return false;
				}
				cReadModeB = 2;
				break;

			case 2:
				// m_dwCount
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				iTemp = atoi(token);
				if (iTemp < 0) iTemp = 1;

				if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
					iTemp = 1;
					wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¾ÆÀÌÅÛ(%s) °³¼ö ¿À¹öÇÃ·Î¿ì", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName);
					PutLogFileList(G_cTxt);
					PutLogList(G_cTxt);
				}

				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwCount = (DWORD)iTemp;
				cReadModeB = 3;

				// v1.3
				if (memcmp(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName, "Gold", 4) == 0)
					iTotalGold += iTemp;
				break;

			case 3:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// m_cItemColor
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemColor = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// m_sItemSpecEffectValue1
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// m_sItemSpecEffectValue2
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue2 = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// m_sItemSpecEffectValue3
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue3 = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// m_wCurLifeSpan
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = atoi(token);

				cReadModeB = 12;
				break;


			case 12:
				// m_dwAttribute
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;

				// v1.41
				if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0x00000001) != 0) {
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;

				}

				// v2.16 2002-5-21
				int iValue = (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (iValue > 0) {
					switch (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cCategory) {
			case 5: 
			case 6:  
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
				break;
					}
				}

				// v1.42
				_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

				// v1.41
				if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan)
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan;
				

				// v1.433
				if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan == 0) && 
					(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¼ö¸í 0Â¥¸® Èñ»ý¼® ¼ÒÁö!", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = 1;
					}

					// v1.4
					if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = 0;
					}
					else 
						if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]) ) {
							// v1.42
							_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, 0, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

							iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
							delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = 0;		
						}
						else iItemInBankIndex++;
						break;
				}
				break;
				//

			case 29:
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy(m_pClientList[iClientH]->m_cLocation, token);
				if (memcmp(m_pClientList[iClientH]->m_cLocation+3,"hunter",6) == 0)
					m_pClientList[iClientH]->m_bIsPlayerCivil = true;
				cReadModeA = 0;
				break;

/* 2.03 Code - Fixed by KLKS
			case 29:
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy(m_pClientList[iClientH]->m_cLocation, token);
				cReadModeA = 0;
				break;
*/
			case 30:
				// m_iMP
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iMP = atoi(token);
				cReadModeA = 0;
				break;

			case 31:
				// m_iSP
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iSP = atoi(token);
				cReadModeA = 0;
				break;

			case 32:
				// m_cLU_Pool
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iLU_Pool = atoi(token);
				cReadModeA = 0;
				break;
			/*
			case 33:
				// m_cLU_Vit
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_cLU_Vit = atoi(token);
				cReadModeA = 0;
				break;

			case 34:
				// m_cLU_Dex
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_cLU_Dex = atoi(token);
				cReadModeA = 0;
				break;

			case 35:
				// m_cLU_Int
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_cLU_Int = atoi(token);
				cReadModeA = 0;
				break;

			case 36:
				// m_cLU_Mag
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_cLU_Mag = atoi(token);
				cReadModeA = 0;
				break;

			case 37:
				// m_cLU_Char
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_cLU_Char = atoi(token);
				cReadModeA = 0;
				break;
*/
			case 38:
				// m_iEnemyKillCount
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iEnemyKillCount = atoi(token);
				cReadModeA = 0;
				break;

			case 39:
				// m_iPKCount
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iPKCount = atoi(token);
				cReadModeA = 0;
				break;

			case 40:
				// m_iRewardGold
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iRewardGold = atol(token);
				cReadModeA = 0;
				break;

			case 41:
				// Skill-SSN
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iSkillSSN[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 42:
				if (token != 0) {
					ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
					strcpy(m_pClientList[iClientH]->m_cProfile, token);
				}
				cReadModeA = 0;
				break;

			case 43:
				// Hunger-Status
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iHungerStatus = atoi(token);
				cReadModeA = 0;
				break;

				case 44:
				// AdminUserLevel
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iAdminUserLevel = 0; //Default it to 0
				if (atoi(token) > 0) {
				for (i = 0; i < DEF_MAXADMINS; i++) {
					if(strlen(m_stAdminList[i].m_cGMName) == 0) break; //No more GM's on list
						if ((strlen(m_stAdminList[i].m_cGMName)) == (strlen(m_pClientList[iClientH]->m_cCharName))) {
							if(memcmp(m_stAdminList[i].m_cGMName,m_pClientList[iClientH]->m_cCharName,strlen(m_pClientList[iClientH]->m_cCharName)) == 0){
								m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
								break; //Break goes to cReadModeA = 0;, so no need to do it again
							}
						}
					}
				}
				cReadModeA = 0;
				break;
				
				/*case 44:
				// AdminUserLevel
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				for (i = 0; i < DEF_MAXADMINS; i++) {
					if (atoi(token) > 0) {
						if ((strlen(m_stAdminList[i].m_cGMName)) == (strlen(m_pClientList[iClientH]->m_cCharName))) {
							m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
							cReadModeA = 0;
							break;
						}
						else {
							m_pClientList[iClientH]->m_iAdminUserLevel = 0;
						}
					else m_pClientList[iClientH]->m_iAdminUserLevel = 0;
					}
				}
				cReadModeA = 0;
				break;*/

			case 45:
				// TimeLeft_ShutUp
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iTimeLeft_ShutUp = atoi(token);
				cReadModeA = 0;
				break;

			case 46:
				// TimeLeft_Rating
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iTimeLeft_Rating = atoi(token);
				cReadModeA = 0;
				break;

			case 47:
				// Rating
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iRating = atoi(token);
				cReadModeA = 0;
				break;

			case 48:
				// Guild GUID
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iGuildGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 49:
				// Down Skill Index
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iDownSkillIndex = atoi(token);
				cReadModeA = 0;
				break;

			case 50:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].x = atoi(token);
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 51:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = atoi(token);
				if (m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y < -10) m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = -10;
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 52:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_sCharIDnum1 = atoi(token);
				cReadModeA = 0;
				break;

			case 53:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_sCharIDnum2 = atoi(token);
				cReadModeA = 0;
				break;

			case 54:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_sCharIDnum3 = atoi(token);
				cReadModeA = 0;
				break;

			case 55:
				switch (cReadModeB) {
			case 1:
				// Penalty Block Year
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockYear = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				// Penalty Block Month
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockMonth = atoi(token);

				cReadModeB = 3;
				break;

			case 3:
				// Penalty Block day
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockDay = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			case 56:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iQuest = atoi(token);
				cReadModeA = 0;
				break;

			case 57:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iCurQuestCount = atoi(token);
				cReadModeA = 0;
				break;

			case 58:
				cReadModeA = 0;
				break;

			case 59:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iQuestRewardType = atoi(token);
				cReadModeA = 0;
				break;

			case 60:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iQuestRewardAmount = atoi(token);
				cReadModeA = 0;
				break;

			case 61:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 62:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iQuestID = atoi(token);
				cReadModeA = 0;
				break;

			case 63:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_bIsQuestCompleted = (bool)atoi(token);
				cReadModeA = 0;
				break;

			case 64:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = (bool)atoi(token);
				cReadModeA = 0;
				break;

			case 65:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = (bool)atoi(token);
				cReadModeA = 0;
				break;

			case 66:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iSpecialEventID = (bool)atoi(token);
				cReadModeA = 0;
				break;

			case 67:
				switch (cReadModeB) {
			case 1:
				// FightZone Number
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iFightzoneNumber = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iReserveTime = atoi(token);


				cReadModeB = 3;
				break;
			case 3:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pClientList[iClientH]->m_iFightZoneTicketNumber = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;
				break;

				}
				break;

			case 70:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iSuperAttackLeft = (bool)atoi(token);
				cReadModeA = 0;
				break;

			case 71:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iSpecialAbilityTime = atoi(token);
				cReadModeA = 0;
				break;

			case 72:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iWarContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 73:
				if (strlen(token) > 10) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, token);
				cReadModeA = 0;
				break;

			case 74:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iLockedMapTime = atoi(token);
				cReadModeA = 0;
				break;

			case 75:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iCrusadeDuty = atoi(token);
				cReadModeA = 0;
				break;

			case 76:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iConstructionPoint = atoi(token);
				cReadModeA = 0;
				break;

			case 77:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_dwCrusadeGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 78:
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iDeadPenaltyTime = atoi(token);
				cReadModeA = 0;
				break;

			case 79: // v2.06 12-4
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iPartyID = atoi(token);
				if (m_pClientList[iClientH]->m_iPartyID != 0) m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
				cReadModeA = 0;
				break;

			case 80: // v2.15
				if (_bGetIsStringIsNumber(token) == false) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = atoi(token);
				cReadModeA = 0;
				break;
			}
		}
		else {
			if (memcmp(token, "character-loc-map", 17) == 0)		 cReadModeA = 1;
			if (memcmp(token, "character-loc-x", 15) == 0)			 cReadModeA = 2;
			if (memcmp(token, "character-loc-y", 15) == 0)			 cReadModeA = 3;
			if (memcmp(token, "character-account-status", 21) == 0)  cReadModeA = 4;
			if (memcmp(token, "character-item", 14) == 0) {
				cReadModeA = 5;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
			}

			if (memcmp(token, "character-bank-item", 18) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = new class CItem;
			}

			if (memcmp(token, "sex-status", 10) == 0)        cReadModeA = 6;
			if (memcmp(token, "skin-status", 11) == 0)       cReadModeA = 7;
			if (memcmp(token, "hairstyle-status", 16) == 0)  cReadModeA = 8;
			if (memcmp(token, "haircolor-status", 16) == 0)  cReadModeA = 9;
			if (memcmp(token, "underwear-status", 16) == 0)  cReadModeA = 10;

			if (memcmp(token, "item-equip-status", 17) == 0)    cReadModeA = 11;
			if (memcmp(token, "character-guild-name", 20) == 0) cReadModeA = 12;
			if (memcmp(token, "character-guild-rank", 20) == 0) cReadModeA = 13;
			if (memcmp(token, "character-HP", 12) == 0)         cReadModeA = 14;
			if (memcmp(token, "character-DefenseRatio",22)==0)  cReadModeA = 15;
			if (memcmp(token, "character-HitRatio", 18) == 0)   cReadModeA = 16;
			if (memcmp(token, "character-LEVEL", 15) == 0)      cReadModeA = 17;
			if (memcmp(token, "character-STR", 13) == 0)        cReadModeA = 18;
			if (memcmp(token, "character-INT", 13) == 0)        cReadModeA = 19;
			if (memcmp(token, "character-VIT", 13) == 0)        cReadModeA = 20;
			if (memcmp(token, "character-DEX", 13) == 0)        cReadModeA = 21;
			if (memcmp(token, "character-MAG", 13) == 0)        cReadModeA = 22;
			if (memcmp(token, "character-CHARISMA", 18) == 0)   cReadModeA = 23;
			if (memcmp(token, "character-LUCK", 14) == 0)       cReadModeA = 24;
			if (memcmp(token, "character-EXP", 13) == 0)        cReadModeA = 25;
			if (memcmp(token, "magic-mastery", 13) == 0)        cReadModeA = 26;

			if (memcmp(token, "skill-mastery", 13) == 0) {
				cReadModeA = 27;
				cReadModeB = 0;
			}

			if (memcmp(token, "character-location", 18) == 0)   cReadModeA = 29;

			if (memcmp(token, "character-MP", 12) == 0)         cReadModeA = 30;
			if (memcmp(token, "character-SP", 12) == 0)         cReadModeA = 31;

			if (memcmp(token, "character-LU_Pool", 17) == 0)     cReadModeA = 32;

			/*
			if (memcmp(token, "character-LU_Str", 16) == 0)     cReadModeA = 32;
			if (memcmp(token, "character-LU_Vit", 16) == 0)     cReadModeA = 33;
			if (memcmp(token, "character-LU_Dex", 16) == 0)     cReadModeA = 34;
			if (memcmp(token, "character-LU_Int", 16) == 0)     cReadModeA = 35;
			if (memcmp(token, "character-LU_Mag", 16) == 0)     cReadModeA = 36;
			if (memcmp(token, "character-LU_Char",17) == 0)     cReadModeA = 37;
			*/

			if (memcmp(token, "character-EK-Count",18) == 0)    cReadModeA = 38;
			if (memcmp(token, "character-PK-Count",18) == 0)    cReadModeA = 39;

			if (memcmp(token, "character-reward-gold",21) == 0) cReadModeA = 40;
			if (memcmp(token, "skill-SSN", 9) == 0) 			cReadModeA = 41;
			if (memcmp(token, "character-profile", 17) == 0)	cReadModeA = 42;

			if (memcmp(token, "hunger-status", 13) == 0) 		cReadModeA = 43;
			if (memcmp(token, "admin-user-level", 16) == 0) 	cReadModeA = 44;
			if (memcmp(token, "timeleft-shutup", 15) == 0) 		cReadModeA = 45;
			if (memcmp(token, "timeleft-rating", 15) == 0) 		cReadModeA = 46;
			if (memcmp(token, "character-RATING", 16) == 0)	    cReadModeA = 47;

			if (memcmp(token, "character-guild-GUID", 20) == 0) cReadModeA = 48;

			if (memcmp(token, "character-downskillindex", 24) == 0) cReadModeA = 49;
			if (memcmp(token, "item-position-x", 16) == 0) {
				cReadModeA = 50;
				cReadModeB = 1;
			}
			if (memcmp(token, "item-position-y", 16) == 0) {
				cReadModeA = 51;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-IDnum1",16) == 0)		cReadModeA = 52;
			if (memcmp(token, "character-IDnum2",16) == 0)		cReadModeA = 53;
			if (memcmp(token, "character-IDnum3",16) == 0)		cReadModeA = 54;
			if (memcmp(token, "penalty-block-date",18) == 0) {
				cReadModeA = 55;
				cReadModeB = 1;
			}

			if (memcmp(token, "character-quest-number",22) == 0) cReadModeA = 56;
			if (memcmp(token, "current-quest-count",19) == 0)	 cReadModeA = 57;

			if (memcmp(token, "quest-reward-type", 17) == 0)    cReadModeA = 59;
			if (memcmp(token, "quest-reward-amount", 19) == 0)  cReadModeA = 60;

			if (memcmp(token, "character-contribution", 22) == 0)   cReadModeA = 61;
			if (memcmp(token, "character-quest-ID",18) == 0)        cReadModeA = 62;
			if (memcmp(token, "character-quest-completed",25) == 0) cReadModeA = 63;

			if (memcmp(token, "timeleft-force-recall", 21) == 0)	cReadModeA = 64;
			if (memcmp(token, "timeleft-firm-staminar", 22) == 0)	cReadModeA = 65;
			if (memcmp(token, "special-event-id", 16) == 0)			cReadModeA = 66;
			if (memcmp(token, "super-attack-left", 17) == 0)		cReadModeA = 70;

			if (memcmp(token, "reserved-fightzone-id", 21) == 0)	{
				cReadModeA = 67;
				cReadModeB = 1;
			}

			if (memcmp(token, "special-ability-time", 20) == 0)       cReadModeA = 71; 
			if (memcmp(token, "character-war-contribution", 26) == 0) cReadModeA = 72; 

			if (memcmp(token, "locked-map-name", 15) == 0) cReadModeA = 73;
			if (memcmp(token, "locked-map-time", 15) == 0) cReadModeA = 74;
			if (memcmp(token, "crusade-job", 11) == 0)     cReadModeA = 75;
			if (memcmp(token, "construct-point", 15) == 0) cReadModeA = 76;
			if (memcmp(token, "crusade-GUID", 12) == 0)    cReadModeA = 77;

			if (memcmp(token, "dead-penalty-time", 17) == 0) cReadModeA = 78;
			if (memcmp(token, "party-id", 8) == 0)           cReadModeA = 79; // v2.06 12-4
			if (memcmp(token, "gizon-item-upgade-left", 22) == 0) cReadModeA = 80; // v2.15 ÁöÁ¸¾ÆÀÌÅÛ¾÷±×·¹ÀÌµå

			if (memcmp(token, "[EOF]", 5) == 0) goto DPDC_STOP_DECODING;
		}

		token = pStrTok->pGet();
		//token = strtok( 0, seps );							    
	}													  

DPDC_STOP_DECODING:

	delete pStrTok;
	delete[] pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		wsprintf(cTxt, "(!!!) Player(%s) data file contents error(%d %d)! Connection closed.", m_pClientList[iClientH]->m_cCharName, cReadModeA, cReadModeB);
		PutLogList(cTxt);

		// Debug code @@@@@@@@@@@@@@@
		HANDLE hFile2;
		DWORD  nWrite2;
		hFile2 = CreateFile("Error.Log", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0);
		WriteFile(hFile2, (char *)pOriginContents, dwSize+2, &nWrite2, 0);
		CloseHandle(hFile2);
		///////////// @@@@@@@@@@@@@@@

		return false;
	}

	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (bRet == false) {
		if ((m_pClientList[iClientH]->m_sX != -1) || (m_pClientList[iClientH]->m_sY != -1)) {
			wsprintf(cTxt, "Invalid location error! %s (%d, %d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY); 
			PutLogList(cTxt);
			return false;
		}
	}

	/*	if ((m_pClientList[iClientH]->m_cLU_Str > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Str < 0)) 
	return false;

	if ((m_pClientList[iClientH]->m_cLU_Vit > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Vit < 0)) 
	return false;

	if ((m_pClientList[iClientH]->m_cLU_Dex > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Dex < 0)) 
	return false;

	if ((m_pClientList[iClientH]->m_cLU_Int > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Int < 0)) 
	return false;

	if ((m_pClientList[iClientH]->m_cLU_Mag > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Mag < 0)) 
	return false;

	if ((m_pClientList[iClientH]->m_cLU_Char > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Char < 0)) 
	return false;
	*/
	//	if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
	//  		  m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) > DEF_TOTALLEVELUPPOINT) 
	if ((m_pClientList[iClientH]->m_iLU_Pool < 0) || (m_pClientList[iClientH]->m_iLU_Pool > DEF_CHARPOINTLIMIT))
		return false;	

	if ((m_pClientList[iClientH]->m_iStr < 10) || (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT))
		return false;

	if ((m_pClientList[iClientH]->m_iDex < 10) || (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT))
		return false;

	if ((m_pClientList[iClientH]->m_iVit < 10) || (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT))
		return false;

	if ((m_pClientList[iClientH]->m_iInt < 10) || (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT))
		return false;

	if ((m_pClientList[iClientH]->m_iMag < 10) || (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT))
		return false;

	if ((m_pClientList[iClientH]->m_iCharisma < 10) || (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT))
		return false;

	//	if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + 
	//		 m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma) 
	//		 !=	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) return false;


	//if ((m_pClientList[iClientH]->m_cAccountStatus != 2) && (m_pClientList[iClientH]->m_iLevel > DEF_LEVELLIMIT)) 
	//	return false;

	if ((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == false) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == false)) 
		return false;

	if (m_pClientList[iClientH]->m_iPenaltyBlockYear != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)(m_pClientList[iClientH]->m_iPenaltyBlockYear*10000 + m_pClientList[iClientH]->m_iPenaltyBlockMonth*100 + m_pClientList[iClientH]->m_iPenaltyBlockDay);
		iDateSum2 = (__int64)(SysTime.wYear*10000 + SysTime.wMonth*100 + SysTime.wDay);
		if (iDateSum1 >= iDateSum2) return false;
	}

	// v1.4311-3
	if (m_pClientList[iClientH]->m_iReserveTime != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)m_pClientList[iClientH]->m_iReserveTime;
		iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
		if (iDateSum2 >= iDateSum1) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -2, 0, 0, 0);
			m_pClientList[iClientH]->m_iFightzoneNumber = 0; 
			m_pClientList[iClientH]->m_iReserveTime = 0;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
		}
	}

	// v1.42
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;

	// ============================================================================================================


	if (m_pClientList[iClientH]->m_cSex == 1) {
		sTmpType = 1;
	}
	else if (m_pClientList[iClientH]->m_cSex == 2) {
		sTmpType = 4; 
	}

	switch (m_pClientList[iClientH]->m_cSkin) {
	case 1:
		break;
	case 2:
		sTmpType += 1;
		break;
	case 3:
		sTmpType += 2;
		break;
	}

	// v1.41
	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 10) 
		sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;

	sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);

	m_pClientList[iClientH]->m_sType  = sTmpType;
	m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;

	iCalcTotalWeight(iClientH);

	// v1.3
	//if (iTotalGold > 800000) {
	//	wsprintf(G_cTxt, "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) Gold(%d)", m_pClientList[iClientH]->m_cCharName, iTotalGold);
	//PutLogFileList(G_cTxt);
	//}

	// v.135 
	/*
	if ((m_pClientList[iClientH]->m_cSkillMastery[0] >= 70) || (m_pClientList[iClientH]->m_cSkillMastery[1] >= 70) ||
	(m_pClientList[iClientH]->m_cSkillMastery[12] >= 70)) {
	wsprintf(G_cTxt, "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) ³ôÀº ½ºÅ³ (%d %d %d)", m_pClientList[iClientH]->m_cCharName, 
	m_pClientList[iClientH]->m_cSkillMastery[0], m_pClientList[iClientH]->m_cSkillMastery[1],
	m_pClientList[iClientH]->m_cSkillMastery[12]);
	PutLogFileList(G_cTxt);
	}
	*/

	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		// v1.3
		int _i, _iTemp1, _iTemp2;
		short _sID1, _sID2, _sID3;

		_iTemp1 = 1;
		_iTemp2 = 1;
		for (_i = 0; _i < 10; _i++) {
			_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
			_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
		}

		_sID1 = (short)timeGetTime(); 
		_sID2 = (short)_iTemp1; 
		_sID3 = (short)_iTemp2; 

		m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
		m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
		m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
	}

	// v1.4
	m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;

	// 
	m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;

	// v1.41 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) m_pClientList[iClientH]->m_bIsNeutral = true;

	return true;
}

int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{
 SYSTEMTIME SysTime;
 char  cTxt[120], cTmp[21];
 POINT TempItemPosList[DEF_MAXITEMS];
 int   i, iPos;

	if (m_pClientList[iClientH] == 0) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n");
		
	strcat(pData, "[NAME-ACCOUNT]\n\n");
	strcat(pData, "character-name     = ");
	strcat(pData, m_pClientList[iClientH]->m_cCharName);
	strcat(pData, "\n");
	strcat(pData, "account-name       = ");
	strcat(pData, m_pClientList[iClientH]->m_cAccountName);
	strcat(pData, "\n\n");

	strcat(pData, "[STATUS]\n\n");
	strcat(pData, "character-profile 	=");
	if (strlen(m_pClientList[iClientH]->m_cProfile) == 0) {
		strcat(pData, "__________");
	}
	else strcat(pData, m_pClientList[iClientH]->m_cProfile);
	strcat(pData, "\n");

	strcat(pData, "character-location   = ");
	strcat(pData, m_pClientList[iClientH]->m_cLocation);
	strcat(pData, "\n");

	strcat(pData, "character-guild-name = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank
		strcat(pData, m_pClientList[iClientH]->m_cGuildName);
	}
	else strcat(pData, "NONE");
	strcat(pData, "\n");
	
	// GUID 
	strcat(pData, "character-guild-GUID = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d", m_pClientList[iClientH]->m_iGuildGUID);
		strcat(pData, cTxt);
	}
	else strcat(pData, "-1");
	strcat(pData, "\n");
		
	strcat(pData, "character-guild-rank = ");
	itoa( m_pClientList[iClientH]->m_iGuildRank, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	strcat(pData, "character-loc-map = ");
	strcat(pData, m_pClientList[iClientH]->m_cMapName);
	strcat(pData, "\n");
	strcat(pData, "character-loc-x   = ");
	itoa( m_pClientList[iClientH]->m_sX, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "character-loc-y   = ");
	itoa( m_pClientList[iClientH]->m_sY, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	//
	if (m_pClientList[iClientH]->m_iHP <= 0)  
		m_pClientList[iClientH]->m_iHP = 30;

	wsprintf(cTxt, "character-HP       = %d", m_pClientList[iClientH]->m_iHP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-MP       = %d",  m_pClientList[iClientH]->m_iMP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	if (m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 0; // v1.1
	wsprintf(cTxt, "character-SP       = %d",  m_pClientList[iClientH]->m_iSP);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-LEVEL    = %d", m_pClientList[iClientH]->m_iLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-RATING   = %d", m_pClientList[iClientH]->m_iRating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-STR      = %d", m_pClientList[iClientH]->m_iStr);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-INT      = %d", m_pClientList[iClientH]->m_iInt);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-VIT      = %d", m_pClientList[iClientH]->m_iVit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-DEX      = %d", m_pClientList[iClientH]->m_iDex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-MAG      = %d", m_pClientList[iClientH]->m_iMag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-CHARISMA = %d", m_pClientList[iClientH]->m_iCharisma);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LUCK     = %d", m_pClientList[iClientH]->m_iLuck);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-EXP      = %d", m_pClientList[iClientH]->m_iExp);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Pool  = %d", m_pClientList[iClientH]->m_iLU_Pool);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	/*	
	wsprintf(cTxt, "character-LU_Str   = %d", m_pClientList[iClientH]->m_cLU_Str);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Vit   = %d", m_pClientList[iClientH]->m_cLU_Vit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Dex   = %d", m_pClientList[iClientH]->m_cLU_Dex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Int   = %d", m_pClientList[iClientH]->m_cLU_Int);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Mag   = %d", m_pClientList[iClientH]->m_cLU_Mag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Char  = %d", m_pClientList[iClientH]->m_cLU_Char);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	*/
	wsprintf(cTxt, "character-EK-Count = %d", m_pClientList[iClientH]->m_iEnemyKillCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-PK-Count = %d", m_pClientList[iClientH]->m_iPKCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-reward-gold = %d", m_pClientList[iClientH]->m_iRewardGold);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-downskillindex = %d", m_pClientList[iClientH]->m_iDownSkillIndex);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-IDnum1 = %d", m_pClientList[iClientH]->m_sCharIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum2 = %d", m_pClientList[iClientH]->m_sCharIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum3 = %d", m_pClientList[iClientH]->m_sCharIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	/*
	wsprintf(cTxt, "party-rank = %d", m_pClientList[iClientH]->m_iPartyRank);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum1 = %d", m_pClientList[iClientH]->m_sPartyIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum2 = %d", m_pClientList[iClientH]->m_sPartyIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum3 = %d", m_pClientList[iClientH]->m_sPartyIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");
	*/

	strcat(pData, "sex-status       = ");
	itoa( m_pClientList[iClientH]->m_cSex, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "skin-status      = ");
	itoa( m_pClientList[iClientH]->m_cSkin, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "hairstyle-status = ");
	itoa( m_pClientList[iClientH]->m_cHairStyle, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "haircolor-status = ");
	itoa( m_pClientList[iClientH]->m_cHairColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "underwear-status = ");
	itoa( m_pClientList[iClientH]->m_cUnderwear, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "hunger-status    = %d", m_pClientList[iClientH]->m_iHungerStatus);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-shutup  = %d", m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-rating  = %d", m_pClientList[iClientH]->m_iTimeLeft_Rating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-force-recall  = %d", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-firm-staminar = %d", m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "admin-user-level = %d", m_pClientList[iClientH]->m_iAdminUserLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "penalty-block-date = %d %d %d", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-number = %d", m_pClientList[iClientH]->m_iQuest);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-ID     = %d", m_pClientList[iClientH]->m_iQuestID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "current-quest-count    = %d", m_pClientList[iClientH]->m_iCurQuestCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-type      = %d", m_pClientList[iClientH]->m_iQuestRewardType);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-amount    = %d", m_pClientList[iClientH]->m_iQuestRewardAmount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-contribution = %d", m_pClientList[iClientH]->m_iContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-war-contribution = %d", m_pClientList[iClientH]->m_iWarContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-completed = %d", (int)m_pClientList[iClientH]->m_bIsQuestCompleted);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "special-event-id = %d", (int)m_pClientList[iClientH]->m_iSpecialEventID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "super-attack-left = %d", (int)m_pClientList[iClientH]->m_iSuperAttackLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v1.4311-3
	wsprintf(cTxt, "reserved-fightzone-id = %d %d %d", m_pClientList[iClientH]->m_iFightzoneNumber, m_pClientList[iClientH]->m_iReserveTime,m_pClientList[iClientH]->m_iFightZoneTicketNumber  );
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "special-ability-time = %d", m_pClientList[iClientH]->m_iSpecialAbilityTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "locked-map-name = %s", m_pClientList[iClientH]->m_cLockedMapName);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "locked-map-time = %d", m_pClientList[iClientH]->m_iLockedMapTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "crusade-job = %d", m_pClientList[iClientH]->m_iCrusadeDuty);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "crusade-GUID = %d", m_pClientList[iClientH]->m_dwCrusadeGUID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "construct-point = %d", m_pClientList[iClientH]->m_iConstructionPoint);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.04 
	wsprintf(cTxt, "dead-penalty-time = %d", m_pClientList[iClientH]->m_iDeadPenaltyTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.06 12-4
	wsprintf(cTxt, "party-id = %d", m_pClientList[iClientH]->m_iPartyID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.15
	wsprintf(cTxt, "gizon-item-upgade-left = %d", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	strcat(pData,"\n\n");

	strcat(pData, "appr1 = ");
	itoa( m_pClientList[iClientH]->m_sAppr1, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr2 = ");
	//m_pClientList[iClientH]->m_sAppr2 = m_pClientList[iClientH]->m_sAppr2 & 0x0FFF;
	itoa( m_pClientList[iClientH]->m_sAppr2, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr3 = ");
	itoa( m_pClientList[iClientH]->m_sAppr3, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr4 = ");
	itoa( m_pClientList[iClientH]->m_sAppr4, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// v1.4 ApprColor
	strcat(pData, "appr-color = ");
	itoa( m_pClientList[iClientH]->m_iApprColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");

	strcat(pData, "[ITEMLIST]\n\n");

	for (i = 0; i < DEF_MAXITEMS; i++) { // v1.4
		TempItemPosList[i].x = 40;
		TempItemPosList[i].y = 30;
	}
	iPos = 0;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
		// v1.4
		TempItemPosList[iPos].x = m_pClientList[iClientH]->m_ItemPosList[i].x;
		TempItemPosList[iPos].y = m_pClientList[iClientH]->m_ItemPosList[i].y;
		iPos++;
		
		strcat(pData, "character-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemList[i]->m_cName)] = (char)' ';
		cTmp[20] = 0;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	// v1.4
	for (i = 0; i < DEF_MAXITEMS; i++) {
		m_pClientList[iClientH]->m_ItemPosList[i].x = TempItemPosList[i].x; 
		m_pClientList[iClientH]->m_ItemPosList[i].y = TempItemPosList[i].y;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] != 0) {
		strcat(pData, "character-bank-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName)] = (char)' ';
		cTmp[20] = 0;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	
	strcat(pData, "[MAGIC-SKILL-MASTERY]\n\n");

	strcat(pData, "//------------------012345678901234567890123456789012345678901234567890");
	strcat(pData,"\n");

	strcat(pData, "magic-mastery     = ");
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		wsprintf(cTxt,"%d", (int)m_pClientList[iClientH]->m_cMagicMastery[i]);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "skill-mastery     = ");
			
	
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_cSkillMastery[i]);

		strcat(pData, cTxt);
	}
	strcat(pData,"\n");
			
	strcat(pData, "skill-SSN     = ");
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_iSkillSSN[i]);

		strcat(pData, cTxt);
	}
	strcat(pData,"\n");
	
	strcat(pData, "[ITEM-EQUIP-STATUS]\n\n");
	strcat(pData, "item-equip-status = ");
	
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "00000000000000000000000000000000000000000000000000");
	              
	int iEP = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
		if ((m_pClientList[iClientH]->m_bIsItemEquipped[i] ) && 
			(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP)) {
			 cTxt[iEP] = '1';
		}
		iEP++;
	}
	strcat(pData, cTxt);
	strcat(pData, "\n");

	
	strcat(pData, "item-position-x = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].x);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "item-position-y = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].y);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n\n");
	
	strcat(pData, "[EOF]");
	strcat(pData, "\n\n\n\n");

	return strlen(pData);
}

bool CGame::_bDecodeItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iItemConfigListIndex, iTemp;
 class CStrTok * pStrTok;

	char cData[50000] = {};
	DWORD lpNumberOfBytesRead;
	HANDLE hFile = CreateFile(pData, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	DWORD dwFileSize = GetFileSize(hFile, 0);
	if (dwFileSize == -1) {
		wsprintf(G_cTxt, "(X) CRITICAL ERROR! Cannot open configuration file(%s)!", pData);
		PutLogList(pData);
		return false;
	}

	SetFilePointer(hFile, 0, 0, FILE_BEGIN);

	ReadFile(hFile, cData, dwFileSize, &lpNumberOfBytesRead, 0);
	CloseHandle(hFile);

	pContents = new char[dwFileSize + 1];
	ZeroMemory(pContents, dwFileSize + 1);
	memcpy(pContents, cData, dwFileSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok( pContents, seps );   
	while( token != 0 ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iItemConfigListIndex = atoi(token);
					
					//testcode
					if (iItemConfigListIndex == 490)
						iItemConfigListIndex = atoi(token);
					
					if (m_pItemConfigList[iItemConfigListIndex] != 0) {
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
						PutLogList(cTxt);
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex] = new class CItem;
					m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
					cReadModeB = 2;
					break;
				case 2:
					// m_cName 
					ZeroMemory(m_pItemConfigList[iItemConfigListIndex]->m_cName, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
					memcpy(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;
				case 3:
					// m_cItemType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_cEquipPos
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_sItemEffectType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_sItemEffectValue1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_sItemEffectValue2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB = 8;
					break;
				case 8:
					// m_sItemEffectValue3
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB = 9;
					break;
				case 9:
					// m_sItemEffectValue4
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB = 10;
					break;
				case 10:
					// m_sItemEffectValue5
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB = 11;
					break;
				case 11:
					// m_sItemEffectValue6
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB = 12;
					break;
				case 12:
					// m_wMaxLifeSpan
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					cReadModeB = 13;
					break;
				case 13:
					// m_sSpecialEffect
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
					cReadModeB = 14;
					break;
				case 14:
					// m_sSprite
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
					cReadModeB = 15;
					break;
				case 15:
					// m_sSpriteFrame
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB = 16;
					break;
				case 16:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iTemp = atoi(token);
					if (iTemp < 0) 
						 m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = false;
					else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = true;
					
					m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
					cReadModeB = 17;
					break;
				case 17:
					// m_wWeight
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
					cReadModeB = 18;
					break;
				case 18:
					// Appr Value
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
					cReadModeB = 19;
					break;
				case 19:
					// m_cSpeed
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// m_sLevelLimit
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_cGederLimit
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
					cReadModeB = 22;
					break;
				
				case 22:
					// m_sSpecialEffectValue1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
					cReadModeB = 23;
					break;

				case 23:
					// m_sSpecialEffectValue2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					// m_sRelatedSkill
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Item", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "[ENDITEMLIST]", 13) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto DICFC_STOPDECODING;
			}
		}
		token = pStrTok->pGet();
		//token = strtok( 0, seps );
	}
	
DICFC_STOPDECODING:

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) ITEM(Total:%d) configuration - success!", iItemConfigListIndex);
	PutLogList(cTxt);

	return true;
}


bool CGame::_bInitItemAttr(class CItem * pItem, char * pItemName)
{
 int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != 0) {
		if (memcmp(cTmpName, m_pItemConfigList[i]->m_cName, 20) == 0) {
			ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;					// ÃÖÃÊ·Î »ý¼ºµÈ ¾ÆÀÌÅÛÀÇ ¼ö¸íÀº ÃÖ´ëÄ¡ÀÌ´Ù.
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;
			
			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;
			
			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;

			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
	
			return true;
		}
	}

 	return false;
}


bool CGame::_bGetIsStringIsNumber(char * pStr)
{
 int i;
	for (i = 0; i < (int)strlen(pStr); i++)
	if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return false;
	
	return true;
}


bool CGame::_bReadMapInfoFiles(int iMapIndex)
{
	if (__bReadMapInfo(iMapIndex) == false) {
		return false;
	}

	return true;
}

bool CGame::bSetNpcFollowMode(char * pName, char * pFollowName, char cFollowOwnerType)
{
 int i, iIndex, iMapIndex, iFollowIndex;
 char cTmpName[11], cFollowSide;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	iMapIndex    = -1;
	iFollowIndex = -1;

	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != 0) && (memcmp(m_pNpcList[i]->m_cName, pName, 5) == 0) ) {
		iIndex = i;
		iMapIndex = m_pNpcList[i]->m_cMapIndex;
		goto NEXT_STEP_SNFM1;
	}

NEXT_STEP_SNFM1:

	switch (cFollowOwnerType) {
	case DEF_OWNERTYPE_NPC:
		for (i = 1; i < DEF_MAXNPCS; i++)
		if ((m_pNpcList[i] != 0) && (memcmp(m_pNpcList[i]->m_cName, pFollowName, 5) == 0) ) {
			if (m_pNpcList[i]->m_cMapIndex != iMapIndex) return false;
			iFollowIndex = i;
			cFollowSide = m_pNpcList[i]->m_cSide;
			goto NEXT_STEP_SNFM2;
		}
		break;
	
	case DEF_OWNERTYPE_PLAYER:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, pFollowName, 10) == 0) ) {
			if (m_pClientList[i]->m_cMapIndex != iMapIndex) return false;
			iFollowIndex = i;
			cFollowSide = m_pClientList[i]->m_cSide;
			goto NEXT_STEP_SNFM2;
		}
		break;
	}

NEXT_STEP_SNFM2:

	if ((iIndex == -1) || (iFollowIndex == -1)) return false;

	m_pNpcList[iIndex]->m_cMoveType = DEF_MOVETYPE_FOLLOW;
	m_pNpcList[iIndex]->m_cFollowOwnerType  = cFollowOwnerType;
	m_pNpcList[iIndex]->m_iFollowOwnerIndex = iFollowIndex;
	m_pNpcList[iIndex]->m_cSide             = cFollowSide;


	return true;
}


int CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sClass, char cSA, char cMoveType, int * poX, int * poY, char * pWaypointList, RECT * pArea, int iSpotMobIndex, char cChangeSide, bool bHideGenMode, bool bIsSummoned, bool bFirmBerserk, bool bIsMaster, int iGuildGUID)
{
 int i, t, j, k, iMapIndex;
 char  cTmpName[11], cTxt[120];
 short sX, sY, sRange;
 bool  bFlag;
 SYSTEMTIME SysTime;

	if (strlen(pName) == 0)   return false;
	if (strlen(pNpcName) == 0) return false;
	GetLocalTime(&SysTime);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);
	iMapIndex = -1;

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != 0) {
		if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0) 
			iMapIndex = i;
	}
	
	if (iMapIndex == -1) return false;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] == 0) {
		m_pNpcList[i] = new class CNpc(pName);
		if (_bInitNpcAttr(m_pNpcList[i], pNpcName, sClass, cSA) == false) {
			wsprintf(cTxt, "(!) Not existing NPC creation request! (%s) Ignored.", pNpcName);
			PutLogList(cTxt);
			
			delete m_pNpcList[i];
			m_pNpcList[i] = 0;
			return false;	
		}

		if (m_pNpcList[i]->m_cDayOfWeekLimit < 10) {
			if (m_pNpcList[i]->m_cDayOfWeekLimit != SysTime.wDayOfWeek)	{
				delete m_pNpcList[i];
				m_pNpcList[i] = 0;
				return false;	
			}
		}

		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
		case DEF_MOVETYPE_RANDOM:
			if ( (poX != 0) && (poY != 0) && (*poX != 0) && (*poY != 0) ) {
				sX = *poX;
				sY = *poY;
			}
			else {
				for ( j = 0; j <= 30; j++) {
					sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
					sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

					bFlag = true;
					for (k = 0; k < DEF_MAXMGAR; k++)
					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left != -1) {
						if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left) &&
							(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].right) &&
							(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].top) &&
							(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].bottom)) {
							// Avoid Rect
							bFlag = false;
						}
					}
					if (bFlag ) goto GET_VALIDLOC_SUCCESS;

				}
				delete m_pNpcList[i];
				m_pNpcList[i] = 0;
				return false;

GET_VALIDLOC_SUCCESS:;
				// sX, sY
			}
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			// pArea
			sRange = (short)(pArea->right - pArea->left);
			sX     = (short)((rand() % sRange) + pArea->left);
			sRange = (short)(pArea->bottom - pArea->top);
			sY     = (short)((rand() % sRange) + pArea->top);
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			// 10
			sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].x;
			sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].y;
			break;

		default:
			// poX, poY
			if ( (poX != 0) && (poY != 0) && (*poX != 0) && (*poY != 0) ) {
				sX = *poX;
				sY = *poY;
			}
			else {
				sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].x;
				sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].y;
			}
			break;
		}
		
		if (bGetEmptyPosition(&sX, &sY, iMapIndex) == false) {
			
			delete m_pNpcList[i];
			m_pNpcList[i] = 0;
			return false;
		}

		if ( (bHideGenMode ) && (_iGetPlayerNumberOnSpot(sX, sY, iMapIndex, 7) != 0) ) {
			delete m_pNpcList[i];
			m_pNpcList[i] = 0;
			return false;	
		}

		if ((poX != 0) && (poY != 0)) {
			*poX = sX;
			*poY = sY;
		}

		m_pNpcList[i]->m_sX = sX;
		m_pNpcList[i]->m_sY = sY;
		
		m_pNpcList[i]->m_vX = sX;
		m_pNpcList[i]->m_vY = sY;

		// WaypointIndex
		for (t = 0; t < 10; t++)
			m_pNpcList[i]->m_iWayPointIndex[t] = pWaypointList[t];

		// WaypointIndex
		m_pNpcList[i]->m_cTotalWaypoint = 0;
		for (t = 0; t < 10; t++)
		if (m_pNpcList[i]->m_iWayPointIndex[t] != -1) m_pNpcList[i]->m_cTotalWaypoint++;

		if (pArea != 0) {
			// RANDOMAREA Copy
			SetRect(&m_pNpcList[i]->m_rcRandomArea, pArea->left, pArea->top, pArea->right, pArea->bottom);
		}

		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
			m_pNpcList[i]->m_dX = m_pNpcList[i]->m_sX;
			m_pNpcList[i]->m_dY = m_pNpcList[i]->m_sY;
			break;
		
		case DEF_MOVETYPE_SEQWAYPOINT: 
			m_pNpcList[i]->m_cCurWaypoint = 1;
			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			m_pNpcList[i]->m_cCurWaypoint = (rand() % (m_pNpcList[i]->m_cTotalWaypoint - 1)) + 1;
			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			m_pNpcList[i]->m_cCurWaypoint = 0;
			
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.right - m_pNpcList[i]->m_rcRandomArea.left);
			m_pNpcList[i]->m_dX = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.left);
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.bottom - m_pNpcList[i]->m_rcRandomArea.top);
			m_pNpcList[i]->m_dY = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.top);
			break;

		case DEF_MOVETYPE_RANDOM:
			m_pNpcList[i]->m_dX = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15);
			m_pNpcList[i]->m_dY = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15);
			break;
		}

		m_pNpcList[i]->m_tmp_iError  = 0;

		m_pNpcList[i]->m_cMoveType          = cMoveType;

		switch (m_pNpcList[i]->m_cActionLimit) {
		case 2:
		case 3:
		case 5:
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_STOP;
			
			switch (m_pNpcList[i]->m_sType) {
			case 15: // ShopKeeper-W
			case 19: // Gandlf
			case 20: // Howard
			case 24: // Tom
			case 25: // William
			case 26: // Kennedy
				m_pNpcList[i]->m_cDir      = 4 + iDice(1,3) -1;
				break;

			default:
				m_pNpcList[i]->m_cDir      = iDice(1,8);
				break;
			}
			break;

		default: 
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
			m_pNpcList[i]->m_cDir      = 5;
			break;
		}

		m_pNpcList[i]->m_iFollowOwnerIndex  = 0;
		m_pNpcList[i]->m_iTargetIndex	    = 0;
		m_pNpcList[i]->m_cTurn              = (rand() % 2);
		
		switch (m_pNpcList[i]->m_sType) {
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
				m_pNpcList[i]->m_sAppr2 = 0xF000;
				m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | ((rand() % 13) << 4); // ¹«±â
				m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | (rand() % 9); // ¹æÆÐ 
				break;

			case 36: // AGT-Aresden/AGT-Elvine
			case 37: // CGT-Aresden/CGT-Elvine
			case 38: // MS-Aresden/MS-Elvine
			case 39: // DT-Aresden/DT-Elvine
				m_pNpcList[i]->m_sAppr2 = 3;
			break;
			
		//case 64: // Crop
		//	m_pNpcList[i]->m_sAppr2 = 1;
		//	break;
		// appr2 = 2 seems to be enemy detection for crusade

		/*case 91: // gate
			m_pNpcList[i]->m_sAppr2 = 0xF000; // 10 aura no sphere 13 no name movable with magic (crash) test to 29
			break;*/
		
		case 64: // Crop
			m_pNpcList[i]->m_sAppr2 = 1; // 1 bud; 2 grown; 3 large 
			break;
	
		// case 66: // Wyvern
		//	m_pNpcList[i]->m_iStatus = 0x00000010; 
		//	// m_pNpcList[i]->m_cSide = 2;
		//	break;

		default:
			m_pNpcList[i]->m_sAppr2 = 0;
			break;
		}
		
		m_pNpcList[i]->m_cMapIndex          = (char)iMapIndex;
		m_pNpcList[i]->m_dwTime             = timeGetTime() + (rand() % 10000);
		m_pNpcList[i]->m_dwActionTime      += (rand() % 300);
		m_pNpcList[i]->m_dwMPupTime			= timeGetTime();
		m_pNpcList[i]->m_dwHPupTime			= m_pNpcList[i]->m_dwMPupTime;
		m_pNpcList[i]->m_sBehaviorTurnCount	= 0;
		m_pNpcList[i]->m_bIsSummoned        = bIsSummoned;
		m_pNpcList[i]->m_bIsMaster          = bIsMaster;
		if (bIsSummoned ) 
			m_pNpcList[i]->m_dwSummonedTime = timeGetTime();

		if (bFirmBerserk ) {
			m_pNpcList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = 1;
			m_pNpcList[i]->m_iStatus = m_pNpcList[i]->m_iStatus | 0x20;
			//iExpRoll = iDice(m_pNpcList[i]->m_iExpDiceMin, m_pNpcList[i]->m_iExpDiceMax);
			//iExpRoll *= 2;
		}

		// !!!
		if (cChangeSide != -1) m_pNpcList[i]->m_cSide = cChangeSide;

		m_pNpcList[i]->m_cBravery = (rand() % 3) + m_pNpcList[i]->m_iMinBravery;
		m_pNpcList[i]->m_iSpotMobIndex		= iSpotMobIndex;
		m_pNpcList[i]->m_iGuildGUID         = iGuildGUID;
		//testcode
		if (iGuildGUID != 0) {
			wsprintf(G_cTxt, "Summon War Unit(%d) GUID(%d)", m_pNpcList[i]->m_sType, iGuildGUID);
			PutLogList(G_cTxt);
		}
		
		m_pMapList[iMapIndex]->SetOwner(i, DEF_OWNERTYPE_NPC, sX, sY);
		m_pMapList[iMapIndex]->m_iTotalActiveObject++;
		m_pMapList[iMapIndex]->m_iTotalAliveObject++;

		switch (m_pNpcList[i]->m_sType) {
		case 36: // AGT-Aresden/AGT-Elvine
		case 37: // CGT-Aresden/CGT-Elvine
		case 38: // MS-Aresden/MS-Elvine
		case 39: // DT-Aresden/DT-Elvine
		case 42: // ManaStone
			m_pMapList[iMapIndex]->bAddCrusadeStructureInfo(m_pNpcList[i]->m_sType, sX, sY, m_pNpcList[i]->m_cSide);
			break;

		case 64:
			m_pMapList[iMapIndex]->bAddCropsTotalSum();
			break;
		}
		
		SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);
		return true;
	}

	return false;
}

void CGame::NpcProcess()
{
 int i, iMaxHP;
 DWORD dwTime, dwActionTime;

	dwTime = timeGetTime();

	for (i = 1; i < DEF_MAXNPCS; i++) { 
		
		if (m_pNpcList[i] != 0) {
			if (m_pNpcList[i]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
				switch (iDice(1,7)) {
				case 1: dwActionTime = m_pNpcList[i]->m_dwActionTime; break;
				case 2: dwActionTime = m_pNpcList[i]->m_dwActionTime - 100; break;
				case 3: dwActionTime = m_pNpcList[i]->m_dwActionTime - 200; break;
				case 4: dwActionTime = m_pNpcList[i]->m_dwActionTime - 300; break;
				case 5: dwActionTime = m_pNpcList[i]->m_dwActionTime - 400; break;
				case 6: dwActionTime = m_pNpcList[i]->m_dwActionTime - 600; break;
				case 7: dwActionTime = m_pNpcList[i]->m_dwActionTime - 700; break;
				}
				if (dwActionTime < 600) dwActionTime = 600;
			}
			else dwActionTime = m_pNpcList[i]->m_dwActionTime; 		

			// v1.42
			if (m_pNpcList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] != 0) 
				dwActionTime += (dwActionTime/2);
		}
		
		if ((m_pNpcList[i] != 0) && ((dwTime - m_pNpcList[i]->m_dwTime) > dwActionTime)) {
			m_pNpcList[i]->m_dwTime = dwTime;
			
			if (abs(m_pNpcList[i]->m_cMagicLevel) > 0) {
				if ((dwTime - m_pNpcList[i]->m_dwMPupTime) > DEF_MPUPTIME) {
					m_pNpcList[i]->m_dwMPupTime = dwTime;	
					
					//if (m_pNpcList[i]->m_bIsSummoned == false)
					m_pNpcList[i]->m_iMana += iDice(1, (m_pNpcList[i]->m_iMaxMana/5));
					
					if (m_pNpcList[i]->m_iMana > m_pNpcList[i]->m_iMaxMana)
						m_pNpcList[i]->m_iMana = m_pNpcList[i]->m_iMaxMana;
				}
			}
			
			// HP
			if (((dwTime - m_pNpcList[i]->m_dwHPupTime) > DEF_HPUPTIME) && (m_pNpcList[i]->m_bIsKilled == false)) {
				m_pNpcList[i]->m_dwHPupTime = dwTime;	
				
				iMaxHP = iDice(m_pNpcList[i]->m_iHitDice, 8) + m_pNpcList[i]->m_iHitDice;
				if (m_pNpcList[i]->m_iHP < iMaxHP) {
					
					if (m_pNpcList[i]->m_bIsSummoned == false)
						m_pNpcList[i]->m_iHP += iDice(1, m_pNpcList[i]->m_iHitDice); // Hit Point
					
					if (m_pNpcList[i]->m_iHP > iMaxHP) m_pNpcList[i]->m_iHP = iMaxHP;
					if (m_pNpcList[i]->m_iHP <= 0)     m_pNpcList[i]->m_iHP = 1;
				}
			}
			
			switch (m_pNpcList[i]->m_cBehavior) {
			case DEF_BEHAVIOR_DEAD:
				NpcBehavior_Dead(i);
				break;
			case DEF_BEHAVIOR_STOP:
				NpcBehavior_Stop(i);
				break;
			case DEF_BEHAVIOR_MOVE:
				NpcBehavior_Move(i);
				break;
			case DEF_BEHAVIOR_ATTACK:
				NpcBehavior_Attack(i);
				break;
			case DEF_BEHAVIOR_FLEE:
				NpcBehavior_Flee(i);
				break;
			}

			// !!! m_pNpcList
			if ((m_pNpcList[i] != 0) && (m_pNpcList[i]->m_iHP != 0) && (m_pNpcList[i]->m_bIsSummoned )) {
				switch (m_pNpcList[i]->m_sType) {
				case 29:
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*90) 
						NpcKilledHandler(0, 0, i, 0);
					break;
				
				default:
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_SUMMONTIME) 
						NpcKilledHandler(0, 0, i, 0);
					break;
				}
			}
		}
	}
}

// 05/29/2004 - Hypnotoad - GM chat tweak
void CGame::ChatMsgHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 int i, iRet;
 WORD * wp;
 int  * ip;
 char * cp, * cp2;
 char   cBuffer[256], cTemp[256], cSendMode = 0;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (dwMsgSize > 83 +30) return;
 
	// v1.41 ShutUp Time
	if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) return;
	
	if (memcmp((pData + 10), m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;
 
	if ((m_pClientList[iClientH]->m_bIsObserverMode ) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
 
	// v1.432-2
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
	 
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	cp = (char *)(pData + 21);

	switch (m_bLogChatOption) {
		// Chat Logs of only players
		case 1:
			if (m_pClientList[iClientH]->m_iAdminUserLevel == 0){
			ZeroMemory(cTemp,sizeof(cTemp));
			pData[dwMsgSize-1] = 0;
			wsprintf(cTemp,"Loc(%s) IP(%s) PC(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, false,cTemp);
		}
		break;
		// Chat Logs of only GM
		case 2:
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
			ZeroMemory(cTemp,sizeof(cTemp));
			pData[dwMsgSize-1] = 0;
			wsprintf(cTemp,"Loc(%s) IP(%s) GM(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, false,cTemp);
		}
		break;
		// Chat logs of all
		case 3:
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
			ZeroMemory(cTemp,sizeof(cTemp));
			pData[dwMsgSize-1] = 0;
			wsprintf(cTemp,"Loc(%s) IP(%s) GM(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, false,cTemp);
		}
		else{
			ZeroMemory(cTemp,sizeof(cTemp));
			pData[dwMsgSize-1] = 0;
			wsprintf(cTemp,"Loc(%s) IP(%s) PC(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, false,cTemp);
		}	
		break;
		// Chat logs of none
		case 4:
			
		break;
	}

	/*	// New 08/05/2004
	// Log GM Chats
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
		ZeroMemory(cTemp,sizeof(cTemp));
		pData[dwMsgSize-1] = 0;
		wsprintf(cTemp,"GM Chat(%s):\"%s\"",m_pClientList[iClientH]->m_cCharName,cp);
		bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, false,cTemp);
	}*/

	switch (*cp) {
	case '@':
		*cp = 32;
		
		/*if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank == 0)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1;
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}*/
				
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 1;
		}
		else cSendMode = 0;
		
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;
		break;

	// New 08/05/2004
	// Party chat
	case '$':
		*cp = 32;

		if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iSP >= 3)){
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(0,iClientH,DEF_NOTIFY_SP,0,0,0,0);
			}
			cSendMode = 4;
		}
		else{
			cSendMode = 0;
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0){
			cSendMode = 0;
		}
		break;

	case '^':
		*cp = 32;

		/*if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10;
			cp2++;
			ip = (int *)cp2;
			*ip = 0;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}*/

		/*if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1;
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}*/

		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			(m_pClientList[iClientH]->m_iSP > 5) && m_pClientList[iClientH]->m_iGuildRank != -1) {
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP -= 3;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
				}
				cSendMode = 1;
			}
		else cSendMode = 0;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;
		
		// v1.4334
		if (m_pClientList[iClientH]->m_iHP < 0) cSendMode = 0;

		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '!':
		*cp = 32;
		
		/*if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10;
			cp2++;
			ip = (int *)cp2;
			*ip = 0;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}*/

		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			 (m_pClientList[iClientH]->m_iSP >= 5) ) {
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 5;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 2;
		}
		else cSendMode = 0;
		
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;
		
		// v1.4334
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = 0;

		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '~':
		*cp = 32;
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 3;
		}
		else cSendMode = 0;
		
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;
		// v1.4334
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = 0;
		break;

	case '/':
		ZeroMemory(cBuffer, sizeof(cBuffer));
		memcpy(cBuffer, cp, dwMsgSize - 21);
		cp = (char *)(cBuffer);
		
		// New 19/05/2004
		if (memcmp(cp, "/version", 8) == 0) {
			ShowVersion(iClientH);
			return;
		}

		// New 10/05/2004
		if (memcmp(cp, "/begincrusadetotalwar", 21) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
				GlobalStartCrusadeMode();
				wsprintf(cTemp, "(%s) GM Order(%s): begincrusadetotalwar", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
			}
			return;
		}
		
		if (memcmp(cp, "/endcrusadetotalwar", 19) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
				ManualEndCrusadeMode(0);
				wsprintf(cTemp, "(%s) GM Order(%s): endcrusadetotalwar", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
			}
			return;
		}

		// New 08/05/2004
		if (memcmp(cp, "/goto ", 6) == 0) {
			AdminOrder_GoTo(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/unsummonboss", 13) == 0) {
			AdminOrder_UnsummonBoss(iClientH);
			return;
		}

		if (memcmp(cp, "/clearnpc", 9) == 0) {
			AdminOrder_ClearNpc(iClientH);
			return;
		}

		/*if (memcmp(cp, "/clearmap", 9) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 1) {
			AdminOrder_CleanMap(iClientH, cp, dwMsgSize);
			}
			return;
		}*/

		if (memcmp(cp, "/setforcerecalltime ", 20) == 0) {
			AdminOrder_SetForceRecallTime(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/enableadmincommand ", 20) == 0) {
			AdminOrder_EnableAdminCommand(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/monstercount", 13) == 0) {
			AdminOrder_MonsterCount(iClientH,cp,dwMsgSize - 21);
			return;
		}

		// New 07/05/2004
		if (memcmp(cp, "/createparty", 12) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 1) {
			RequestCreatePartyHandler(iClientH);
			}
			return;
		}
		
		if (memcmp(cp, "/joinparty ", 11) == 0) {
			RequestJoinPartyHandler(iClientH,cp,dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/dismissparty", 13) == 0) {
			RequestDismissPartyHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/blueball", 9) == 0) {
			Command_BlueBall(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/redball", 8) == 0) {
			Command_RedBall(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/yellowball ", 12) == 0) {
			Command_YellowBall(iClientH, cp, dwMsgSize - 21);
			return;
		}
		
		if (memcmp(cp, "/getpartyinfo", 13) == 0) {
			GetPartyInfoHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/deleteparty", 12) == 0) {
			RequestDeletePartyHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/who", 4) == 0) {
			// New 08/05/2003
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelWho) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_TOTALUSERS, 0, 0, 0, 0);
			}
			return;
		}

		if (memcmp(cp, "/fi ", 4) == 0) {
			CheckAndNotifyPlayerConnection(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/to", 3) == 0) {
			ToggleWhisperPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setpf ", 7) == 0) {
			SetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

		//ArchAngel Addition
		if (memcmp(cp, "/weather", 8) == 0) { 
			AdminOrder_Weather(iClientH, cp, dwMsgSize - 21); 
			return; 
		}

		if (memcmp(cp, "/pf ", 4) == 0) {
			GetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/shutup ", 8) == 0) {
			ShutUpPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/rep+ ", 6) == 0) {
			SetPlayerReputation(iClientH, cp, 1, dwMsgSize - 21);
			return;
		}

		
		if (memcmp(cp,"/time ", 6) == 0) {
			AdminOrder_Time(iClientH, cp, dwMsgSize - 21);
				return;
		}

		if (memcmp(cp,"/getskills", 10) == 0) {
			SetSkillAll(iClientH, cp, dwMsgSize - 21);
				return;
		}

		if (memcmp(cp, "/checkrep", 9) == 0) {
			AdminOrder_CheckRep(iClientH,cp, dwMsgSize - 21);
			return;
		}		

		if (memcmp(cp, "/checkstatus ", 13) == 0) {
			AdminOrder_CheckStats(iClientH,cp, dwMsgSize - 21);
			return;
		}

        if (memcmp(cp, "/send ", 5) == 0) {
			AdminOrder_Pushplayer(iClientH, cp, dwMsgSize -21);
			return;
		}

		if (memcmp(cp, "/rep- ", 6) == 0) {
			SetPlayerReputation(iClientH, cp, 0, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/hold", 5) == 0) {
			SetSummonMobAction(iClientH, 1, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/tgt ", 5) == 0) {
			SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
			return;
		}

		if (memcmp(cp, "/free", 5) == 0) {
			SetSummonMobAction(iClientH, 0, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summonall ", 11) == 0) {
			AdminOrder_SummonAll(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summonguild", 12) == 0) {
			if ((!m_bIsCrusadeMode) || (m_pClientList[iClientH]->m_iGuildRank == 0)) {
				if (m_pClientList[iClientH]->m_iGuildRank == 0) {
					if (dwGetItemCount(iClientH, "Gold") >= 100000)  {
					SetItemCount(iClientH, "Gold", dwGetItemCount(iClientH, "Gold") - 50000);
					AdminOrder_SummonGuild(iClientH, cp, dwMsgSize - 21);
					return;
					}
				}
			}
 		}


		if (memcmp(cp, "/summonplayer ", 14) == 0) {
			AdminOrder_SummonPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/storm ", 7) == 0) {
			AdminOrder_SummonStorm(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summondeath ", 13) == 0) {
			AdminOrder_SummonDeath(iClientH);
			return;
		}

		if (memcmp(cp, "/kill ", 6) == 0) {
			AdminOrder_Kill(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/revive ", 8) == 0) {
			AdminOrder_Revive(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/closeconn ", 11) == 0) {
			AdminOrder_CloseConn(iClientH, cp, dwMsgSize - 21);
			return;
		}

		// v1.4311-3
		if (memcmp(cp, "/ban", 4) == 0) {
			UserCommand_BanGuildsman(iClientH, cp, dwMsgSize - 21);
			return;
		}

		// v1.4311-3
		if (memcmp(cp, "/reservefightzone", 17) == 0) {
			AdminOrder_ReserveFightzone(iClientH, cp, dwMsgSize - 21);
			return;
		}
		
		if (memcmp(cp, "/dissmiss ", 9) == 0) {
			UserCommand_DissmissGuild(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/attack ", 8) == 0) {
			AdminOrder_CallGuard(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/createfish ", 12) == 0) {
			AdminOrder_CreateFish(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/teleport ", 10) == 0 || memcmp(cp, "/tp ", 4) == 0) {
			AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summondemon ", 13) == 0) {
			AdminOrder_SummonDemon(iClientH);
			return;
		}

		if (memcmp(cp, "/unsummonall ", 13) == 0) {
			AdminOrder_UnsummonAll(iClientH);
			return;			
		}

		if (memcmp(cp, "/unsummondemon ", 15) == 0) {
			AdminOrder_UnsummonDemon(iClientH);
			return;			
		}

		if (memcmp(cp, "/checkip ", 9) == 0) {
			AdminOrder_CheckIP(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/polymorph ", 11) == 0) {
			AdminOrder_Polymorph(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setinvi ", 9) == 0) {
			AdminOrder_SetInvi(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/gns ", 4) == 0) {
			AdminOrder_GetNpcStatus(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setattackmode ", 15) == 0) {
			AdminOrder_SetAttackMode(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/summon ", 8) == 0) {
			AdminOrder_Summon(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setzerk ", 9) == 0) {
			AdminOrder_SetZerk(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setfreeze ", 11) == 0) {
			AdminOrder_SetFreeze(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setstatus ", 11) == 0) {
			AdminOrder_SetStatus(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/disconnectall ", 15) == 0) {
			AdminOrder_DisconnectAll(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/createitem ", 12) == 0) {
			AdminOrder_CreateItem(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/energysphere ", 14) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelEnergySphere) EnergySphereProcessor(true, iClientH);
			return;
		}

		if ((memcmp(cp, "/shutdownthisserverrightnow ", 28) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelShutdown)) {
			m_cShutDownCode      = 2;
			m_bOnExitProcess     = true;
			m_dwExitProcessTime  = timeGetTime();
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
			//bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, 0);
			
			return;
		}

		if ((memcmp(cp, "/setobservermode ", 17) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelObserver)) {
			AdminOrder_SetObserverMode(iClientH);
			return;
		}
		
		if ((memcmp(cp, "/getticket ", 11) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= 2)) {
			AdminOrder_GetFightzoneTicket(iClientH);
			return;
		}

		/*if (memcmp(cp, "/beginapocalypse ", 17) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 2) {
				GlobalStartApocalypseMode(iClientH, cp, dwMsgSize - 21);
			}
			return;
		}

		if (memcmp(cp, "/endapocalypse", 14) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
				GlobalEndApocalypseMode();
				wsprintf(cTemp, "(%s) GM Order(%s): endapocalypse", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
			}
			return;
		}*/
		
		if (memcmp(cp, "/beginheldenian ", 16) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 2) {
				ManualStartHeldenianMode(iClientH, cp, dwMsgSize - 21);
			}
			return;
		}
		
		if (memcmp(cp, "/endheldenian ", 14) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 2) {
				ManualEndHeldenianMode(iClientH, cp, dwMsgSize - 21);
			}
			return;
		}

		return;
	}

	pData[dwMsgSize-1] = 0;
		
	if ((m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 1) && (iDice(1,3) != 2)) {
		// Confuse Language
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
		
		while (*cp != 0) {
			if ((cp[0] != 0) && (cp[0] != ' ') && (cp[1] != 0) && (cp[1] != ' ')) {
				switch (iDice(1,3)) {
				case 1:	memcpy(cp, "¿ö", 2); break;
				case 2:	memcpy(cp, "¿ì", 2); break;
				case 3:	memcpy(cp, "¿ù", 2); break;
				}
				cp += 2;
			}
			else cp++; 
		}
	}
		
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
	
	if ((cSendMode == 0) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) {
		cSendMode = 20;
		
		if (*cp == '#') cSendMode = 0;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;
	}

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	*wp = (WORD)iClientH;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 16);
	*cp = cSendMode;

	if (cSendMode != 20) {
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			switch (cSendMode) {
			case 0:
				if (m_pClientList[i]->m_bIsInitComplete == false) break;
				
				if ( (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
					 (m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 12) &&
					 (m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 12) &&
					 (m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 9) &&
					 (m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 9) ) {
					
					// Crusade
					if (m_bIsCrusadeMode ) {
						if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 1:
				if (m_pClientList[i]->m_bIsInitComplete == false) break;

				if ( (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
					 (memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0) ) {
					
					// Crusade
					if (m_bIsCrusadeMode ) {
						if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 2:
			case 10:
				// Crusade
				if (m_bIsCrusadeMode ) {
					if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
						 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
					
			case 3:
				if (m_pClientList[i]->m_bIsInitComplete == false) break;

				if ( (m_pClientList[i]->m_cSide == m_pClientList[iClientH]->m_cSide) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;

			case 4:
				if (m_pClientList[i]->m_bIsInitComplete == false) break;
				if ( (m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
			}
				
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				//DeleteClient(i, true, true);
				break;
			}
		}
	}
	else {
		// New 16/05/2004
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);	
		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == 10000) {
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp = (char *)cBuffer;
			*cp = GSM_WHISFERMSG;
			cp++;
			memcpy(cp, m_pClientList[iClientH]->m_cWhisperPlayerName, 10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = (WORD)dwMsgSize;
			cp += 2;
			memcpy(cp, pData, dwMsgSize);
			cp += dwMsgSize;
			//bStockMsgToGateServer(cBuffer, dwMsgSize+13);

			//testcode
			//wsprintf(G_cTxt, "Sending Whisper Msg: %s %d", m_pClientList[iClientH]->m_cWhisperPlayerName, (13 +dwMsgSize));
			//PutLogList(G_cTxt);
		}
		else{
			if (m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ] != 0 &&
				strcmp(m_pClientList[iClientH]->m_cWhisperPlayerName, m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ]->m_cCharName) == 0){
					iRet = m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);	
					switch (m_bLogChatOption){

						case 1:
							if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel == 0){
								ZeroMemory(cTemp,sizeof(cTemp));
								wsprintf(cTemp,"GM Whisper   (%s):\"%s\"\tto Player(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
								bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, false,cTemp);
						}
						break;

						case 2:
							if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0){
								ZeroMemory(cTemp,sizeof(cTemp));
								wsprintf(cTemp,"GM Whisper   (%s):\"%s\"\tto GM(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
								bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, false,cTemp);
						}
						break;

						case 3:
							if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0){
								ZeroMemory(cTemp,sizeof(cTemp));
								wsprintf(cTemp,"GM Whisper   (%s):\"%s\"\tto GM(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
								bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, false,cTemp);
						}
						else{
								ZeroMemory(cTemp,sizeof(cTemp));
								wsprintf(cTemp,"Player Whisper   (%s):\"%s\"\tto Player(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
								bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, false,cTemp);
						}
						break;

						case 4:
							break;
						}
				}
		}

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//DeleteClient(i, true, true);
			break;
		}
	}
}


void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char * pName, char * pData, DWORD dwMsgSize)
{
 int i, iRet;
 DWORD * dwp;
 WORD * wp;
 short * sp;
 char * cp, cTemp[256], cSendMode = 0;

	ZeroMemory(cTemp, sizeof(cTemp));
	
	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;
	
	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = 0;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = 0;
	cp += 2;

	sp  = (short *)cp;
	*sp = 0;
	cp += 2;
	
	memcpy(cp, pName, 10);
	cp += 10;

	*cp = (char)iMsgType;
	cp++;

	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;

	switch (iMsgType) {
	case 1:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsInitComplete == false) break;
			if ( (m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) {
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
			}
		}
		break;

	case 2:
	case 10:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
		}
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, bool bResponse, bool bIsDash)
//  description			:: controls player attack
//	return value		:: int
//  last updated		:: October 29, 2004; 8:06 PM; Hypnotoad
//  commentary			:: - contains attack hack detection
//						   - added checks for Firebow and Directionbow to see if player is m_bIsInsideWarehouse, m_bIsInsideWizardTower, m_bIsInsideOwnTown 
//						   - added ability to attack moving object
//						   - fixed attack unmoving object
/////////////////////////////////////////////////////////////////////////////////////
// Incomplete: 
//			- Direction Bow damage disabled
//
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, bool bResponse, bool bIsDash)
{
 char cData[100];
 DWORD * dwp, dwTime, iExp;
 WORD  * wp;
 int     iRet, tdX = 0, tdY = 0, i;
 short   sOwner, sAbsX, sAbsY;
 char    cOwnerType;
 bool    bNearAttack = false, var_AC = false;
 short sItemIndex;
 int tX, tY, iErr, iStX, iStY;

	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled ) return 0;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	m_pClientList[iClientH]->m_iAttackMsgRecvCount++;
	if (m_pClientList[iClientH]->m_iAttackMsgRecvCount >= 7) {
		if (m_pClientList[iClientH]->m_dwAttackLAT != 0) {
			if ((dwTime - m_pClientList[iClientH]->m_dwAttackLAT) < (3500)) {		
				DeleteClient(iClientH, true, true, true);
				return 0;
			}
		}
		m_pClientList[iClientH]->m_dwAttackLAT = dwTime;
		m_pClientList[iClientH]->m_iAttackMsgRecvCount = 0;
	}

	if ((wTargetObjectID != 0) && (wType != 2)) {
		if (wTargetObjectID < DEF_MAXCLIENTS) {
			if (m_pClientList[wTargetObjectID] != 0) {
				tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
			}
		}
		else if ( (wTargetObjectID > 10000) && (wTargetObjectID < (10000 + DEF_MAXNPCS)) ) {
			if (m_pNpcList[wTargetObjectID - 10000] != 0) {
				tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
			}
		}

		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwner, &cOwnerType, dX, dY);
		if(sOwner == (wTargetObjectID - 10000)){
			tdX = m_pNpcList[sOwner]->m_sX;
			dX = tdX;
			tdY = m_pNpcList[sOwner]->m_sY;
			dY = tdY;
			bNearAttack = false;
			var_AC = true;
		}
		if (var_AC != true) {
			if ((tdX == dX) && (tdY == dY)) {
				bNearAttack = false;	
			}
			else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
				dX = tdX;
				dY = tdY;
				bNearAttack = true;
			}
		}
	}

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) {
		if (var_AC == false) {
			sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
			if (sItemIndex != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return 0;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
					if ((sAbsX > 4) || (sAbsY > 4)) wType = 0;
				}
				else{
					if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
				}
			}
			else{
				if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
			}
		}
		else{
			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bCheckFlySpaceAvailable(sX, sY, cDir, sOwner)))
				wType = 0;
		}
	}

	ClearSkillUsingStatus(iClientH);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	m_pClientList[iClientH]->m_cDir = cDir;

	iExp = 0;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
		
	if (sOwner != 0) {
		if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) { 
			if ((m_pClientList[iClientH]->m_pIsProcessingAllowed == false) && (m_pClientList[iClientH]->m_bIsInsideWarehouse == false) 
				&& (m_pClientList[iClientH]->m_bIsInsideWizardTower == false) && (m_pClientList[iClientH]->m_bIsInsideOwnTown == false)) {
				
				DWORD dwType1 = 0, dwType2, dwValue1, dwValue2;
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
					sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				}
				else if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
					sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				}
				else sItemIndex = -1;

				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
						dwType1 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
						dwValue1 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
						dwType2 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;
						dwValue2 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
					}

					if (dwType1 == 2) {
						// Centuu - fix for poison
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwner]->m_iAdminUserLevel < 1 && !m_pClientList[sOwner]->m_bIsPoisoned && !bCheckResistingPoisonSuccess(sOwner, cOwnerType))
							{
								m_pClientList[sOwner]->m_bIsPoisoned = true;
								m_pClientList[sOwner]->m_iPoisonLevel = dwValue1 * 5;
								m_pClientList[sOwner]->m_dwPoisonTime = dwTime;
								SetPoisonFlag(sOwner, cOwnerType, true);
								SendNotifyMsg(0, sOwner, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sOwner]->m_iPoisonLevel, 0, 0);
							}
							break;
						case DEF_OWNERTYPE_NPC:
							break;
						}
					}
				}
				
				sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
					if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 874){ // Directional bow
						for(i = 2; i < 10; i++){
							iErr = 0;
							m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX, tY);
							//iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, tX, tY, wType, bNearAttack, bIsDash, true); // 1
							if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
								//iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false); // 0
							}
						}
					}
					else if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 873){ // Firebow
						if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) != 0) {
							if (m_bHeldenianInitiated != 1) {
								iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (iDice(1,7)+3)*1000, 8);
							}
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false); // 0
						}
					}
					else{
						iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false); // 0
					}
				}
				else{
					iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false); // 0
				}
			}
			else{
				iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false); // 0
			}
			if (m_pClientList[iClientH] == 0) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		}
	}
	else _CheckMiningAction(iClientH, dX, dY);

	if (iExp != 0) {
		GetExp(iClientH, iExp, true);
	}

	if (bResponse ) {
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOTION_ATTACK_CONFIRM;
	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
	}

	return 1;
}

char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError)
{
 char  cDir, cTmpDir;
 int   aX, aY, dX, dY;
 int   i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;
 
	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else m_Misc.GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = m_Misc.cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
	for (i = cDir; i <= cDir + 7;i++) {
		cTmpDir = i;
		if (cTmpDir > 8) cTmpDir -= 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) ) return cTmpDir;
	}

	if (cTurn == 1)
	for (i = cDir; i >= cDir - 7;i--) {
		cTmpDir = i;
		if (cTmpDir < 1) cTmpDir += 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) ) return cTmpDir;
	}

	return 0;
}


char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };

bool CGame::bGetEmptyPosition(short * pX, short * pY, char cMapIndex)
{
 int i;
 short sX, sY;	
	
	for (i = 0; i < 25; i++) 
	if ( (m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) ) &&
		 (m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == false) ) {
		sX = *pX + _tmp_cEmptyPosX[i];
		sY = *pY + _tmp_cEmptyPosY[i];	
		*pX = sX;
		*pY = sY;
		return true;
	}

	
	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;

	return false;
}

void CGame::NpcBehavior_Move(int iNpcH)
{
 char  cDir;
 short sX, sY, dX, dY, absX, absY;
 short sTarget, sDistance;
 char  cTargetType;
	
	if (m_pNpcList[iNpcH] == 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled ) return;
	if ((m_pNpcList[iNpcH]->m_bIsSummoned ) && 
		(m_pNpcList[iNpcH]->m_iSummonControlMode == 1)) return;
	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 2:
	case 3:
	case 5:
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_STOP;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		return;
	}
	
	// v1.432-2
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != 0) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}

	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		
		absX = abs(m_pNpcList[iNpcH]->m_vX - m_pNpcList[iNpcH]->m_sX);
		absY = abs(m_pNpcList[iNpcH]->m_vY - m_pNpcList[iNpcH]->m_sY);
		
		if ((absX <= 2)	&& (absY <= 2)) {
			CalcNextWayPointDestination(iNpcH);
		}

		m_pNpcList[iNpcH]->m_vX = m_pNpcList[iNpcH]->m_sX;
		m_pNpcList[iNpcH]->m_vY = m_pNpcList[iNpcH]->m_sY;
	}

	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != 0) {
		if (m_pNpcList[iNpcH]->m_dwActionTime < 1000) {
			if (iDice(1,3) == 3) {
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
				m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
				return;
			}
		}
		else {
			m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
			m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
			return;
		}
	}
	
	if ((m_pNpcList[iNpcH]->m_bIsMaster ) && (iDice(1,3) == 2)) return;
	
	if (m_pNpcList[iNpcH]->m_cMoveType == DEF_MOVETYPE_FOLLOW) {
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
		switch (m_pNpcList[iNpcH]->m_cFollowOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == 0) {
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				return;
			}

			dX = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == 0) {
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = 0;
				//bSerchMaster(iNpcH);
				return;
			}
			
			dX = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		}

		if (abs(sX - dX) >= abs(sY - dY)) 
			 sDistance = abs(sX - dX);
		else sDistance = abs(sY - dY);

		if (sDistance >= 3) {
			cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) {
			}
			else {
				dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
				dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(3, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
				m_pNpcList[iNpcH]->m_sX   = dX;
				m_pNpcList[iNpcH]->m_sY   = dY;
				m_pNpcList[iNpcH]->m_cDir = cDir;
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
			}
		}
	}
	else 
	{
		cDir = cGetNextMoveDir(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 
			                   m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY, 
				     	       m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
						
		if (cDir == 0) {
			if (iDice(1,10) == 3) CalcNextWayPointDestination(iNpcH);
		}
		else {
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(4, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
		}
	}
}

void CGame::TargetSearch(int iNpcH, short * pTarget, char * pTargetType)
{
 int ix, iy, iPKCount;
 short sX, sY, rX, rY, dX, dY;
 short sOwner, sTargetOwner, sDistance, sTempDistance;
 char  cOwnerType, cTargetType, cTargetSide;
 int   iInv;

	sTargetOwner = 0;
	cTargetType  = 0;
	sDistance    = 100;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	
	for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; ix++)
	for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; iy++) {
		
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
		if (sOwner != 0) {
			if ((sOwner == iNpcH) && (cOwnerType == DEF_OWNERTYPE_NPC)) break; // ÀÚ±â ÀÚ½ÅÀÌ¸é ¹«½Ã 
			
			iPKCount = 0;
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner] == 0) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(5, sOwner, DEF_OWNERTYPE_PLAYER, ix, iy);
				}
				else {
					if (m_pClientList[sOwner]->m_iAdminUserLevel > 0) goto SKIP_SEARCH;

					dX = m_pClientList[sOwner]->m_sX;
					dY = m_pClientList[sOwner]->m_sY;
					cTargetSide = m_pClientList[sOwner]->m_cSide;
					iPKCount    = m_pClientList[sOwner]->m_iPKCount;
					iInv        = m_pClientList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwner] == 0) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(6, sOwner, DEF_OWNERTYPE_NPC, ix, iy);
				}
				else {
					dX = m_pNpcList[sOwner]->m_sX;
					dY = m_pNpcList[sOwner]->m_sY;
					cTargetSide = m_pNpcList[sOwner]->m_cSide;
					iPKCount    = 0;
					iInv        = m_pNpcList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];

					if (m_pNpcList[iNpcH]->m_sType == 21) {
						if (_iCalcPlayerNum(m_pNpcList[sOwner]->m_cMapIndex, dX, dY, 2) != 0) {
							sOwner     = 0;
							cOwnerType = 0;
						}
					}
				}
				break;
			}
			
			if (m_pNpcList[iNpcH]->m_cSide < 10) {
				// NPC
				if (cTargetSide == 0) {
					if (iPKCount == 0) goto SKIP_SEARCH;
				}
				else {
					if ((iPKCount == 0) && (cTargetSide == m_pNpcList[iNpcH]->m_cSide)) goto SKIP_SEARCH;
					if (m_pNpcList[iNpcH]->m_cSide == 0) goto SKIP_SEARCH;
				}
			}
			else {
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0)) goto SKIP_SEARCH;
				if (cTargetSide == m_pNpcList[iNpcH]->m_cSide) goto SKIP_SEARCH;
			}

			if ((iInv != 0) && (m_pNpcList[iNpcH]->m_cSpecialAbility != 1)) goto SKIP_SEARCH;

			if (abs(sX - dX) >= abs(sY - dY)) 
				 sTempDistance = abs(sX - dX);
			else sTempDistance = abs(sY - dY);

			if (sTempDistance <	sDistance) {
				sDistance = sTempDistance;
				sTargetOwner = sOwner;
				cTargetType  = cOwnerType;
			}
SKIP_SEARCH:;
		}
	}

	*pTarget     = sTargetOwner;
	*pTargetType = cTargetType;
	return;
}

void CGame::NpcBehavior_Attack(int iNpcH)
{
 int   iMagicType;
 short sX, sY, dX, dY;
 char  cDir;
 DWORD dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == 0) return;
 	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled ) return;
	
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 1:
	case 2:
	case 3:
	case 4:
		return;

	case 5:
		if (m_pNpcList[iNpcH]->m_iBuildCount > 0) return;
	}
	
	// v1.432-2
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != 0) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}

	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount == 0) 
		m_pNpcList[iNpcH]->m_iAttackCount = 0;

	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 20) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == false))
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;

		return;
	}

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == 0) {
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == 0) {
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}

	if ( (iGetDangerValue(iNpcH, dX, dY) > m_pNpcList[iNpcH]->m_cBravery) && 
		 (m_pNpcList[iNpcH]->m_bIsPermAttackMode == false) &&
		 (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {
		
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}

	if ( (m_pNpcList[iNpcH]->m_iHP <= 2) && (iDice(1,m_pNpcList[iNpcH]->m_cBravery) <= 3) &&
		 (m_pNpcList[iNpcH]->m_bIsPermAttackMode == false) &&
		 (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}

	if ((abs(sX - dX) <= 1) && (abs(sY - dY) <= 1)) {
		
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		m_pNpcList[iNpcH]->m_cDir = cDir;				  

		if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
			switch (m_pNpcList[iNpcH]->m_sType) {
			case 89:
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, dX, dY, 61);
				break;

			case 87:
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); 
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
				break;
				
			case 36: // Crossbow Guard Tower: Ȱ 
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 2); // Ȱ
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2, false, false, false);
				break;

			case 37: // Cannon Guard Tower: 
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, dX, dY, 61);
				break;
			}
		}
		else {
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Į  ϴ ǹ 
			iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 1, false, false); // ݿ  ȿ Ѵ. 
		}
		m_pNpcList[iNpcH]->m_iAttackCount++;

		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == false) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
			switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
			case DEF_ATTACKAI_EXCHANGEATTACK:
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				break;

			case DEF_ATTACKAI_TWOBYONEATTACK:
				if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				}
				break;
			}
		}
	}
	else {
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		m_pNpcList[iNpcH]->m_cDir = cDir;				  
			
		if ((m_pNpcList[iNpcH]->m_cMagicLevel > 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			switch (m_pNpcList[iNpcH]->m_cMagicLevel) {
			case 1:
				if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;

			case 2:
				if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;

			case 3: // Orc-Mage
				if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 4:
				if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 5: // Rudolph, Cannibal-Plant, Cyclops
				if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 6: // Tentocle, Liche
				if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 7: // Barlog, Fire-Wyvern, MasterMage-Orc , LightWarBeatle, GHK, GHKABS, TK, BG
				    // Sor, Gagoyle, Demon
				if ((m_pMagicConfigList[70]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,5) == 3)) 
					iMagicType = 70;
				else if (m_pMagicConfigList[61]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 61;
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60;
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				break;

			case 8: // Unicorn, Centaurus
				if ((m_pMagicConfigList[35]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 35;
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60;
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				break;

			case 9: // Tigerworm
				if ((m_pMagicConfigList[74]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 74; // Lightning-Strike
				break;
			
			case 10: // Frost, Nizie
				break;

			case 11: // Ice-Golem
				break;

			case 12: // Wyvern
				if ((m_pMagicConfigList[91]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 91; // Blizzard
				else if (m_pMagicConfigList[63]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 63; // Mass-Chill-Wind
				break;

			case 13: // Abaddon
				if ((m_pMagicConfigList[96]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 96; // Earth Shock Wave
				else if (m_pMagicConfigList[81]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 81; // Metoer Strike
				break;

			}

			if (iMagicType != -1) {
				
				if (m_pNpcList[iNpcH]->m_iAILevel >= 2) {
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						if ((iMagicType == 35) && (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						if ((iMagicType == 35) && (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;
					}
				}
				
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Į  ϴ ǹ 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}

		if ((m_pNpcList[iNpcH]->m_cMagicLevel < 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 43;
			else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 37;
			else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 0;

			if (iMagicType != -1) {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Į  ϴ ǹ 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}

		// v1.41
		if ((m_pNpcList[iNpcH]->m_iAttackRange > 1) && 
			(abs(sX - dX) <= m_pNpcList[iNpcH]->m_iAttackRange) && (abs(sY - dY) <= m_pNpcList[iNpcH]->m_iAttackRange)) {
						
			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if (cDir == 0) return;
			m_pNpcList[iNpcH]->m_cDir = cDir;				  
			
			if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 36: // Crossbow Guard Tower
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;

				case 37: // Cannon Guard Tower
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;
				}
			}
			else {
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 51: // v2.05 Catapult
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;

				case 54: // Dark Elf: Ȱ  Ѵ.
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); // 2: Ȱ 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;
				
				case 63: // Frost
				case 79: // Nizie
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == 0) goto NBA_BREAK1;
						if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
							NpcMagicHandler(iNpcH, dX, dY, 57);
						if ((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio) == false)) {
							if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
									                m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
								SendNotifyMsg(0, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == 0) goto NBA_BREAK1;
						if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
						NpcMagicHandler(iNpcH, dX, dY, 57);
						if ((m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio) == false)) {
							if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
								                    m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}	
				case 53: //Beholder
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == 0) goto NBA_BREAK1;
						if ((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio) == false)) {
							if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
									                m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
								SendNotifyMsg(0, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == 0) goto NBA_BREAK1;
						if ((m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio) == false)) {
							if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
								                    m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
NBA_BREAK1:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: ʻ
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
					break;
							
				default:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: ʻ 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
					break;
				}
			}
			m_pNpcList[iNpcH]->m_iAttackCount++;
			
			if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == false) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
				switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
				case DEF_ATTACKAI_EXCHANGEATTACK:
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					break;
			
				case DEF_ATTACKAI_TWOBYONEATTACK:
					if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					}
					break;
				}
			}
			return;
		}

NBA_CHASE:		

		if (m_pNpcList[iNpcH]->m_cActionLimit != 0) return;

		m_pNpcList[iNpcH]->m_iAttackCount = 0;

		{
			cDir = cGetNextMoveDir(sX, sY, dX, dY,m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) {
				return;
			}
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(9, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
		}
	}
}

void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode)
{
 int i;
 DWORD dwTime = timeGetTime();

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != 0) {
		if ((m_pNpcList[i]->m_iGuildGUID != 0) && (cTargetType == DEF_OWNERTYPE_PLAYER) &&
			(m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {
			
			if (m_pNpcList[i]->m_cActionLimit == 0) {
				m_pNpcList[i]->m_bIsSummoned = true;
				m_pNpcList[i]->m_dwSummonedTime = dwTime;
			}
		}
		
		if ((m_pNpcList[i]->m_iTargetIndex == sTargetH) && 
			(m_pNpcList[i]->m_cTargetType == cTargetType)) {
			
			switch (iCode) {
			case DEF_MAGICTYPE_INVISIBILITY:
				if (m_pNpcList[i]->m_cSpecialAbility == 1) {
				}
				else {
					m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_iTargetIndex = 0;
					m_pNpcList[i]->m_cTargetType  = 0;
				}
				break;

			default:
				m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_iTargetIndex = 0;
				m_pNpcList[i]->m_cTargetType  = 0;
				break;
			}
		}
	}
}

void CGame::NpcKilledHandler(short sAttackerH, char cAttackerType, int iNpcH, short sDamage)
{
 short  sAttackerWeapon, sType;
 int    * ip, i, iQuestIndex, iConstructionPoint, iWarContribution, iMapIndex;
 double dTmp1, dTmp2, dTmp3;
 char   * cp, cData[120], cQuestRemain;
 DWORD iExp;

	if (m_pNpcList[iNpcH] == 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled ) return;

	m_pNpcList[iNpcH]->m_bIsKilled = true;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = sDamage;

	sType = m_pNpcList[iNpcH]->m_sType;

	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);

	ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC); 

	m_pNpcList[iNpcH]->m_iTargetIndex = 0;
	m_pNpcList[iNpcH]->m_cTargetType  = 0;
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, 0);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_DEAD;
	
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();

	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	
	NpcDeadItemGenerator(iNpcH, sAttackerH, cAttackerType);

	if ( (m_pNpcList[iNpcH]->m_bIsSummoned != true) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && 
		 (m_pClientList[sAttackerH] != 0) ) {
		iExp = (m_pNpcList[iNpcH]->m_iExp/3);
		if (m_pNpcList[iNpcH]->m_iNoDieRemainExp > 0)
			iExp += m_pNpcList[iNpcH]->m_iNoDieRemainExp;

		if (m_pClientList[sAttackerH]->m_iAddExp != 0) {
			dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
			dTmp2 = (double)iExp;
			dTmp3 = (dTmp1/100.0f)*dTmp2;
			iExp += (DWORD)dTmp3;
		}

		if (sType == 81) {
			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != 0) {		
				SendNotifyMsg(sAttackerH, i, DEF_NOTIFY_ABADDONKILLED, 0, 0, 0, 0,0,0,0,0,0,0, 0);		
				}
			}
		}

		if (m_bIsCrusadeMode ) {
			if (iExp > 10) iExp = iExp/3;
		}

		// New 09/05/2004
		//m_pClientList[sAttackerH]->m_iExpStock += iExp;
		GetExp(sAttackerH, iExp, true);

		// Quest
		iQuestIndex = m_pClientList[sAttackerH]->m_iQuest;
		if (iQuestIndex != 0) {
			if (m_pQuestConfigList[iQuestIndex] != 0) {
				switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
				case DEF_QUESTTYPE_MONSTERHUNT:
					if ( (m_pClientList[sAttackerH]->m_bQuestMatchFlag_Loc ) &&
						 (m_pQuestConfigList[iQuestIndex]->m_iTargetType == sType) ) {
						m_pClientList[sAttackerH]->m_iCurQuestCount++;
						cQuestRemain = (m_pQuestConfigList[m_pClientList[sAttackerH]->m_iQuest]->m_iMaxCount - m_pClientList[sAttackerH]->m_iCurQuestCount);
						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, 0, 0, 0);
						_bCheckIsQuestCompleted(sAttackerH);
					}
					break;
				}
			}
		}

		// Centuu - mob kill's counter
		if (m_pClientList[sAttackerH]->m_pMobKillCount[sType] == 0)
		{
			m_pClientList[sAttackerH]->m_pMobKillCount[sType] = new class CMobCounter(m_pNpcList[iNpcH]->m_cNpcName);
		}

		m_pClientList[sAttackerH]->m_pMobKillCount[sType]->iKillCount++;
		if (m_pClientList[sAttackerH]->m_pMobKillCount[sType]->iKillCount >= m_pClientList[sAttackerH]->m_pMobKillCount[sType]->iNextCount)
		{
			m_pClientList[sAttackerH]->m_pMobKillCount[sType]->iLevel++;
			m_pClientList[sAttackerH]->m_pMobKillCount[sType]->iNextCount *= 2;
		}

		RequestMobKills(sAttackerH); // refresh
	}

	// v1.41
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		switch (sType) {
		case 32:
			m_pClientList[sAttackerH]->m_iRating -= 5;
			if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = 0;
			if (m_pClientList[sAttackerH]->m_iRating >  10000) m_pClientList[sAttackerH]->m_iRating = 0;
			break;

		case 33:
			break;
		}
	}

	// Crusade
	iConstructionPoint = 0;
	switch (sType) {
	case 1:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 2:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 3:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 4:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 5:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 6:  iConstructionPoint = 50; iWarContribution = 100; break;	
	case 36: iConstructionPoint = 700; iWarContribution = 4000; break;	
	case 37: iConstructionPoint = 700; iWarContribution = 4000; break;	
	case 38: iConstructionPoint = 500; iWarContribution = 2000; break;	
	case 39: iConstructionPoint = 500; iWarContribution = 2000; break;	
	case 40: iConstructionPoint = 1500; iWarContribution = 5000; break;	
	case 41: iConstructionPoint = 5000; iWarContribution = 10000; break;
	case 43: iConstructionPoint =  500; iWarContribution = 1000; break;	
	case 44: iConstructionPoint = 1000; iWarContribution = 2000; break;	
	case 45: iConstructionPoint = 1500; iWarContribution = 3000; break;	
	case 46: iConstructionPoint = 1000; iWarContribution = 2000; break;	
	case 47: iConstructionPoint = 1500; iWarContribution = 3000; break;	
	case 64: m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum(); break;

	}
	
	// Crusade
	if (iConstructionPoint != 0) {
		switch (cAttackerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
				m_pClientList[sAttackerH]->m_iConstructionPoint += iConstructionPoint;

				if (m_pClientList[sAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[sAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
				if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				//testcode
				wsprintf(G_cTxt, "Enemy Npc Killed by player! Construction: +%d WarContribution: +%d", iConstructionPoint, iWarContribution);
				PutLogList(G_cTxt);

				SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, 0, 0);
			}
			else {
				m_pClientList[sAttackerH]->m_iWarContribution   -= (iWarContribution*2);
				if (m_pClientList[sAttackerH]->m_iWarContribution < 0)
					m_pClientList[sAttackerH]->m_iWarContribution = 0;

				//testcode
				wsprintf(G_cTxt, "Friendly Npc Killed by player! WarContribution: -%d", iWarContribution);
				PutLogList(G_cTxt);

				SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, 0, 0);
			}
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sAttackerH]->m_iGuildGUID != 0) {
				if (m_pNpcList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[sAttackerH]->m_iGuildGUID) &&
						(m_pClientList[i]->m_iCrusadeDuty == 3)) {
						
						m_pClientList[i]->m_iConstructionPoint += iConstructionPoint;
						if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
							m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

						//testcode
						wsprintf(G_cTxt, "Enemy Npc Killed by Npc! Construct point +%d", iConstructionPoint);
						PutLogList(G_cTxt);
						SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, 0);
						goto NKH_GOTOPOINT1;
					}
				
					/*ZeroMemory(cData, sizeof(cData));
					cp = (char *)cData;
					*cp = GSM_CONSTRUCTIONPOINT;
					cp++;
					ip = (int*)cp;
					*ip = m_pNpcList[sAttackerH]->m_iGuildGUID;
					cp += 4;
					ip = (int*)cp;
					*ip = iConstructionPoint;
					cp += 4;
					bStockMsgToGateServer(cData, 9);*/
				}
			}
			break;
		}
	}

NKH_GOTOPOINT1:

	// v1.411 Explosive
	if (m_pNpcList[iNpcH]->m_cSpecialAbility == 7) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 30); 
	}
	else if (m_pNpcList[iNpcH]->m_cSpecialAbility == 8) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 61); 
	}

	/*if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject == 0) && (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType  == 2) {
		//sub_428CD0
	}

	if (m_pNpcList[]->m_bIsApocalypseBoss ) {
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		var_BC = m_pNpcList[iNpcH]->m_cMapIndex;
		if (m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete ) && (var_BC >= 0) && (var_BC < DEF_MAXMAPS) {
			if ((m_pMapList[var_BC] != 0) && (m_pMapList[var_BC]->m_bRecallImpossible )) {
				m_pClientList[]->m_iTimeLeft_ForceRecall = 200;
				m_pClientList[i]->m_bIsImpossibleZone = true;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_FORCERECALLTIME,  m_pClientList[iClientH]->m_iTimeLeft_ForceRecall , 0, 0, 0);
			}
		}
	}*/

	if ((m_bIsHeldenianMode ) && (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsHeldenianMap ) && (m_cHeldenianModeType == 1)) {
		iMapIndex = 0;
		iMapIndex = m_pNpcList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cMapIndex;
		if (sType == 87 || sType == 89) {
			if (m_pNpcList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cSide == 1) {
				m_iHeldenianAresdenLeftTower--;
				wsprintf(G_cTxt, "Aresden Tower Broken, Left TOWER %d", m_iHeldenianAresdenLeftTower);
			}
			else if (m_pNpcList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cSide == 2) {
				m_iHeldenianElvineLeftTower--;
				wsprintf(G_cTxt, "Elvine Tower Broken, Left TOWER %d", m_iHeldenianElvineLeftTower);
			}
			PutLogList(G_cTxt);
			UpdateHeldenianStatus();
		}
		if ((m_iHeldenianElvineLeftTower == 0) || (m_iHeldenianAresdenLeftTower == 0)) {
			GlobalEndHeldenianMode();
		}
	}
}

int CGame::iGetDangerValue(int iNpcH, short dX, short dY)
{
 int ix, iy, iDangerValue;
 short sOwner, sDOType;
 char  cOwnerType;
 DWORD dwRegisterTime;

	if (m_pNpcList[iNpcH] == 0) return false;

	iDangerValue = 0;

	for (ix = dX - 2; ix <= dX + 2; ix++)
	for (iy = dY - 2; iy <= dY + 2; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);	
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bGetDynamicObject( ix, iy, &sDOType, &dwRegisterTime );
		
		if (sDOType == 1) iDangerValue++;

		switch (cOwnerType) {
		case 0:
			break;
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwner] == 0) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwner] == 0) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pNpcList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		}
	}

	return iDangerValue;
}

void CGame::NpcBehavior_Flee(int iNpcH)
{
 char cDir;
 short sX, sY, dX, dY;
 short sTarget;
 char  cTargetType;

	if (m_pNpcList[iNpcH] == 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled ) return;

	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
	case DEF_ATTACKAI_EXCHANGEATTACK:
	case DEF_ATTACKAI_TWOBYONEATTACK:
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 2) {
			m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			return;
		}
		break;
	
	default:
		if (iDice(1,2) == 1) NpcRequestAssistance(iNpcH);
		break;
	}

	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 10) {
		// 10
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
		m_pNpcList[iNpcH]->m_tmp_iError         = 0;
		if (m_pNpcList[iNpcH]->m_iHP <= 3) {
			m_pNpcList[iNpcH]->m_iHP += iDice(1, m_pNpcList[iNpcH]->m_iHitDice); // !     Ƿ  .
			if (m_pNpcList[iNpcH]->m_iHP <= 0) m_pNpcList[iNpcH]->m_iHP = 1;
		}
		return;
	}

	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != 0) {
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
	}

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	case DEF_OWNERTYPE_NPC:
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}
	dX = sX - (dX - sX);
	dY = sY - (dY - sY);

	cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
	if (cDir == 0) {
	}
	else {
		dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
		dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
		m_pNpcList[iNpcH]->m_sX   = dX;
		m_pNpcList[iNpcH]->m_sY   = dY;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
	}
}

void CGame::MsgProcess()
{
 char   * pData, cFrom, cKey;
 DWORD    dwMsgSize, * dwpMsgID;
 WORD   * wpMsgType, * wp;
 int      i, iClientH;
 char   m_msgBuff[1000];
 DWORD dwTime = timeGetTime();
	
	if ((m_bF5pressed ) && (m_bF1pressed )) {
		PutLogList("(XXX) RELOADING CONFIGS MANUALY...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
					g_login->LocalSavePlayerData(i); //bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
				}
				bInit();
		}

	if ((m_bF1pressed ) && (m_bF4pressed ) && (m_bOnExitProcess == false)) {
		m_cShutDownCode      = 2;
		m_bOnExitProcess     = true;
		m_dwExitProcessTime  = timeGetTime();
		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		//bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, 0);
		
		
		return;
	}
	
	ZeroMemory(m_pMsgBuffer, DEF_MSGBUFFERSIZE+1);
	pData = (char *)m_pMsgBuffer;

	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey) ) {
		
		//v1.31
		m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

		switch (cFrom) {
		//case DEF_MSGFROM_GATESERVER:
		//	dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
		//	wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

		//	switch (*dwpMsgID) {
		//	// New 07/05/2004
		//	case MSGID_PARTYOPERATION:
		//		PartyOperationResultHandler(pData);
		//		break;

		//	case MSGID_SERVERSTOCKMSG:
		//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_SERVERSTOCKMSG");
		//		ServerStockMsgHandler(pData);
		//		break;
		//							
		//	case MSGID_SENDSERVERSHUTDOWNMSG:
		//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_SENDSERVERSHUTDOWNMSG");
		//		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
		//		switch (*wp) {
		//		case 1:
		//			PutLogList("(!) Send server shutdown announcement - 1.");
		//			for (i = 1; i < DEF_MAXCLIENTS; i++)
		//			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
		//				SendNotifyMsg(0, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, 0, 0, 0);
		//			}
		//			break;
		//		
		//		case 2:
		//			PutLogList("(!) Send server shutdown announcement - 2.");
		//			for (i = 1; i < DEF_MAXCLIENTS; i++)
		//			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
		//				SendNotifyMsg(0, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, 0, 0, 0);
		//			}
		//			break;
		//		}

		//		// WLS
		//		bSendMsgToLS(MSGID_SENDSERVERSHUTDOWNMSG, 0, 0); 
		//		break;
		//	
		//	case MSGID_GAMESERVERSHUTDOWNED:
		//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_GAMESERVERSHUTDOWNED");
		//		m_cShutDownCode      = 1;
		//		m_bOnExitProcess     = true;
		//		m_dwExitProcessTime  = timeGetTime();
		//		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Global command)!!!");
		//		bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, 0);
		//		
		//		break;
		//	
		//	case MSGID_TOTALGAMESERVERCLIENTS:
		//		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
		//		m_iTotalGameServerClients = (int)*wp;
		//		if (m_iTotalGameServerClients > m_iTotalGameServerMaxClients) 
		//			m_iTotalGameServerMaxClients = m_iTotalGameServerClients;
		//		break;
		//	
		//	case MSGID_RESPONSE_REGISTERGAMESERVER:
		//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER");
		//		switch (*wpMsgType) {
		//		case DEF_MSGTYPE_CONFIRM:
		//			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_CONFIRM");
		//			PutLogList("(!) Game Server registration to Gate Server - Success!");
		//			m_bIsGateSockAvailable = true;
		//			//50Cent - HG start process fix
		//			bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, 0);
		//			break;

		//		case DEF_MSGTYPE_REJECT:
		//			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_REJECT");
		//			PutLogList("(!) Game Server registration to Gate Server - Fail!");
		//			PutLogList(" ");
		//			PutLogList("(!!!) STOPPED!");
		//			break;
		//		}
		//		
		//		//wsprintf(G_cTxt, "%d %d %d %d %d %d %d", (int)m_bIsGameStarted, (int)m_bIsItemAvailable, m_bIsNpcAvailable, (int)m_bIsGateSockAvailable, (int)m_bIsLogSockAvailable, (int)m_bIsMagicAvailable, (int)m_bIsSkillAvailable);
		//		//PutLogList(G_cTxt);

		//		/*
		//		if ((m_bIsGameStarted == false) && (m_bIsItemAvailable ) && 
		//			(m_bIsNpcAvailable ) && (m_bIsGateSockAvailable ) &&
		//			(m_bIsLogSockAvailable ) && (m_bIsMagicAvailable ) &&
		//			(m_bIsSkillAvailable ) && (m_bIsPortionAvailable ) &&
		//			(m_bIsQuestAvailable ) ) {
		//			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, 0, 0); 
		//			m_bIsGameStarted = true;
		//		}
		//		*/
		//		break;
		//	}
		//	break;
		
		case DEF_MSGFROM_CLIENT:
			/*m_pClientList[iClientH]->m_cConnectionCheck++;
			if (m_pClientList[iClientH]->m_cConnectionCheck > 3) {
				wsprintf(G_cTxt, "Client Hex Edit: (%s) Player: (%s) - has removed 3203203 (check connection handler).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true);
				break;
			}*/

			dwpMsgID = (DWORD *)(pData + DEF_INDEX4_MSGID);
			switch (*dwpMsgID) { // 84148741
						
			case DEF_REQUEST_ANGEL: // Angels by Snoopy...
				GetAngelHandler(iClientH, pData, dwMsgSize);
				break;

			case DEF_REQUEST_RESURRECTPLAYER_YES:
				RequestResurrectPlayer(iClientH, true);
				break;

			case DEF_REQUEST_RESURRECTPLAYER_NO:
				RequestResurrectPlayer(iClientH, false);
				break;

			case MSGID_REQUEST_SELLITEMLIST:
				RequestSellItemListHandler(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RESTART:
				RequestRestartHandler(iClientH);
				break;

			case MSGID_REQUEST_PANNING:
				iRequestPanningMapDataRequest(iClientH, pData);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				//RequestNoticementHandler(iClientH, pData);
				break;
			
			case MSGID_BWM_COMMAND_SHUTUP:
				_BWM_Command_Shutup(pData);
				break;
			
			case MSGID_BWM_INIT:
				_BWM_Init(iClientH, pData);
				break;
			
			case MSGID_REQUEST_SETITEMPOS:
				_SetItemPos(iClientH, pData);
				break;
			
			case MSGID_ADMINUSER:
				RequestAdminUserMode(iClientH, pData);
				break;
			
			case MSGID_REQUEST_FULLOBJECTDATA:
				RequestFullObjectData(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RETRIEVEITEM:
				RequestRetrieveItemHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				RequestCivilRightHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_TELEPORT:
				RequestTeleportHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_INITPLAYER:
				RequestInitPlayerHandler(iClientH, pData, cKey);
				break;

			case MSGID_REQUEST_INITDATA:
				// Anti Bump 
				if (m_pClientList[iClientH]->m_bIsClientConnected ) {
					if (m_pClientList[iClientH] == 0) break;
					wsprintf(G_cTxt, "(!!!) Client (%s) connection closed!. Sniffer suspect!.", m_pClientList[iClientH]->m_cCharName);
					PutLogList(G_cTxt);
					/*ZeroMemory(cData, sizeof(cData));
					cp = (char*)cData;
					*cp = GSM_DISCONNECT;
					cp++;
					memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
					cp += 10;
					bStockMsgToGateServer(cData, 11);*/
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
					bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, 0);
					g_login->LocalSavePlayerData(iClientH); //bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, false);
					if ((dwTime - m_dwGameTime2) > 3000) { // 3 segs
						m_pClientList[iClientH]->m_bIsClientConnected = false;
						DeleteClient(iClientH, true, true, true, true);
					}
					break;
				}
				else {
					m_pClientList[iClientH]->m_bIsClientConnected = true;
					RequestInitDataHandler(iClientH, pData, cKey);
				}
				break;

			case MSGID_COMMAND_COMMON:
				ClientCommonHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_MOTION:
				ClientMotionHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_CHECKCONNECTION:
				CheckConnectionHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_CHATMSG:
				ChatMsgHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_CREATENEWGUILD:
				RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_DISBANDGUILD:
				RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				FightzoneReserveHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_LEVELUPSETTINGS:
				LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_STATECHANGEPOINT:
				StateChangeHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_HELDENIANTELEPORT:
				RequestHeldenianTeleport(iClientH, pData, dwMsgSize);
				break;


			case MSGID_REQUEST_CITYHALLTELEPORT:
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden",7) == 0 ) {
					  RequestTeleportHandler(iClientH, "2   ", "dglv2", 263, 258);
				}
				else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine",6) == 0 ) {
				  RequestTeleportHandler(iClientH, "2   ", "dglv2", 209, 258);
				}
			break;

			default:
				if (m_pClientList[iClientH] != 0)  // Snoopy: Anti-crash check !
				{
					wsprintf(G_cTxt, "Unknown message received: (0x%.8X) PC(%s) - (Delayed). \tIP(%s)"
						, *dwpMsgID
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					//DelayedDeleteClient(iClientH, true, true, true, true);
				}
				else
				{
					wsprintf(G_cTxt, "Unknown message received: (0x%.8X) PC(unknown).", *dwpMsgID);
				}
				PutLogList(G_cTxt);
				PutHackLogFileList(G_cTxt);
				PutHackLogFileList(m_pMsgBuffer);
				break;
			}	
			break;

		case DEF_MSGFROM_LOGSERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			//wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			//case MSGID_REQUEST_CHECKACCOUNTPASSWORD:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_REQUEST_CHECKACCOUNTPASSWORD");
			//	RequestCheckAccountPasswordHandler(pData, dwMsgSize);
			//	break;
			//
			//case MSGID_REQUEST_FORCEDISCONECTACCOUNT:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_REQUEST_FORCEDISCONECTACCOUNT");
			//	wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
			//	ForceDisconnectAccount((char *)(pData + DEF_INDEX2_MSGTYPE + 2), *wpMsgType);
			//	break;
			//
			//case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_SAVEPLAYERDATA_REPLY");
			//	ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
			//	break;
			//
			//case MSGID_GUILDNOTIFY:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_GUILDNOTIFY");
			//	GuildNotifyHandler(pData, dwMsgSize);
			//	break;
			//
			//case MSGID_RESPONSE_DISBANDGUILD:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_DISBANDGUILD");
			//	ResponseDisbandGuildHandler(pData, dwMsgSize);
			//	break;

			//case MSGID_RESPONSE_CREATENEWGUILD:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_CREATENEWGUILD");
			//	ResponseCreateNewGuildHandler(pData, dwMsgSize);
			//	break;
			//
			//case MSGID_RESPONSE_REGISTERGAMESERVER:
			//	switch (*wpMsgType) {
			//	case DEF_MSGTYPE_CONFIRM:
			//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_CONFIRM");
			//		PutLogList("(!) Game Server registration to Log Server - Success!");
			//		m_bIsLogSockAvailable = true;
			//		break;

			//	case DEF_MSGTYPE_REJECT:
			//		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_REJECT");
			//		PutLogList("(!) Game Server registration to Log Server - Fail!");
			//		break;
			//	}
		
			//	if (m_bIsBuildItemAvailable == false) {
			//		PutLogList(" ");
			//		PutLogList("(!!!) STOPPED! Build-Item configuration error.");
			//	}
			//					
			//	if (m_bIsItemAvailable == false) {
			//		PutLogList(" ");
			//		PutLogList("(!!!) STOPPED! Item configuration error.");
			//	}
			//	
			//	if (m_bIsNpcAvailable == false) {
			//		PutLogList(" ");
			//		PutLogList("(!!!) STOPPED! Npc configuration error.");
			//	}

			//	if (m_bIsMagicAvailable == false) {
			//		PutLogList(" ");
			//		PutLogList("(!!!) STOPPED! MAGIC configuration error.");
			//	}

			//	if (m_bIsSkillAvailable == false) {
			//		PutLogList(" ");
			//		PutLogList("(!!!) STOPPED! SKILL configuration error.");
			//	}

			//	if (m_bIsQuestAvailable == false) {
			//		PutLogList(" ");
			//		PutLogList("(!!!) STOPPED! QUEST configuration error.");
			//	}

			//	if (m_bIsPortionAvailable == false) {
			//		PutLogList(" ");
			//		PutLogList("(!!!) STOPPED! PORTION configuration error.");
			//	}

			//	//wsprintf(G_cTxt, "%d %d %d %d %d %d %d", (int)m_bIsGameStarted, (int)m_bIsItemAvailable, m_bIsNpcAvailable, (int)m_bIsGateSockAvailable, (int)m_bIsLogSockAvailable, (int)m_bIsMagicAvailable, (int)m_bIsSkillAvailable);
			//	//PutLogList(G_cTxt);

			//	/*
			//	if ((m_bIsGameStarted == false) && (m_bIsItemAvailable ) && 
			//		(m_bIsNpcAvailable ) && (m_bIsGateSockAvailable ) &&
			//		(m_bIsLogSockAvailable ) && (m_bIsMagicAvailable ) &&
			//		(m_bIsSkillAvailable ) && (m_bIsPortionAvailable ) &&
			//		(m_bIsQuestAvailable ) ) {
			//		SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, 0, 0); 
			//		m_bIsGameStarted = true;
			//	}
			//	*/
			//	break;

			//case MSGID_RESPONSE_PLAYERDATA:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_PLAYERDATA");
			//	ResponsePlayerDataHandler(pData, dwMsgSize);
			//	break;

			//case MSGID_BUILDITEMCONFIGURATIONCONTENTS:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_BUILDITEMCONFIGURATIONCONTENTS");
			//	// Build Item contents
			//	PutLogList("(!) BUILD-ITEM configuration contents received. Now decoding...");
			//	m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			//	break;
			//
			//case MSGID_ITEMCONFIGURATIONCONTENTS:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_ITEMCONFIGURATIONCONTENTS");
			//	PutLogList("(!) ITEM configuration contents received. Now decoding...");
			//	m_bIsItemAvailable = _bDecodeItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			//	break;

			//case MSGID_NPCCONFIGURATIONCONTENTS:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_NPCCONFIGURATIONCONTENTS");
			//	PutLogList("(!) NPC configuration contents received. Now decoding...");
			//	m_bIsNpcAvailable = _bDecodeNpcConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			//	break;
			//
			//case MSGID_MAGICCONFIGURATIONCONTENTS:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_MAGICCONFIGURATIONCONTENTS");
			//	PutLogList("(!) MAGIC configuration contents received. Now decoding...");
			//	m_bIsMagicAvailable = _bDecodeMagicConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			//	break;

			//case MSGID_SKILLCONFIGURATIONCONTENTS:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_SKILLCONFIGURATIONCONTENTS");
			//	PutLogList("(!) SKILL configuration contents received. Now decoding...");
			//	m_bIsSkillAvailable = _bDecodeSkillConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			//	break;

			//case MSGID_QUESTCONFIGURATIONCONTENTS:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_QUESTCONFIGURATIONCONTENTS");
			//	PutLogList("(!) QUEST configuration contents received. Now decoding...");
			//	m_bIsQuestAvailable = _bDecodeQuestConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			//	break;

			//case MSGID_PORTIONCONFIGURATIONCONTENTS:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_PORTIONCONFIGURATIONCONTENTS");
			//	PutLogList("(!) PORTION configuration contents received. Now decoding...");
			//	m_bIsPortionAvailable = _bDecodePortionConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			//	break;

			//// Crusade
			////case MSGID_ARESDENOCCUPYFLAGSAVEFILECONTENTS:
			//	//PutLogList("(!) Aresden OccupyFlag save file contents received. Now decoding...");
			//	//_bDecodeOccupyFlagSaveFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize, 1);
			//	//break;

			//// Crusade
			////case MSGID_ELVINEOCCUPYFLAGSAVEFILECONTENTS:
			//	//PutLogList("(!) Elvine OccupyFlag save file contents received. Now decoding...");
			//	//_bDecodeOccupyFlagSaveFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize, 2);
			//	//break;

			//case MSGID_DUPITEMIDFILECONTENTS:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_DUPITEMIDFILECONTENTS");
			//	PutLogList("(!) DupItemID file contents received. Now decoding...");
			//	_bDecodeDupItemIDFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			//	break;

			//case MSGID_NOTICEMENTFILECONTENTS:
			//	//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_NOTICEMENTFILECONTENTS");
			//	PutLogList("(!) Noticement file contents received. Now decoding...");
			//	_bDecodeNoticementFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			//	break;

			//// v2.17 2002-8-7 // 2002-09-06 #1
			///*case MSGID_NPCITEMCONFIGCONTENTS:
			//	PutLogList("(!) NpcItemConfig file contents received. Now decoding...");
			//	_bDecodeNpcItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			//	break;*/

			case MSGID_REQUEST_CREATENEWACCOUNT:
				g_login->CreateNewAccount(iClientH, pData);
				break;
			case MSGID_REQUEST_LOGIN:
				g_login->RequestLogin(iClientH, pData);
				break;
			case MSGID_REQUEST_CREATENEWCHARACTER: //message from client
				g_login->ResponseCharacter(iClientH, pData);
				break;
			case MSGID_REQUEST_DELETECHARACTER:
				g_login->DeleteCharacter(iClientH, pData);
				break;
			case MSGID_REQUEST_CHANGEPASSWORD:
				g_login->ChangePassword(iClientH, pData);
				break;
			case MSGID_REQUEST_ENTERGAME:
				g_login->RequestEnterGame(iClientH, pData);
				break;
			default:
				wsprintf(G_cTxt, "Unknown login message received! (0x%.8X) Delete Client", *dwpMsgID);
				PutLogList(G_cTxt);
				break;
			}
			DeleteLoginClient(iClientH);
			break;
		}
	}

}


bool CGame::bPutMsgQuene(char cFrom, char * pData, DWORD dwMsgSize, int iIndex, char cKey)
{
	/*
	HANDLE hMutex;
	
	hMutex = OpenMutex(MUTEX_ALL_ACCESS, false, m_cServerName);
	if (hMutex != 0) return false; // ¹ÂÅØ½º°¡ »ý¼ºµÇ¾î ÀÖ´Ù. ¾îµð¼±°¡ Å¥¸¦ Á¶ÀÛÁßÀÌ´Ù. ±×³É ¸®ÅÏ 

	hMutex = CreateMutex(0, false, m_cServerName);
	*/
	if (m_pMsgQuene[m_iQueneTail] != 0) return false;

	m_pMsgQuene[m_iQueneTail] = new class CMsg;
	if (m_pMsgQuene[m_iQueneTail] == 0) return false;

	if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey) == false) return false;

	m_iQueneTail++;
	if (m_iQueneTail >= DEF_MSGQUENESIZE) m_iQueneTail = 0;

	//ReleaseMutex(hMutex);

	return true;
}


bool CGame::bGetMsgQuene(char * pFrom, char * pData, DWORD * pMsgSize, int * pIndex, char * pKey)
{
	/*
	HANDLE hMutex;
	
	hMutex = OpenMutex(MUTEX_ALL_ACCESS, false, m_cServerName);
	if (hMutex != 0) return false;

	hMutex = CreateMutex(0, false, m_cServerName);
	*/
	if (m_pMsgQuene[m_iQueneHead] == 0) return false;

	m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey);

	delete m_pMsgQuene[m_iQueneHead];
	m_pMsgQuene[m_iQueneHead] = 0;

	m_iQueneHead++;
	if (m_iQueneHead >= DEF_MSGQUENESIZE) m_iQueneHead = 0;

	//ReleaseMutex(hMutex);

	return true;
}


void CGame::ClientCommonHandler(int iClientH, char * pData)
{
 WORD * wp, wCommand;
 short * sp, sX, sY; 
 int   * ip, iV1, iV2, iV3, iV4;
 char  * cp, cDir, * pString;
	
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled ) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;
 
	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;

	pString = cp;
	cp += 30;
	
	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;
	
	switch (wCommand) {

	//50Cent - Repair All
	case DEF_COMMONTYPE_REQ_REPAIRALL:
		RequestRepairAllItemsHandler(iClientH);
		break;
	case DEF_COMMONTYPE_REQ_REPAIRALLDELETE:
		RequestRepairAllItemsDeleteHandler(iClientH, iV1);
		break;
	case DEF_COMMONTYPE_REQ_REPAIRALLCONFIRM:
		RequestRepairAllItemsConfirmHandler(iClientH);
		break;

	case DEF_COMMONTYPE_UPGRADEENCHANT:
		RequestEnchantUpgradeHandler(iClientH, iV1, iV2, iV3);
		break;
	case DEF_COMMONTYPE_ENCHANTITEM:
		RequestItemEnchantHandler(iClientH, iV1, iV2);
		break;
	case DEF_COMMONTYPE_DISENCHANTITEM:
		RequestItemDisenchantHandler(iClientH, iV1);
		break;

	// Crafting
	case DEF_COMMONTYPE_CRAFTITEM:
		ReqCreateCraftingHandler(iClientH, pData);
		break;

	// New 15/05/2004
	case DEF_COMMONTYPE_REQ_CREATESLATE:
		ReqCreateSlateHandler(iClientH, pData);
		break;

// 2.06 - by KLKS
	case DEF_COMMONTYPE_REQ_CHANGEPLAYMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> MSGID_REQUEST_CIVILRIGHT");
		RequestChangePlayMode(iClientH);
		break;
//

	case DEF_COMMONTYPE_SETGUILDTELEPORTLOC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDTELEPORTLOC");
		RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, "middleland");
		break;

	case DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC");
		RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;
	
	case DEF_COMMONTYPE_GUILDTELEPORT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GUILDTELEPORT");
		RequestGuildTeleportHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_SUMMONWARUNIT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SUMMONWARUNIT");
		RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQUEST_HELP:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_HELP");
		RequestHelpHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_MAPSTATUS:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_MAPSTATUS");
		MapStatusHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY");
		SelectCrusadeDutyHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQUEST_CANCELQUEST:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_CANCELQUEST");
		CancelQuestHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY");
		ActivateSpecialAbilityHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_JOINPARTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_JOINPARTY");
		JoinPartyHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_GETMAGICABILITY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GETMAGICABILITY");
		GetMagicAbilityHandler(iClientH);
		break;

	case DEF_COMMONTYPE_BUILDITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_BUILDITEM");
		BuildItemHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_QUESTACCEPTED:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_QUESTACCEPTED");
		QuestAcceptedHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_CANCELEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CANCELEXCHANGEITEM");
		CancelExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_CONFIRMEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CONFIRMEXCHANGEITEM");
		ConfirmExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_SETEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETEXCHANGEITEM");
		SetExchangeItem(iClientH, iV1, iV2);
		break;
	
	case DEF_COMMONTYPE_REQ_GETHEROMANTLE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETHEROMANTLE");
		GetHeroMantleHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_GETOCCUPYFLAG:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFLAG");
		GetOccupyFlagHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX");
		SetDownSkillIndexHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_TALKTONPC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TALKTONPC");
		// works for client, but for npc it returns middleland
		// if ((m_pMapList[m_pNpcList[iV1]->m_cMapIndex]->m_cName) != (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) break;
		NpcTalkHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQ_CREATEPORTION:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_CREATEPORTION");
		ReqCreatePortionHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_REQ_GETFISHTHISTIME:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETFISHTHISTIME");
		ReqGetFishThisTimeHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM");
		ReqRepairItemCofirmHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEM");
		ReqRepairItemHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEMCONFIRM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEMCONFIRM");
		ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEM");
		ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_USESKILL:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USESKILL");
		UseSkillHandler(iClientH, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQ_USEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USEITEM");
		UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
		break;
	
	case DEF_COMMONTYPE_REQ_GETREWARDMONEY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETREWARDMONEY");
		GetRewardMoneyHandler(iClientH);
		break;

	case DEF_COMMONTYPE_ITEMDROP:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_ITEMDROP");
		DropItemHandler(iClientH, iV1, iV2, pString, true);
		break;
	
	case DEF_COMMONTYPE_EQUIPITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EQUIPITEM");
		// ¿©±â¼­´Â Æ¯¼ºÄ¡ º¯È­¸¸À» ´Ù·é´Ù.
		bEquipItemHandler(iClientH, iV1);
		// ¹Ù²ï ¿ÜÇü¿¡ ´ëÇÑ Á¤º¸¸¦ ¿©±â¼­ Àü¼ÛÇÑ´Ù.
		// .....
		break;

	case DEF_COMMONTYPE_REQ_PURCHASEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_PURCHASEITEM");
		RequestPurchaseItemHandler(iClientH, pString, iV1);
		break;

	case DEF_COMMONTYPE_REQ_STUDYMAGIC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_STUDYMAGIC");
		RequestStudyMagicHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_REQ_TRAINSKILL:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_TRAINSKILL");
		//RequestTrainSkillHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_GIVEITEMTOCHAR:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GIVEITEMTOCHAR");
		GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_EXCHANGEITEMTOCHAR:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EXCHANGEITEMTOCHAR");
		ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDAPPROVE");
		JoinGuildApproveHandler(iClientH, pString);
		break;
	
	case DEF_COMMONTYPE_JOINGUILDREJECT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDREJECT");
		JoinGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDAPPROVE");
		DismissGuildApproveHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDREJECT");
		DismissGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_RELEASEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_RELEASEITEM");
		ReleaseItemHandler(iClientH, iV1, true);
		break;

	case DEF_COMMONTYPE_TOGGLECOMBATMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLECOMBATMODE");
		ToggleCombatModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_MAGIC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_MAGIC");
		PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100));
		break;

	case DEF_COMMONTYPE_TOGGLESAFEATTACKMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLESAFEATTACKMODE");
		ToggleSafeAttackModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET");
		GetFightzoneTicketHandler(iClientH);
		break;

	// Upgrade Item
	case DEF_COMMONTYPE_UPGRADEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_UPGRADEITEM");
		RequestItemUpgradeHandler(iClientH,iV1);
		break;

	case DEF_COMMONTYPE_REQGUILDNAME:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQGUILDNAME");
		RequestGuildNameHandler(iClientH, iV1, iV2);
			break;

	case DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY");
		RequestAcceptJoinPartyHandler(iClientH, iV1);
		break;

	//50Cent - HP Bar
	case DEF_COMMONTYPE_REQ_GETNPCHP:
		if ((iV1 - 10000 <= 0) || (iV1 - 10000 >= DEF_MAXNPCS)) return;
		if (m_pNpcList[iV1 - 10000] == 0) return;
		if (m_pNpcList[iV1 - 10000]->m_iHP > m_pNpcList[iV1 - 10000]->m_iMaxHP) m_pNpcList[iV1 - 10000]->m_iMaxHP = m_pNpcList[iV1 - 10000]->m_iHP;
		SendNotifyMsg(0, iClientH, DEF_SEND_NPCHP, m_pNpcList[iV1 - 10000]->m_iHP, m_pNpcList[iV1 - 10000]->m_iMaxHP, 0, 0);
		break;

	default:
		wsprintf(G_cTxt,"Unknown message received! (0x%.8X)",wCommand);
		PutLogList(G_cTxt);
		break;
	}
}

// New 07/05/2004
void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, char * pItemName, bool bByPlayer)
{
	class CItem * pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange ) return;
	if ((m_bAdminSecurity ) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if ((iAmount != -1) && (iAmount < 0)) return;

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		(iAmount == -1) ) 
		iAmount = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;


	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) return;

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		(((int)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount - iAmount) > 0) ) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == false) {
				delete pItem;
				return;
			}
			else {
				if (iAmount <= 0) {
					delete pItem;
					return;
				}
				pItem->m_dwCount = (DWORD)iAmount;
			}

			if ((DWORD)iAmount > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount) {
				delete pItem;
				return;
			}

			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

			// v1.41 !!!
			SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, pItem);

			// v1.411 
			// v2.17 2002-7-31
			if ( bByPlayer  )
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
			else 
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem, true);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, 0, 0);
		}
	else {

		ReleaseItemHandler(iClientH, sItemIndex, true);

		// v2.17
		if ( m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] )
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);

		// v1.432
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) && 
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)) {
				delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
				m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;
			}
		else {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			// v1.41
			// v2.17 2002-7-31
			if ( bByPlayer  )
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			else 
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex], true);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum, 
				0, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); //v1.4 color
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, 0, 0);

		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	iCalcTotalWeight(iClientH);
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: check if player is dropping item or picking up item
//  last updated		:: October 29, 2004; 7:12 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp, sRemainItemSprite, sRemainItemSpriteFrame;
 char  cRemainItemColor, cData[100];
 int   iRet, iEraseReq;
 class CItem * pItem;

	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled ) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	short sIDNum;
	DWORD dwAttribute;
	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sIDNum, &cRemainItemColor, &dwAttribute);
	if (pItem != 0) {
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {

			_bItemLog(DEF_ITEMLOG_GET, iClientH, 0, pItem);

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;
			
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0;
			cp++;

			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;
			 
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

			*cp = (char)pItem->m_sItemSpecEffectValue2;
			cp++;
			
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			if (iEraseReq == 1) delete pItem;

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				                        sIDNum, 0, cRemainItemColor, dwAttribute);

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);						
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return 0;
			}
		}
		else 
		{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);
			
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return 0;
			}
		}
	}

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

bool CGame::_bAddClientItemList(int iClientH, class CItem * pItem, int * pDelReq)
{
 int i;

	if (m_pClientList[iClientH] == 0) return false;
	if (pItem == 0) return false;
	
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return false;
	}
	else {
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return false;
  	}
	
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pClientList[iClientH]->m_pItemList[i] != 0) && 
			 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0) ) {
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
			//delete pItem;
			*pDelReq = 1;
			
			iCalcTotalWeight(iClientH);
			
			return true;
		}
	}
	
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == 0) {
		
		m_pClientList[iClientH]->m_pItemList[i] = pItem;
		m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
		m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

		*pDelReq = 0;

		if (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)
			m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

		iCalcTotalWeight(iClientH);
		
		return true;
	}

	return false;
}

bool CGame::bEquipItemHandler(int iClientH, short sItemIndex, bool bNotify)
{
	char  cEquipPos, cHeroArmorType;
	short   sSpeed;
	short sTemp;
	int iTemp;

	if (m_pClientList[iClientH] == 0) return false;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return false;

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return false;

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == 0)  &&
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) return false;


	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
		case 1:
		case 2:
		case 3:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return false;
			break;
		case 4:
		case 5:
		case 6:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return false;
			break;
		}
	}

	if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > (m_pClientList[iClientH]->m_iStr+ m_pClientList[iClientH]->m_iAngelicStr)*100) return false;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

	if ((cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_LEGGINGS) ||
		(cEquipPos == DEF_EQUIPPOS_ARMS) || (cEquipPos == DEF_EQUIPPOS_HEAD)) {
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
				case 10: // Str
					if ((m_pClientList[iClientH]->m_iStr+ m_pClientList[iClientH]->m_iAngelicStr) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
						return false;
					}
					break;
				case 11: // Dex
					if ((m_pClientList[iClientH]->m_iDex+ m_pClientList[iClientH]->m_iAngelicDex) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
						return false;
					}
					break;
				case 12: // Vit
					if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
						return false;
					}
					break;
				case 13: // Int
					if ((m_pClientList[iClientH]->m_iInt+ m_pClientList[iClientH]->m_iAngelicInt) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
						return false;
					}
					break;
				case 14: // Mag
					if ((m_pClientList[iClientH]->m_iMag+ m_pClientList[iClientH]->m_iAngelicMag) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
						return false;
					}
					break;
				case 15: // Chr
					if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
						return false;
					}
					break;
			}
		}

		if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
			// Stormbringer
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
				if((m_pClientList[iClientH]->m_iInt+ m_pClientList[iClientH]->m_iAngelicInt) < 65){
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, 0, 0);
					ReleaseItemHandler(iClientH, sItemIndex , true);
					return false;
				}
			}
		}

		if (cEquipPos == DEF_EQUIPPOS_RHAND) {
			// Resurrection wand(MS.10) or Resurrection wand(MS.20)
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
				if((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 99 && (m_pClientList[iClientH]->m_iMag+ m_pClientList[iClientH]->m_iAngelicMag) > 99 &&  m_pClientList[iClientH]->m_iSpecialAbilityTime < 1){
					m_pClientList[iClientH]->m_cMagicMastery[94] = true;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
				}
			}
		}

		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) || 
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) {

				if ((m_pClientList[iClientH]->m_iSpecialAbilityType != 0)) {
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], 0, 0);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], true);
					}
				}
			}


		if (cEquipPos == DEF_EQUIPPOS_NONE) return false;

		if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], false);
			else {
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ], false);
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ], false);
			}
		}
		else {
			if ((cEquipPos == DEF_EQUIPPOS_LHAND) || (cEquipPos == DEF_EQUIPPOS_RHAND)) {
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ], false);
			}

			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], false);
		}


		if (cEquipPos == DEF_EQUIPPOS_RELEASEALL) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) {
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], false);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ], false);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ], false);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ], false);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ], false);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ], false);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ], false);
			}
		}
		else{
			if (cEquipPos == DEF_EQUIPPOS_HEAD || cEquipPos == DEF_EQUIPPOS_BODY || cEquipPos == DEF_EQUIPPOS_ARMS ||
				cEquipPos == DEF_EQUIPPOS_LEGGINGS || cEquipPos == DEF_EQUIPPOS_PANTS || cEquipPos == DEF_EQUIPPOS_BACK) {
					if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RELEASEALL ] != -1) {
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RELEASEALL ], false);
					}
			}
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], false);
		}


		m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = true;

		switch (cEquipPos) {

			case DEF_EQUIPPOS_HEAD:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xFF0F;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFFFFF0;			
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor));
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_PANTS:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xF0FF;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFFF0FF;
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_LEGGINGS:
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0x0FFF;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr °ªÀ» ¼¼ÆÃ. 
				m_pClientList[iClientH]->m_sAppr4 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; 
				iTemp = iTemp & 0xFFFFFF0F; 
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_BODY:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0x0FFF;	

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) {
					sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr °ªÀ» ¼¼ÆÃ. 
					m_pClientList[iClientH]->m_sAppr3 = sTemp;
				}
				else {
					sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12); // Appr °ªÀ» ¼¼ÆÃ. 
					m_pClientList[iClientH]->m_sAppr3 = sTemp;
					sTemp = m_pClientList[iClientH]->m_sAppr4;
					sTemp = sTemp | 0x080;	
					m_pClientList[iClientH]->m_sAppr4 = sTemp;
				}

				iTemp = m_pClientList[iClientH]->m_iApprColor; 
				iTemp = iTemp & 0xFF0FFFFF;
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;
			
			case DEF_EQUIPPOS_ARMS:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xFFF0;	
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr °ªÀ» ¼¼ÆÃ. 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFFFFFF; // New 09/05/2004
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_LHAND:
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xFFF0;	
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr °ªÀ» ¼¼ÆÃ. 
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; 
				iTemp = iTemp & 0xF0FFFFFF; 
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_RHAND:
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xF00F;	
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr °ªÀ» ¼¼ÆÃ. 
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; 
				iTemp = iTemp & 0xFFFFFFF; 
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				iTemp = m_pClientList[iClientH]->m_iStatus;
				iTemp = iTemp & 0xFFFFFFF0;
				sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
				sSpeed -= ((m_pClientList[iClientH]->m_iStr+ m_pClientList[iClientH]->m_iAngelicStr) / 13);
				if (sSpeed < 0) sSpeed = 0;
				iTemp = iTemp | (int)sSpeed;
				m_pClientList[iClientH]->m_iStatus = iTemp;
				m_pClientList[iClientH]->m_iComboAttackCount = 0;
				break;

			case DEF_EQUIPPOS_TWOHAND:
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xF00F;	
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr °ªÀ» ¼¼ÆÃ. 
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFFFFF; 
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				iTemp = m_pClientList[iClientH]->m_iStatus;
				iTemp = iTemp & 0xFFFFFFF0;
				sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
				sSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
				if (sSpeed < 0) sSpeed = 0;
				iTemp = iTemp | (int)sSpeed;
				m_pClientList[iClientH]->m_iStatus = iTemp;
				m_pClientList[iClientH]->m_iComboAttackCount = 0;
				break;

			case DEF_EQUIPPOS_BACK:
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0xF0FF;	
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr °ªÀ» ¼¼ÆÃ. 
				m_pClientList[iClientH]->m_sAppr4 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFF0FFFF;
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_RELEASEALL:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0x0FFF;	
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr °ªÀ» ¼¼ÆÃ. 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFF0FFFF; 
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;
		}

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
				case 0: break;
				case 1: 
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;	
					break;

				case 2: 
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;	
					break;

				case 3: 
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;	
					break;
			}
		}

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
			switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect){
				case 0:
					break;
				case 50:
				case 51:
				case 52:
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;
					break;
				default:
					if(m_pClientList[iClientH]->m_iAdminUserLevel > 0)
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0001;
					// m_sAppr4
					// 0x0001 GM	
					// 0x0002 Green	
					// 0x0003 ice element
					// 0x0004 sparkle
					// 0x0005 sparkle green gm
					// 0x0006 sparkle green
					break;
			}
		}
		
	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = cHeroArmorType;
		
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);
	return true;

}

void CGame::SendEventToNearClient_TypeB(DWORD dwMsgID, WORD wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{
 int i, iRet, iShortCutIndex;
 char  * cp, cData[100];
 DWORD * dwp, dwTime;
 WORD * wp;
 short * sp;
 bool bFlag;

	ZeroMemory(cData, sizeof(cData));
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	sp  = (short *)cp;
	*sp = sX;
	cp += 2;

	sp  = (short *)cp;
	*sp = sY;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV1;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV2;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;

	dwTime = timeGetTime();

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = true;
	iShortCutIndex = 0;
	while (bFlag ) {
		// DEF_MAXCLIENTS 
		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = false;

		if ((bFlag ) && (m_pClientList[i] != 0)) {
			if ( (m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				 (m_pClientList[i]->m_sX >= sX - 12) &&
				 (m_pClientList[i]->m_sX <= sX + 12) &&
				 (m_pClientList[i]->m_sY >= sY - 10 ) &&
				 (m_pClientList[i]->m_sY <= sY + 10 ) ) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 18);
			}
		}
	}
}

void CGame::SendEventToNearClient_TypeB(DWORD dwMsgID, WORD wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, DWORD dwV4)
{
	int i, iRet, iShortCutIndex;
	char* cp, cData[100];
	DWORD* dwp, dwTime;
	WORD* wp;
	short* sp;
	bool bFlag;

	ZeroMemory(cData, sizeof(cData));

	dwp = (DWORD*)(cData + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp = (WORD*)(cData + DEF_INDEX2_MSGTYPE);
	*wp = wMsgType;

	cp = (char*)(cData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short*)cp;
	*sp = sX;
	cp += 2;

	sp = (short*)cp;
	*sp = sY;
	cp += 2;

	sp = (short*)cp;
	*sp = sV1;
	cp += 2;

	sp = (short*)cp;
	*sp = sV2;
	cp += 2;

	sp = (short*)cp;
	*sp = sV3;
	cp += 2;

	dwp = (DWORD*)cp;
	*dwp = dwV4;
	cp += 4;

	dwTime = timeGetTime();

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = true;
	iShortCutIndex = 0;
	while (bFlag ) {
		// DEF_MAXCLIENTS 
		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = false;

		if ((bFlag ) && (m_pClientList[i] != 0)) {
			if ((m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				(m_pClientList[i]->m_sX >= sX - 12) &&
				(m_pClientList[i]->m_sX <= sX + 12) &&
				(m_pClientList[i]->m_sY >= sY - 10) &&
				(m_pClientList[i]->m_sY <= sY + 10)) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 20);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is stopped
//  last updated		:: October 29, 2004; 6:46 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{
 char cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 short   sOwnerH;
 char    cOwnerType;
	
	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled ) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;
	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] ) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);		
		if (sOwnerH != 0) {
			DeleteClient(iClientH, true, true);
			return 0;
		}
	}

	ClearSkillUsingStatus(iClientH);

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	m_pClientList[iClientH]->m_cDir = cDir;
	
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char * pData, int iType)
{
 int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	
	// ·Î±× ¼­¹ö·ÎºÎÅÍ ±æµå »ý¼º ¿äÃ»¿¡ ´ëÇÑ ÀÀ´äµ¥ÀÌÅÍ°¡ µµÂøÇß´Ù. 
	ZeroMemory(cCharName, sizeof(cCharName));
	//cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, pData, 10);
	//cp += 10;
	
	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£´Â´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) &&
		(m_pClientList[i]->m_iLevel >= 20) && (m_pClientList[i]->m_iCharisma >= 20)) {
		
		//wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (iType) {
		case 1: // DEF_LOGRESMSGTYPE_CONFIRM
			// Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå »ý¼º ¿ä±¸°¡ ¼º°øÇÏ¿´´Ù. 
			wResult = DEF_MSGTYPE_CONFIRM;
			// ±æµå ÀÌ¸§Àº ÀÌ¹Ì ÀúÀåµÇ¾î ÀÖÀ¸¹Ç·Î ·©Å©¸¦ 0À¸·Î ¹Ù²ã À¯È¿È­ ÇÑ´Ù.
			m_pClientList[i]->m_iGuildRank = 0;	// ±æµå ·©Å©´Â 0. ±æµå¸¶½ºÅÍÀÓ 
			wsprintf(cTxt, "(!) New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;

		case 0: // DEF_LOGRESMSGTYPE_REJECT
			// Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå »ý¼º ¿ä±¸°¡ ½ÇÆÐÇÏ¿´´Ù.
			// ÇØ´ç Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµåÀÌ¸§À» ÃÊ±âÈ­ÇÑ´Ù "NONE".
			wResult = DEF_MSGTYPE_REJECT;
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;  
			m_pClientList[i]->m_iGuildGUID = -1;
			wsprintf(cTxt, "(!) New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CREATENEWGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		// ±æµå »ý¼º ¿ä±¸ ÀÀ´ä ¸Þ½ÃÁö¸¦ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(i, true, true);
			return;
		}

		return;
	}

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À» ¼ö ¾ø´Ù.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestCreateNewGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120], cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_bIsCrusadeMode ) return;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	
	cp += 10;
	cp += 10;
	cp += 10;
	
	ZeroMemory(cGuildName, sizeof(cGuildName));
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// ÀÌ Ä³¸¯ÅÍ´Â ÀÌ¹Ì ±æµå¿¡ °¡ÀÔÇÏ¿© ÀÖÀ¸¹Ç·Î ±æµå¸¦ ¸¸µé ¼ö ¾ø´Ù.
		wsprintf(cTxt, "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		if ( (m_pClientList[iClientH]->m_iLevel < 20) || (m_pClientList[iClientH]->m_iCharisma < 20) ||
			 (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) ||
			 (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) != 0) ) { // v1.4
			// ÀÚ°Ý¿ä°ÇÀÌ ¸ÂÁö ¾Ê´Â´Ù. Æ¯¼ºÄ¡°¡ ³·°Å³ª ¸¶À»ÀÇ À§Ä¡°¡ ´Ù¸£°Å³ª ½Ã¹ÎÀÌ ¾Æ´Ñ °æ¿ì  
			ZeroMemory(cData, sizeof(cData));

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_CREATENEWGUILD;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;

			// ±æµå »ý¼º ¿ä±¸ ÀÀ´ä ¸Þ½ÃÁö¸¦ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, true, true);
				return;
			}
		}
		else {
	   		// ±æµå ÀÌ¸§À» ÀÓ½Ã·Î ÀúÀåÇÑ´Ù. -> ¾îÂ÷ÇÇ ±æµå ÀÌ¸§Àº Rank°¡ -1ÀÏ¶§ ¹«ÀÇ¹ÌÇÏ¹Ç·Î .
			ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);
			// ±æµåÀÇ ¼Ò¼Ó ¸¶À» ÀÌ¸§À» ÀúÀåÇÑ´Ù.
			ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			// ±æµåÀÇ GUID¸¦ »ý¼ºÇÏ¿© ÀÔ·ÂÇÑ´Ù. 
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + timeGetTime());
			
			// ±æµå »ý¼º¿äÃ» ¸Þ½ÃÁö¸¦ ·Î±×¼­¹ö·Î Àü¼ÛÇÑ´Ù.
			//bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);

			char cData[512];
			ZeroMemory(cData, sizeof(cData));
			DWORD* dwp;

			cp = (char*)cData;

			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
			cp += 20;

			memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
			cp += 10;

			dwp = (DWORD*)cp;
			*dwp = (DWORD)m_pClientList[iClientH]->m_iGuildGUID;
			cp += 4;

			RequestCreateNewGuild(iClientH, cData);
		}
	}
}


void CGame::RequestDisbandGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120];

	if (m_bIsCrusadeMode ) return;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cGuildName, sizeof(cGuildName));
	
	cp += 10;
	cp += 10;
	cp += 10;
	
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) {
		// ±æµå¸¶½ºÅÍ°¡ ¾Æ´Ï°Å³ª ±æµåÀÇ ÀÌ¸§ÀÌ ´Ù¸£¹Ç·Î ±æµåÇØ»êÀÇ ±ÇÇÑÀÌ ¾ø´Ù.
		wsprintf(cTxt, "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		// ±æµå ÇØ»ê ¸Þ½ÃÁö¸¦ ·Î±×¼­¹ö·Î Àü¼ÛÇÑ´Ù.
		//bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);

		char cData[512];

		ZeroMemory(cData, sizeof(cData));
		cp = (char*)(cData);

		memcpy((char*)cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		memcpy((char*)cp, m_pClientList[iClientH]->m_cGuildName, 20);
		cp += 20;

		RequestDisbandGuild(iClientH, cData);
	}
}

void CGame::ResponseDisbandGuildHandler(char * pData, int iType)
{
 int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	
	// α κ  ػ û  䵥Ͱ ߴ. 
	ZeroMemory(cCharName, sizeof(cCharName));
	//cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, pData, 10);
	//cp += 10;
	
	// ̸ ġϴ Ŭ̾Ʈ ã´.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		
		//wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (iType) {
		case 1: // DEF_LOGRESMSGTYPE_CONFIRM
			// Ŭ̾Ʈ  ػ 䱸 Ͽ. 
			wResult = DEF_MSGTYPE_CONFIRM;
			wsprintf(cTxt, "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			
			//  鿡 尡 ػǾ ˸ ޽ Ѵ. 
			SendGuildMsg(i,	DEF_NOTIFY_GUILDDISBANDED, 0, 0, 0);
			
			// ̸ Ŭ
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;		//  ũ -1.  ƴϴ. 
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case 0: // DEF_LOGRESMSGTYPE_REJECT
			// Ŭ̾Ʈ  ػ 䱸 Ͽ.
			wResult = DEF_MSGTYPE_REJECT;
			wsprintf(cTxt, "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_DISBANDGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		//  ػ 䱸  ޽ Ŭ̾Ʈ 
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ޽   ߻ߴٸ Ѵ.
			DeleteClient(i, true, true);
			return;
		}
		return;
	}

	// ̸ ġϴ Ŭ̾Ʈ ã  .
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

// 05/29/2004 - Hypnotoad - Purchase Dicount updated to take charisma into consideration
void CGame::RequestPurchaseItemHandler(int iClientH, char * pItemName, int iNum)
{
 class CItem * pItem;
 char  * cp, cItemName[21], cData[100];
 short * sp;
 DWORD * dwp, dwGoldCount, dwItemCount;
 WORD  * wp, wTempPrice;
 int   i, iRet, iEraseReq, iGoldWeight;
	 int   iCost, iDiscountRatio, iDiscountCost;
 double dTmp1, dTmp2, dTmp3;
 
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	// ¸¸¾à ¾ÆÀÌÅÛÀ» ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é ±¸ÀÔÇÒ ¼ö ¾ø´Ù. 
	//if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
	//	 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pClientList[iClientH]->m_cLocation, 10) != 0) ) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) {
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arefarm", 7) == 0)) {

			}
			else return;
		}

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvfarm", 7) == 0)) {

			}
			else return;
		}
	}
	
	
	// ¾ÆÀÌÅÛÀ» ±¸ÀÔÇÑ´Ù. 
	ZeroMemory(cData, sizeof(cData));	
	ZeroMemory(cItemName, sizeof(cItemName));
	
	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	// ÀÓ½ÃÄÚµå´Ù. 
	if (memcmp(pItemName, "10Arrows", 8) == 0) {
		strcpy(cItemName, "Arrow");
		dwItemCount = 10;
	}
	else if (memcmp(pItemName, "100Arrows", 9) == 0) {
		strcpy(cItemName, "Arrow");
		dwItemCount = 100;
	}
	else {
		memcpy(cItemName, pItemName, 20);
		dwItemCount = 1;
	}
	
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == false) {
			delete pItem;
		}
		else {
			
			if (pItem->m_bIsForSale == false) {
				delete pItem;
				return;
			}

			pItem->m_dwCount = dwItemCount;
			
			iCost = pItem->m_wPrice * pItem->m_dwCount;
			

			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			
			iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma -10)/ 4) ;
			
			// 2.03 Discount Method
			// Charisma
			// iDiscountRatio = (m_pClientList[iClientH]->m_iCharisma / 4) -1;
			// if (iDiscountRatio == 0) iDiscountRatio = 1;
			
			dTmp1 = (double)(iDiscountRatio);
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)iCost;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;
				
			if (iDiscountCost >= (iCost/2)) iDiscountCost = (iCost/2)-1;

			if ( dwGoldCount < (DWORD)(iCost - iDiscountCost) ) {
				delete pItem;
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp  = -1; 
				cp++;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}
				return;
			}
			
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// ¾ÆÀÌÅÛ »ò´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMPURCHASED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1°³ È¹µæÇß´Ù.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;
				
				wp  = (WORD *)cp;
				*wp = (iCost - iDiscountCost);
				wTempPrice = (iCost - iDiscountCost);
				cp += 2;
				
				if (iEraseReq == 1) delete pItem;
				
				// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
				
				// GoldÀÇ ¼ö·®À» °¨¼Ò½ÃÅ²´Ù. ¹Ýµå½Ã ¿©±â¼­ ¼¼ÆÃÇØ¾ß ¼ø¼­°¡ ¹Ù²îÁö ¾Ê´Â´Ù.
				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - wTempPrice);
				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);

				//v1.4 ¸¶À»ÀÇ ÀÚ±Ý¿¡ ´õÇÑ´Ù. 
				m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += wTempPrice;
					
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}
			}
			else 
			{
				// °ø°£ÀÌ ºÎÁ·ÇØ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
				delete pItem;

				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}
			}
		}
 	}
}

void CGame::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char * pItemName)
{
 int iRet, iEraseReq;
 short * sp, sOwnerH;
 char  * cp, cOwnerType, cData[100], cCharName[21];
 DWORD * dwp;
 WORD  * wp;
 class CItem * pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange ) return;
	if ((m_bAdminSecurity ) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (iAmount <= 0) return;

	// ¾ÆÀÌÅÛ ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏÁö ¾Ê¾Æµµ ¹«½ÃµÈ´Ù.
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) {
		PutLogList("GiveItemHandler - Not matching Item name");
		return;
	}

	ZeroMemory(cCharName, sizeof(cCharName));

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount > (DWORD)iAmount) ) {
		// ¼Òºñ¼º ¾ÆÀÌÅÛÀÌ¾ú°í ¼ö·®¸¸Å­ °¨¼Ò½ÃÅ°°í ³²Àº °Ô ÀÖ´Ù¸é 
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == false) {
			// ºÐÇÒÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¸®½ºÆ®¿¡ ¾ø´Â °Å´Ù. ÀÌ·± ÀÏÀº ÀÏ¾î³¯ ¼ö°¡ ¾øÁö¸¸ 
			delete pItem;
			return;
		}
		else {
			pItem->m_dwCount = iAmount;
		}

		// ¼ö·® °¨¼Ò: 0º¸´Ù Å©´Ù.
		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

		// º¯°æµÈ ¼ö·®À» ¼³Á¤ÇÏ°í ¾Ë¸°´Ù.
		// v1.41 !!! ¾ÆÀÌÅÛ ÀÌ¸§¿¡¼­ ÀÎµ¦½º·Î º¯°æµÇ¾ú´Ù. 
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);
		
		//ÀÌÁ¦ dX, dY¿¡ ÀÖ´Â ¿ÀºêÁ§Æ®¿¡°Ô ¼Òºñ¼º ¾ÆÀÌÅÛÀ» °Ç³×ÁØ´Ù. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		
		// v1.4 ÁÖ°íÀÚ ÇÑ °´Ã¼¿Í ¸Â´ÂÁö ÆÇ´ÜÇÑ´Ù.
		if (wObjectID != 0) { 
			if (wObjectID < 10000) {
				// ÇÃ·¹ÀÌ¾î 
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != 0) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = 0;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != 0) {
						if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = 0;
					}
				}
			}
		}

		if (sOwnerH == 0) {
			// ÁÖ°íÀÚ ÇÏ´Â À§Ä¡¿¡ ¾Æ¹«µµ ¾ø´Ù.
			// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);
	
			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4 color
		}
		else {
			// ¾ÆÀÌÅÛÀ» ÁØ´Ù.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// ÇÃ·¹ÀÌ¾î¿¡°Ô ÁÖ¾ú´Ù.
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);

				if (sOwnerH == iClientH) {
					// ¸¸¾à ÀÚ±â ÀÚ½Å¿¡°Ô ÁÖ´Â °Å¶ó¸é ¹«½ÃÇÑ´Ù. ÇØÅ·ÀÇ ¼ÒÁö°¡ ÀÖ´Ù.
					delete pItem;
					return;
				}
				
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) ) {
					// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					// 1°³ È¹µæÇß´Ù. Amount°¡ ¾Æ´Ï´Ù!
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;	// ¼ö·®À» ÀÔ·Â 
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
					cp++;

					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
	
					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item
					cp++;
					*/

					if (iEraseReq == 1) delete pItem;

					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, true, true);
						break;
					}

					// v1.4
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, 0, cCharName);
				}
				else {
					// ¾ÆÀÌÅÛÀ» Àü´Þ¹ÞÀº Ä³¸¯ÅÍ°¡ ´õÀÌ»ó ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¼ö ¾ø´Â »óÅÂÀÌ´Ù.
					// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);
	
					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4 color

					// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(sOwnerH, true, true);
						break;
					}

					// v1.4 ¼ö·®´ÜÀ§ÀÇ ¾ÆÀÌÅÛÀ» Àü´Þ¿¡ ½ÇÆÐÇßÀ½À» ¾Ë¸°´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, 0, cCharName);
				}

			}
			else {
				// NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù.
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPC°¡ Ã¢°í ÁÖÀÎÀÌ¾ú´Ù¸é ¹°°ÇÀ» º¸°üÇÏ°Ú´Ù´Â ÀÇ¹ÌÀÌ´Ù. 
					if (bSetItemToBankItem(iClientH, pItem) == false) {
						// ¹°°ÇÀ» ¸Ã±â´Âµ¥ ½ÇÆÐÇÏ¿´´Ù.	
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, 0, 0, 0, 0);

						// ½ÇÆÐÇßÀ¸¹Ç·Î ¹Ù´Ú¿¡ ¶³±º´Ù.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

						// v1.411  
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);
	
						// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
									                pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color
					}
		   		}
				else {
					// ÀÏ¹Ý NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¸é ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö·Á¾ß ÇÑ´Ù. 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);
	
					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color
				}
			}
		}
	}
	else {
		// ¾ÆÀÌÅÛ ÀüºÎ¸¦ ÁÖ¾ú´Ù.
		
		// ÀåÂøÁßÀÎ ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù¸é ¾ÆÀÌÅÛ ÀåÂøÈ¿°ú¸¦ ÇØÁ¦ÇØ¾ß ÇÏ¹Ç·Î.
		ReleaseItemHandler(iClientH, sItemIndex, true);

		// Ã³¸®µµÁß ¿¡·¯°¡ ¹ß»ýÇÒ¶§¸¦ ´ëºñÇØ¼­ -1·Î ÇÒ´çÇØ ³õ´Â´Ù.
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) 
			m_pClientList[iClientH]->m_cArrowIndex = -1;
		
		//ÀÌÁ¦ dX, dY¿¡ ÀÖ´Â ¿ÀºêÁ§Æ®¿¡°Ô ¼Òºñ¼º ¾ÆÀÌÅÛÀ» °Ç³×ÁØ´Ù. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); // ¾ÆÀÌÅÛÀ» dX, dY¿¡ ÀÖ´Â Ä³¸¯ÅÍ¿¡°Ô ÁØ´Ù. ¸¸¾à ¹ÞÀ» Ä³¸¯ÅÍ°¡ ¾ÆÀÌÅÛÀ» ¹ÞÁö ¸øÇÒ »óÈ²ÀÌ¶ó¸é ¶¥¿¡ ¶³¾îÁø´Ù.  
		
		// v1.4 ÁÖ°íÀÚ ÇÑ °´Ã¼¿Í ¸Â´ÂÁö ÆÇ´ÜÇÑ´Ù.
		if (wObjectID != 0) { 
			if (wObjectID < 10000) {
				// ÇÃ·¹ÀÌ¾î 
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != 0) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = 0;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != 0) {
						if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = 0;
					}
				}
			}
		}
	
		if (sOwnerH == 0) {
			// ¾ÆÀÌÅÛÀ» ÁÖ°íÀÚ ÇÏ´Â Àå¼Ò¿¡ Ä³¸¯ÅÍ°¡ ¾ø´Ù. 
			// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                             m_pClientList[iClientH]->m_sY, 
																	     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
	
			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum, 
								        0, 
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color
		
			// ÀÌÁ¦ ¾ÆÀÌÅÛÀÌ ¶³¾îÁ³À¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, 0, 0);
		}
		else {
			// ¾ÆÀÌÅÛÀ» ´Ù¸¥ Ä³¸¯ÅÍ¿¡°Ô ÁØ´Ù. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
					
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// ĳͿ  ־.	
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
				pItem = m_pClientList[iClientH]->m_pItemList[sItemIndex];
				
				// v2.03 ũ缼̵ ΰ쵵   ϴ.

				// v2.17 2002-7-31   ȣ   ְ Ѵ.
				if (pItem->m_sIDnum == 88) {

					// ÷̾ iClientH  sOwnerH 尡 û ־.  
					// sOwnerH 帶Ͷ  ޴  ƴ϶ Ȯ  ־ Ѵ.
								// v2.17 2002-7-31   ȣ   ְ Ѵ.
					if ((m_pClientList[iClientH]->m_iGuildRank == -1) && 
						(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
						(memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[sOwnerH]->m_cLocation, 10) == 0) &&
						(m_pClientList[sOwnerH]->m_iGuildRank == 0) ) {
						//  ̴.	 ͿԴ Ȯ û ޽ Ѵ.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION, 0, 0, 0, 0);
						//    ο  ־Ƿ Ʈ Ұ 뺸Ѵ.
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, 0, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
					
						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// v2.17 2002-7-31   ȣ   ְ Ѵ.
				if ((m_bIsCrusadeMode == false) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {

					// ÷̾ iClientH  sOwnerH Ż û ־.  
					// sOwnerH 帶̰ iClientH  ̸  iClientH ̶ 
					//  ޴  ƴ϶ Ȯ  ־ Ѵ.
					if ( (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) && 
						 (m_pClientList[iClientH]->m_iGuildRank != -1) && 
						 (m_pClientList[sOwnerH]->m_iGuildRank == 0) ) {
						//  ̴.	 ͿԴ ŻȮ û ޽ Ѵ.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION, 0, 0, 0, 0);
						//    ο  ־Ƿ Ʈ Ұ 뺸Ѵ.
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, 0, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
					
						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// ÀÏ¹ÝÀûÀÎ °æ¿ì ¾ÆÀÌÅÛÀ» ±×Àú ¹ÞÀ» »Ó...
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) ) {
					
					// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» Àü´ÞÇÑ °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
					_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

					// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					// 1°³ È¹µæÇß´Ù.
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
					cp++;

					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
	
					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
					cp++;
					*/

					if (iEraseReq == 1) delete pItem;
 
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, true, true);
						break;
					}
				}
				else {
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum, 
										        0, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color

					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, true, true);
						break;
					}

					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}
			else {
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					if (bSetItemToBankItem(iClientH, sItemIndex) == false) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, 0, 0, 0, 0);
						
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
						                                                         	 m_pClientList[iClientH]->m_sY, 
							                                                         m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
							                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum, 
							                        0, 
													m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
													m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color
					}
				}
				else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0) {
					if ((m_bIsCrusadeMode == false) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {
						
						if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
							SendNotifyMsg(iClientH, iClientH, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, 0, 0, 0, 0);
						
							ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
							memcpy(m_pClientList[iClientH]->m_cGuildName, "NONE", 4);
							m_pClientList[iClientH]->m_iGuildRank = -1;
							m_pClientList[iClientH]->m_iGuildGUID = -1;

							SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

							m_pClientList[iClientH]->m_iExp -= 300;
							if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
						}

						delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
					} 
					else {
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
													m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
													m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
													0,
													m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
													m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color

						// v1.4 ¾ÆÀÌÅÛ Àü´ÞÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¹æ¹ý 
						ZeroMemory(cCharName, sizeof(cCharName));

					}
				}
				else {
					// ÀÏ¹Ý NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¸é ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö·Á¾ß ÇÑ´Ù. 

					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
												m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
												0,
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color

					// v1.4 ¾ÆÀÌÅÛ Àü´ÞÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¹æ¹ý 
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}

			// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ÁØ º»ÀÎ¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾úÀ¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, 0, cCharName);
		}

REMOVE_ITEM_PROCEDURE:

		// ³×Æ®¿öÅ© ¿À·ù·Î Ã³¸®µµÁß Å¬¶óÀÌ¾ðÆ®°¡ Á¦°ÅµÇ¾ú´Ù¸é ´õÀÌ»ó ÁøÇàÇÒ ¼ö ¾ø´Ù. 
		if (m_pClientList[iClientH] == 0) return;

		// ¾ÆÀÌÅÛÀ» ÁÖ°Å³ª ¹ö·ÈÀ¸¹Ç·Î Áö¿î´Ù. deleteÇØ¼­´Â ¾ÈµÈ´Ù! 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;
		
		// È­»ì ÀÎµ¦½º¸¦ Àç ÇÒ´ç
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
	iCalcTotalWeight(iClientH);
}

void CGame::SendNotifyMsg(int iFromH, int iToH, WORD wMsgType, DWORD sV1, DWORD sV2, DWORD sV3, char * pString, DWORD sV4, DWORD sV5, DWORD sV6, DWORD sV7, DWORD sV8, DWORD sV9, char * pString2)
{
 char cData[1000];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 int   * ip, iRet, i;
	
	if (m_pClientList[iToH] == 0) return;

	ZeroMemory(cData, sizeof(cData));

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);			   
	*wp  = wMsgType;

	cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

	// !!! sV1, sV2, sV3´Â DWORDÇüÀÓÀ» ¸í½ÉÇÏ¶ó.
	switch (wMsgType) {
	case msg_shard:
	case msg_fragment:
		wp = (WORD*)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp = (WORD*)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp = (WORD*)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, pString2, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 42);
		break;

	case DEF_NOTIFY_CURLIFESPAN:
	case DEF_SEND_NPCHP: //50Cent - HP Bar
		ip = (int*)cp;
		*ip = (int)sV1;
		cp += 4;

		ip = (int*)cp;
		*ip = (int)sV2;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_HELDENIANCOUNT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		cp += 14;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);

		break;
	
	case DEF_NOTIFY_NOMOREAGRICULTURE:
	case DEF_NOTIFY_AGRICULTURESKILLLIMIT:
	case DEF_NOTIFY_AGRICULTURENOAREA:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	// New 18/05/2004
	case DEF_NOTIFY_SPAWNEVENT:
		*cp = (char)sV3;
		cp++;

		sp = (short *)cp;
		*cp = sV1;
		cp += 2;

		sp = (short *)cp;
		*cp = sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 11);
		break;

	case DEF_NOTIFY_QUESTCOUNTER:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;
	
	case DEF_NOTIFY_APOCGATECLOSE:
	case DEF_NOTIFY_APOCGATEOPEN:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		ip  = (int *)cp;
		*ip = sV2;
		cp += 4;

		memcpy(cp,pString,10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;

	case DEF_NOTIFY_ABADDONKILLED:
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;

	case DEF_NOTIFY_APOCFORCERECALLPLAYERS:
	case DEF_NOTIFY_APOCGATESTARTMSG:
	case DEF_NOTIFY_APOCGATEENDMSG:
	case DEF_NOTIFY_NORECALL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_FORCERECALLTIME:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	// New 16/05/2004
	//0xB4E2, 0xBEB
	case DEF_NOTIFY_MONSTERCOUNT:
	case DEF_NOTIFY_SLATE_STATUS:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	//0x0BE5, 0x0BE7, 0x0BE8, 0x0BEA
	case DEF_NOTIFY_0BE8:
	case DEF_NOTIFY_HELDENIANTELEPORT:
	case DEF_NOTIFY_HELDENIANEND:
	case DEF_NOTIFY_RESURRECTPLAYER:
	case DEF_NOTIFY_SLATE_EXP:
	case DEF_NOTIFY_SLATE_MANA:
	case DEF_NOTIFY_SLATE_INVINCIBLE:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_SLATE_CREATEFAIL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_SLATE_CREATESUCCESS:
		dwp  = (DWORD *)cp;
		*dwp = sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	// New 07/05/2004
	// Party Notify Msg's
	case DEF_NOTIFY_PARTY:
		switch(sV1) {
		case 4:
		case 6:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;

			memcpy(cp,pString,10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
			break;
		case 5:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;

			memcpy(cp, pString, sV3 * 11);
			cp += sV3 * 11;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + (sV3 * 11));
			break;
		default:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV4;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
				break;
		}
		break;

	case DEF_NOTIFY_REQGUILDNAMEANSWER:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);
		break;

	// New 06/05/2004
	// Upgrade Notify Msg's
	case DEF_NOTIFY_ITEMUPGRADEFAIL:
		sp  = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,8);
		break;

	case DEF_NOTIFY_ITEMATTRIBUTECHANGE:
	case DEF_NOTIFY_GIZONITEMUPGRADELEFT:
		sp  = (short *)cp;
		*sp = sV1;
		cp += 2;

		dwp = (DWORD *)cp;
		*dwp = sV2;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = sV3;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,20);
		break;

	case DEF_NOTIFY_GIZONITEMCANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		*cp = (char)sV2;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		*cp = (char)sV6;
		cp++;

		*cp = (char)sV7;
		cp++;

		dwp = (DWORD *)cp;
		*dwp = sV8;
		cp += 4;

		memcpy(cp,pString,20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,41);
		break;

// 2.06 - by KLKS
	case DEF_NOTIFY_CHANGEPLAYMODE:
		memcpy(cp,pString,10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,16);
		break;
//

	case DEF_NOTIFY_TCLOC:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV5;
		cp += 2;
		
		memcpy(cp, pString2, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;
	
	//New 11/05/2004
	case DEF_NOTIFY_GRANDMAGICRESULT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		if (sV9 > 0) {
			memcpy(cp,pString2,(sV9*2)+2);
			cp += (sV9*2)+2;
		}
		else{
			sp = (short *)cp;
			*sp = 0;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, (sV9*2)+26);
		break;
	
	case DEF_NOTIFY_MAPSTATUSNEXT:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;

	case DEF_NOTIFY_MAPSTATUSLAST:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;
	
	case DEF_NOTIFY_LOCKEDMAP:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
		break;
	
	case DEF_NOTIFY_BUILDITEMSUCCESS:
	case DEF_NOTIFY_BUILDITEMFAIL:
		
		if (sV1 >= 0) {
			sp = (short *)cp;
			*sp = (short)sV1;
			cp += 2;
		}
		else {
			sp = (short *)cp;
			*sp = (short)sV1 + 10000;
			cp += 2;
		}

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
		
	case DEF_NOTIFY_HELP:
	case DEF_NOTIFY_QUESTREWARD:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
		
	case DEF_NOTIFY_CANNOTCONSTRUCT:
	case DEF_NOTIFY_METEORSTRIKECOMING:
	case DEF_NOTIFY_METEORSTRIKEHIT:
	case DEF_NOTIFY_HELPFAILED:
	case DEF_NOTIFY_SPECIALABILITYENABLED:
	case DEF_NOTIFY_FORCEDISCONN:
	case DEF_NOTIFY_OBSERVERMODE:
	case DEF_NOTIFY_QUESTCOMPLETED:
	case DEF_NOTIFY_QUESTABORTED:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_QUESTCONTENTS:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString2 != 0) memcpy(cp, pString2, 20);
		cp += 20;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 44);
		break;
		
	case DEF_NOTIFY_ENERGYSPHERECREATED:
	case DEF_NOTIFY_ITEMCOLORCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
	case DEF_NOTIFY_CANCELEXCHANGEITEM:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SETEXCHANGEITEM:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_NOTFLAGSPOT:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_ITEMPOSLIST:
		for (i = 0; i < DEF_MAXITEMS; i++) {
			sp = (short *)cp;
			*sp = (short)m_pClientList[iToH]->m_ItemPosList[i].x;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_pClientList[iToH]->m_ItemPosList[i].y;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXITEMS*4);
		break;
	
	case DEF_NOTIFY_ENEMYKILLS:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_CRUSADE:
		ip = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
	case DEF_NOTIFY_SPECIALABILITYSTATUS:
	case DEF_NOTIFY_DAMAGEMOVE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_ADMINIFO:
		switch (sV1) {
		case 1:
			// NPCÀÇ Á¤º¸¸¦ ¾ò¾î¿Â´Ù.
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHP;
			cp += 4;
			
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iDefenseRatio;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_bIsSummoned;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_cActionLimit;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHitDice;
			cp += 4;

			dwp  = (DWORD *)cp; // v1.4
			*dwp = m_pNpcList[sV2]->m_dwDeadTime;
			cp += 4;

			dwp  = (DWORD *)cp; 
			*dwp = m_pNpcList[sV2]->m_dwRegenTime;
			cp += 4;

			ip  = (int *)cp; 
			*ip	= (int)m_pNpcList[sV2]->m_bIsKilled;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26 + 12);
			break;
		}
		break;

	case DEF_NOTIFY_HELDENIANSTART:
	case DEF_NOTIFY_NPCTALK:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString != 0) memcpy(cp, pString, 20);
		cp += 20;

		if (pString2 != 0) memcpy(cp, pString2, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 64);
		break;

	// Crafting
	case DEF_NOTIFY_CRAFTING_FAIL:		//reversed by Snoopy: 0x0BF1:
		ip = (int*)cp;
		*ip = (int)sV1;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_CRAFTING_SUCCESS:		//reversed by Snoopy: 0x0BF0
	case DEF_NOTIFY_PORTIONSUCCESS:
	case DEF_NOTIFY_LOWPORTIONSKILL:
	case DEF_NOTIFY_PORTIONFAIL:
	case DEF_NOTIFY_NOMATCHINGPORTION:
		// ÀÏÄ¡ÇÏ´Â Æ÷¼Ç Á¶ÇÕÀÌ ¾ø´Ù.
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SUPERATTACKLEFT:
		sp = (short *)cp;
		*sp = m_pClientList[iToH]->m_iSuperAttackLeft;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_SAFEATTACKMODE:
		*cp = m_pClientList[iToH]->m_bIsSafeAttackMode;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
	
	case DEF_NOTIFY_QUERY_JOINPARTY:
	case DEF_NOTIFY_IPACCOUNTINFO:
		strcpy(cp, pString);
		cp += strlen(pString);

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
		break;
	
	case DEF_NOTIFY_REWARDGOLD:
		dwp = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iRewardGold;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SERVERSHUTDOWN:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_GLOBALATTACKMODE:
	case DEF_NOTIFY_WHETHERCHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
		
	case DEF_NOTIFY_FISHCANCELED:
	case DEF_NOTIFY_FISHSUCCESS:
	case DEF_NOTIFY_FISHFAIL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_DEBUGMSG:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_FISHCHANCE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
	case DEF_NOTIFY_EVENTFISHMODE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_NOTICEMSG:
		memcpy(cp, pString, strlen(pString));
		cp += strlen(pString);

		*cp = 0;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, strlen(pString) + 7);
		break;

	case DEF_NOTIFY_CANNOTRATING:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_RATINGPLAYER:
		*cp = (char)sV1;
		cp++;

		memcpy(cp, pString, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_ADMINUSERLEVELLOW:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_PLAYERSHUTUP:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 19);
		break;
	
	case DEF_NOTIFY_TIMECHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_TOBERECALLED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_HUNGER:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_PLAYERPROFILE:
		if (strlen(pString) > 100) {
			memcpy(cp, pString, 100);
			cp += 100;
		}
		else {
			memcpy(cp, pString, strlen(pString));
			cp += strlen(pString);
		}
		*cp = 0;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
		break;

	// New 10/05/2004 Changed
	case DEF_NOTIFY_WHISPERMODEON:
	case DEF_NOTIFY_WHISPERMODEOFF:
	case DEF_NOTIFY_PLAYERNOTONGAME:
		memcpy(cp, pString, 10);
		cp += 10;

		memcpy(cp, "          ", 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 27);
		break;

	// New 15/05/2004 Changed
	case DEF_NOTIFY_PLAYERONGAME:
		memcpy(cp, pString, 10);
		cp += 10;

		if (pString[0] != 0) {
			memcpy(cp, pString2, 14);
			cp += 14;
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 31);
		break;
	
	// New 06/05/2004
	case DEF_NOTIFY_ITEMSOLD:
	case DEF_NOTIFY_ITEMREPAIRED:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	// New 06/05/2004
	case DEF_NOTIFY_REPAIRITEMPRICE:
	case DEF_NOTIFY_SELLITEMPRICE:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV3;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV4;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 42);
		break;

	case DEF_NOTIFY_CANNOTREPAIRITEM:
	case DEF_NOTIFY_CANNOTSELLITEM:
		wp = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);

		break;
	
	case DEF_NOTIFY_SHOWMAP:
		wp  = (WORD *)cp;  // º¸¿©ÁÖ´Â Á¾·ù 
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;  // ¸Ê ¹øÈ£ (0 aresden, 1 elvine, 3 middleland...)
		*wp = (WORD)sV2;
		cp += 2;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SKILLUSINGEND:
		wp  = (WORD *)cp;  // ±â¼ú »ç¿ë °á°ú 
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_TOTALUSERS:
		wp  = (WORD *)cp;    
		*wp = (WORD)m_iTotalGameServerClients; //_iGetTotalClients();
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_MAGICEFFECTOFF:
	case DEF_NOTIFY_MAGICEFFECTON:
		wp  = (WORD *)cp;  // ¸¶¹ý È¿°ú Á¾·ù 
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  // ¸¶¹ý È¿°ú È¿·Â  
		*dwp = (DWORD)sV2;
		cp += 4;

		dwp  = (DWORD *)cp;  // ¸¶¹ý È¿°ú È¿·Â  
		*dwp = (DWORD)sV3;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;
	
	case DEF_NOTIFY_CANNOTITEMTOBANK:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SERVERCHANGE:
		memcpy(cp, m_pClientList[iToH]->m_cMapName, 10);
		cp += 10;
	
		// World ServerÀÇ ÁÖ¼Ò¸¦ ¾Ë·ÁÁØ´Ù.
		memcpy(cp, m_cLogServerAddr, 15);
		cp += 15;

		ip = (int *)cp;
		//Filter
		*ip = m_iLogServerPort;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16 +19);
		break;

	case DEF_NOTIFY_SKILL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SETITEMCOUNT:
		wp  = (WORD *)cp;  // ¾ÆÀÌÅÛ ÀÎµ¦½º ¹øÈ£ 
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  // ¾ÆÀÌÅÛÀÇ ÇöÀç ¼ö·® 
		*dwp = (DWORD)sV2;
		cp += 4;
				
		*cp = (char)sV3;
		cp++;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 13);
		break;

	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;
		
	case DEF_NOTIFY_CANNOTGIVEITEM:
	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_ENEMYKILLREWARD:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iEnemyKillCount;
		cp += 4;
		memcpy(cp, m_pClientList[sV1]->m_cCharName, 10);
		cp += 10;
		memcpy(cp, m_pClientList[sV1]->m_cGuildName, 20);
		cp += 20;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[sV1]->m_iGuildRank;
		cp += 2;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[iToH]->m_iWarContribution;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_PKCAPTURED:
		// PK¸¦ Àâ¾Ò´Ù.
		// PKÀÇ PKcount
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iRewardGold;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iExp;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_NOTIFY_PKPENALTY:
		// PK Æä³ÎÆ¼¸¦ ¸Ô¾ú´Ù.
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iStr;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iVit;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iDex;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iInt;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMag;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iPKCount;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
	
	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
	case DEF_NOTIFY_LIMITEDLEVEL:
		// Ã¼ÇèÆÇ »ç¿ëÀÚ´Â ´õÀÌ»ó ·¹º§À» ¿Ã¸± ¼ö ¾øÀ½À» ¾Ë¸°´Ù.
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_ITEMRELEASED:
	case DEF_NOTIFY_ITEMLIFESPANEND:
		// ÀüÅõÁß ¹«±â, È¤Àº ¹æ¾î±¸ ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´ÙÇØ ¸Á°¡Á³À½À» ¾Ë¸°´Ù. 
		sp  = (short *)cp;
		*sp = (short)sV1;	// ÀåÂø À§Ä¡ 
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;	// ¾ÆÀÌÅÛ ¹øÈ£  
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_KILLED:
		// »ç¸Á Åëº¸ : Á×ÀÎ Ä³¸¯ÅÍ ÀÌ¸§µµ ÇÔ²² º¸³»ÁØ´Ù. 
		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26);
		break;
	
	case DEF_NOTIFY_EXP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_HP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iHP;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iHungerStatus; // v2.04 0926 HPÀÇ µÚ¿¡ MP¸¦ °°ÀÌ ¾Ë·ÁÁØ´Ù. ¸¶³ªº¯È¯ÀÇ Æ¯¼ºÄ¡ ¶§¹® 
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_MP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iSP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_CHARISMA:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

		//MOG Fixes
	case DEF_NOTIFY_STATECHANGE_FAILED:		// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ½ÇÆÐ..korean buttplugs
	case DEF_NOTIFY_SETTING_FAILED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_STATECHANGE_SUCCESS:	// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ¼º°ø.. wtf korean junk
		{
			int i;

			for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cMagicMastery[i];
				cp++;
			}

			for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cSkillMastery[i];
				cp++;
			}

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
		}
		break;

	case DEF_NOTIFY_SETTING_SUCCESS:
	case DEF_NOTIFY_LEVELUP:
		ip  = (int *)cp;
		*ip = m_pClientList[iToH]->m_iLevel;
		cp += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iStr;		
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iVit;								
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iDex;			
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iInt;					
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iMag;						
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iCharisma;
		cp  += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;

	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		if (m_pClientList[iFromH] != 0)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:			
    case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:		
    case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		if (m_pClientList[iFromH] != 0)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;

	case DEF_NOTIFY_GUILDDISBANDED:
		
		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;
	  
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 36);
		break;

	// v1.4311-3 Ãß°¡ Å¬¶óÀÌ¾ðÆ®¿¡°Ô »çÅõÀå ¿¹¾àÀÌ Ãë¼ÒµÇ¾ú´Ù°í ¾Ë¸² ..
	case DEF_NOTIFY_FIGHTZONERESERVE:
		ip = (int *)cp;
		*ip = (int )sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break; 

	// v1.4311-3 Ãß°¡ ±æµå ¸¶½ºÅÍ°¡ ¾Æ´Ñ°æ¿ì .
	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	// v1.4311-3 Ãß°¡ ÀÚ½ÅÀÇ ±æµå¿øÀÌ  ¾Æ´Ñ°æ¿ì 
	case DEF_NOTIFY_CANNOTBANGUILDMAN:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		// Ã³¸® µµÁß ¿À·ù°¡ ¹ß»ýÇÏ´Â °ÍÀ» ¸·±â À§ÇØ Áö¿ìÁö ¾Ê´Â´Ù. Time OutÀ¸·Î »èÁ¦µÉ °ÍÀÓ. 
		//DeleteClient(iToH, true, true);
		return;
	}
}

void CGame::JoinGuildApproveHandler(int iClientH, char * pName)
{
 int i;
 bool bIsExist = false;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ °¡ÀÔ¿ä±¸°¡ ¼º°øÇÏ¿´´Ù.
	
	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		// v1.4 ¼Ò¼Ó ¸¶À»ÀÌ ´Þ¶óµµ ¹«½ÃµÈ´Ù.
		if (memcmp(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) != 0) return;
		
		// ±æµåÀÇ ÀÌ¸§À» º¹»çÇÏ°í ¼öÄ¡¸¦ ÃÊ±âÈ­ÇØ ÁØ´Ù.
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);
		
		// ±æµå GUIDº¹»çÇÑ´Ù.
		m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

		// ±æµåÀÇ »ý¼ºÀ§Ä¡¸¦ ÃÊ±âÈ­ÇÑ´Ù.
		ZeroMemory(m_pClientList[i]->m_cLocation, sizeof(m_pClientList[i]->m_cLocation));
		strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

		m_pClientList[i]->m_iGuildRank = DEF_GUILDSTARTRANK; //@@@  GuildRankÀÇ ½ÃÀÛÀº DEF_GUILDSTARTRANK
		
		// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô °¡ÀÔÀÌ ¼º°øÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDAPPROVE, 0, 0, 0, 0);

		// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù. 
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		
		// ´Ù¸¥ ±æµå¿øµé¿¡°Ô »õ ±æµå¿øÀÌ ÀÖÀ½À» ¾Ë¸°´Ù.
		SendGuildMsg(i, DEF_NOTIFY_NEWGUILDSMAN, 0, 0, 0);

		// ±æµåÁ¤º¸È­ÀÏ¿¡ »õ ±æµå¿øÀÇ ÀÌ¸§À» ±â·ÏÇÑ´Ù.
		//bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN, i);
		return;
	}

	// °¡ÀÔÀ» ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ 
}

void CGame::JoinGuildRejectHandler(int iClientH, char * pName)
{
 int i;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ °¡ÀÔ ¿ä±¸°¡ ½ÇÆÐ ÇÏ¿´´Ù.

	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô °¡ÀÔÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDREJECT, 0, 0, 0, 0);
		return;
	}

	// °¡ÀÔÀ» ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ 
}

void CGame::DismissGuildApproveHandler(int iClientH, char * pName)
{
 int i;


	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		//bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
		//_bItemLog(DEF_ITEMLOG_BANGUILD,i,(char *)0,0) ;
		SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, 0, 0, 0);
	
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, "NONE");
		m_pClientList[i]->m_iGuildRank = -1; 
		m_pClientList[i]->m_iGuildGUID = -1;

		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, 0, 0, 0, 0);
		
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		return;
	}

}

void CGame::DismissGuildRejectHandler(int iClientH, char * pName)
{
 int i;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ Å»Åð ¿ä±¸°¡ ½ÇÆÐ ÇÏ¿´´Ù.

	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô Å»Åð°¡ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDREJECT, 0, 0, 0, 0);
		return;
	}

	// Å»Åð¸¦ ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ 
}


DWORD CGame::dwGetItemCount(int iClientH, char * pName)
{
 int i;
 char cTmpName[21];

	if (m_pClientList[iClientH] == 0) return 0;
	
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != 0) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
	}

	return 0;
}

int CGame::SetItemCount(int iClientH, char * pItemName, DWORD dwCount)
{
 int i;
 char cTmpName[21];
 WORD wWeight;
	
	if (m_pClientList[iClientH] == 0) return -1;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != 0) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);// m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;

		// Ä«¿îÆ®°¡ 0ÀÌ¸é ¸ðµÎ ¼Ò¸ðµÈ °ÍÀÌ¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÑ´Ù.
		if (dwCount == 0) {
			ItemDepleteHandler(iClientH, i, false);
		}
		else {
			// ¾ÆÀÌÅÛÀÇ ¼ö·®ÀÌ º¯°æµÇ¾úÀ½À» ¾Ë¸°´Ù. 
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETITEMCOUNT, i, dwCount, (char)true, 0);
		}
		
		return wWeight;
	}

	return -1;
}


int CGame::SetItemCount(int iClientH, int iItemIndex, DWORD dwCount)
{
 WORD wWeight;
	
	if (m_pClientList[iClientH] == 0) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return -1;
	
	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1);//m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;

	// Ä«¿îÆ®°¡ 0ÀÌ¸é ¸ðµÎ ¼Ò¸ðµÈ °ÍÀÌ¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÑ´Ù.
	if (dwCount == 0) {
		ItemDepleteHandler(iClientH, iItemIndex, false);
	}
	else {
		// ¾ÆÀÌÅÛÀÇ ¼ö·®ÀÌ º¯°æµÇ¾úÀ½À» ¾Ë¸°´Ù. 
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)true, 0);
	}
		
	return wWeight;	
}

void CGame::ClientKilledHandler(int iClientH, int iAttackerH, char cAttackerType, short sDamage)
{
 char  * cp, cAttackerName[21], cData[120];
 short sAttackerWeapon;
 int   * ip, i, iExH;
 bool  bIsSAattacked = false;
 
	
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
 	if (m_pClientList[iClientH]->m_bIsKilled ) return;

	//   ð ԷѴ.
	// 2002-7-4   ø  ֵ 
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fight", 5) == 0) {
		m_pClientList[iClientH]->m_dwFightzoneDeadTime = timeGetTime();
		wsprintf(G_cTxt, "Fightzone Dead Time: %d", m_pClientList[iClientH]->m_dwFightzoneDeadTime);
		PutLogList(G_cTxt);
	}

	m_pClientList[iClientH]->m_bIsKilled = true;
	// HP 0̴.
	m_pClientList[iClientH]->m_iHP = 0;

	// Snoopy: Remove all magic effects and flags
	for (i = 0; i < DEF_MAXMAGICEFFECTS; i++)
		m_pClientList[iClientH]->m_cMagicEffectStatus[i] = 0;

	SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetInhibitionCastingFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);
	SetHasteFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);

	//  ȯ  ȯ Ѵ.
	if (m_pClientList[iClientH]->m_bIsExchangeMode ) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	//   NPC ݴ ִ ü Ѵ.
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
	
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER_INDIRECT:
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iAttackerH] != 0)
			memcpy(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);
		break;
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iAttackerH] != 0)
#ifdef DEF_LOCALNPCNAME     // v2.14 NPC ̸ ߹ȭ   
			wsprintf(cAttackerName,"NPCNPCNPC@%d",m_pNpcList[iAttackerH]->m_sType);
#else 
			memcpy(cAttackerName, m_pNpcList[iAttackerH]->m_cNpcName, 20);
#endif
		break ;
	default:
		break;
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_KILLED, 0, 0, 0, cAttackerName);
	// ٸ Ŭ̾Ʈ ״  .
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[iAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, 0);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap ) {
		if (m_pClientList[iClientH]->m_cSide == 1) {
			m_iHeldenianAresdenDead++;
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			m_iHeldenianElvineDead++;
		}
		UpdateHeldenianStatus();
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// v1.432
		// Ư ɷ ִ   ߴ.
		switch (m_pClientList[iAttackerH]->m_iSpecialAbilityType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			bIsSAattacked = true;
			break;
		}
		
		if (iAttackerH == iClientH) return; // ̴.
		// ÷̾ ÷̾ ׿ٸ PK  ¸ ǺϿ ġ ø. 
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
			// ڰ ̴. 
			if (m_pClientList[iClientH]->m_iPKCount == 0) {


				//  ڿ. ڴ PK  ޴´.
				ApplyPKpenalty(iAttackerH, iClientH);
			}
			else {

						// ˸  ڿ. ڴ PK Ϳ   ޴´. 
				PK_KillRewardHandler(iAttackerH, iClientH);
			}
		} 
		else {
			// ڰ ڰ ƴ϶   Ҽ̴. 
			if (m_pClientList[iClientH]->m_iGuildRank == -1) {
				// ڴ ù̴.
				// ڰ ,   ù,    -> PK . ٸ  ù,  ->  
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					// ڰ ̴. 				
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						//  ù ڰ ׿. ڴ PK ȴ.
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
						// ڴ PK Ƶ   Ѵ.

					}
				}
				else {
					// ڰ ù, Ȥ  ->   PK, ٸ ̶   
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						//   ù  ù Ȥ   ̴.  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// ڰ  . PK̴.
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							// ڸ Ҵ. 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						// ڰ ٸ  Ҽ.  
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
			else {
				// ڴ ̴. 
				//  ڰ , ù, ° ƴ -> PK /   ->  
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					// ڰ ̴.
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						//   ڰ ׿. ڴ PK ȴ.
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
						// ڴ PK Ƶ   Ѵ.

					}
				}
				else {
					// ڴ ù Ȥ  ->   PK, ٸ ̶   
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						//     ù Ȥ   ̴.  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// ڰ  . PK̴.
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							// ڸ Ҵ. 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						// ڰ ٸ  Ҽ.  
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
		}

		//  ÷̾ ޿ ´ Ƽ Ѵ. 
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
				//ڿ ݹ޾ ׾. 
				//PKǷ ġ  ʴ´.
				//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
				//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
				//SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
			}
			else {
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) == 0) {
					//  ù Ȥ  ׾. 
					//PKǷ   ʴ´. 
					//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
					//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
					//SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
				}
				else {
					// ٸ  ù Ȥ  ׾.  ׾Ƿ ġ  . 
					ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
				}
			}
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
		char cTxt[128];
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%s killed %s", m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iClientH]->m_cCharName);
		for (int Killedi = 0; Killedi < DEF_MAXCLIENTS; Killedi++) {
			if (m_pClientList[Killedi] != 0 && Killedi != iAttackerH) {
				SendNotifyMsg(0, Killedi, DEF_NOTIFY_NOTICEMSG, 0, 0, 0, cTxt);
			}
		}
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%s(%s) killed %s(%s) in %s(%d,%d)", m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		PutPvPLogFileList(cTxt); // Centu : log pvp
	}
	else if (cAttackerType == DEF_OWNERTYPE_NPC) {

		_bPKLog(DEF_PKLOG_BYNPC,iClientH,0,cAttackerName) ;

		// ÷̾  ׾.  ÷̾ ޿ ´ Ƽ Ѵ.
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			ApplyCombatKilledPenalty(iClientH, 1, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
		//   NPC  Ʈ ְ Ǽ Ʈ ΰ
		if (m_pNpcList[iAttackerH]->m_iGuildGUID != 0) {
						
			if (m_pNpcList[iAttackerH]->m_cSide != m_pClientList[iClientH]->m_cSide) {
				//   Ȥ Ʈ  ÷̾ ׿. ٷ 뺸Ѵ.
				//   ְ ִٸ ٷ 뺸.  ٸ  ˷.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[iAttackerH]->m_iGuildGUID) &&
					(m_pClientList[i]->m_iCrusadeDuty == 3)) {
					m_pClientList[i]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);

					if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
						m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

					//testcode
					wsprintf(G_cTxt, "Enemy Player Killed by Npc! Construction +%d", (m_pClientList[iClientH]->m_iLevel / 2));
					PutLogList(G_cTxt);
					// ְ ٷ 뺸.
					SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, 0);
					return;
				}
				
				//   . ٸ  ְ ˷ Ѵ.
				/*ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				*cp = GSM_CONSTRUCTIONPOINT;
				cp++;
				ip = (int*)cp;
				*ip = m_pNpcList[iAttackerH]->m_iGuildGUID;
				cp += 4;
				ip = (int*)cp;
				*ip = (m_pClientList[iClientH]->m_iLevel / 2);
				cp += 4;
				bStockMsgToGateServer(cData, 9);*/
			}
		}
		char cTxt[128];
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%s killed %s", m_pNpcList[iAttackerH]->m_cNpcName, m_pClientList[iClientH]->m_cCharName);
		for (int Killedi = 0; Killedi < DEF_MAXCLIENTS; Killedi++) {
			if (m_pClientList[Killedi] != 0) {
				SendNotifyMsg(0, Killedi, DEF_NOTIFY_NOTICEMSG, 0, 0, 0, cTxt);
			}
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_PLAYER_INDIRECT) {
		_bPKLog(DEF_PKLOG_BYOTHER,iClientH,0,0) ;
		// ÷̾ ׾ ڰ ̴. ƹ  .
		// m_pClientList[iClientH]->m_iExp -= iDice(1, 50);
		// if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		// SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
	}
}

void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, bool bNotice)
{
 char cEquipPos, cHeroArmorType;
 short  sTemp;
 int   iTemp;

	if (m_pClientList[iClientH] == 0) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return;
	
	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == false) return;
	
	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = 0;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
	if (cEquipPos == DEF_EQUIPPOS_RHAND) {
		if(m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0){
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
				m_pClientList[iClientH]->m_cMagicMastery[94] = false;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
			}
		}
	}

	// ¾ÆÀÌÅÛÀÇ ÇØÁ¦À§Ä¡¿¡ ¸Â°Ô Apprº¯¼ö¸¦ Á¶Á¤ÇÑ´Ù.
	switch (cEquipPos) {
	case DEF_EQUIPPOS_RHAND:
		// ¿À¸¥¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹«±â·ùÀÌ´Ù. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0x0FFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		// V1.3 ¹«±â¼Óµµ Àç°è»ê <- ¸Ç¼ÕÀÌ´Ï±ñ 0
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		break;

	case DEF_EQUIPPOS_LHAND:
		// ¿Þ¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹æÆÐ·ùÀÌ´Ù. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xF0FFFFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		// ¾ç¼Õ¿¡ ÀåÂøÇÑ´ÙÁö¸¸ »ç½Ç ¿À¸¥¼Õ¿¡¸¸ µé°í ÀÖ´Ù. ¿Þ¼ÕÀº ºñ¾îÀÖ´Â »óÅÂ.
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0x0FFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		// °Ñ¿Ê È®Àå Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xFF7F;	
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFF0FFFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;	// ¸ÁÅä Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFF0FFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFF0FFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFF0FF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFFF0F; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;	// Åõ±¸ Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFFFF0; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_RELEASEALL:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// ¸ÁÅä Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFF0FFFF; // ¸ÁÅä »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
 	}

	//v1.432 Æ¯¼ö ´É·ÂÀÌ ºÎ¿©µÈ ¾ÆÀÌÅÛÀÌ¶ó¸é ÇÃ·¡±× ¼³Á¤ 
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		// °ø°Ý Æ¯¼ö ´É·Â ºñÆ® Å¬¸®¾î
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;	
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		// ¹æ¾î±¸ Æ¯¼ö ´É·Â ºñÆ® Å¬¸®¾î
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
	}
	
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;
	
	// ¿ÜÇüÀÌ ¹Ù²ï°ÍÀ» ¾Ë¸°´Ù.
	if (bNotice )
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

	// ÀÌ ¾ÆÀÌÅÛÀ» ÇØÁ¦ÇÏ´Â °Í¿¡ µû¸£´Â Æ¯¼ºÄ¡ÀÇ º¯È­¸¦ °è»êÇÑ´Ù. 
	CalcTotalItemEffect(iClientH, sItemIndex, true);
}


bool CGame::_bDecodeNpcConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iNpcConfigListIndex = 0;
 class CStrTok * pStrTok;

 char cData[50000] = {};
 DWORD lpNumberOfBytesRead;
 HANDLE hFile = CreateFile(pData, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
 DWORD dwFileSize = GetFileSize(hFile, 0);
 if (dwFileSize == -1) {
	 wsprintf(G_cTxt, "(X) CRITICAL ERROR! Cannot open configuration file(%s)!", pData);
	 PutLogList(pData);
	 return false;
 }

 SetFilePointer(hFile, 0, 0, FILE_BEGIN);

 ReadFile(hFile, cData, dwFileSize, &lpNumberOfBytesRead, 0);
 CloseHandle(hFile);

 pContents = new char[dwFileSize + 1];
 ZeroMemory(pContents, dwFileSize + 1);
 memcpy(pContents, cData, dwFileSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != 0 ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// NPC
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Too long Npc name.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					ZeroMemory(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, sizeof(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName));
					memcpy(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					// m_sType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					// m_iHitDice
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitDice = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_iDefenseRatio
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iDefenseRatio = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_iHitRatio
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitRatio = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_iMinBravery
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMinBravery = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_iExpDiceMin
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMin = atol(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_iExpDiceMax
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMax = atol(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_iGoldDiceMin
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMin = atol(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_iGoldDiceMax
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMax = atol(token);
					cReadModeB = 11;
					break;
				
				case 11:
					// m_cAttackDiceThrow
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceThrow = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// m_cAttackDiceRange
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceRange = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// m_cSize
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSize = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 15;
					break;
				
				case 15:
					// ActionLimit 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cActionLimit = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// Action Time
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwActionTime = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// ResistMagic
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cResistMagic = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// cMagicLevel
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cMagicLevel = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// cGenDayWeekLimit  // Æ¯Á¤ ¿äÀÏ¿¡¸¸ »ý¼ºµÇ´Â ¸ó½ºÅÍ¿©ºÎ 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cDayOfWeekLimit = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// cChatMsgPresence
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence = atoi(token);
					
					if (m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence == 1) {
						// ¿¬°áµÈ Ã¤ÆÃ ¸Þ½ÃÁö°¡ Á¸ÀçÇÑ´Ù. ³»¿ëÀ» ÀÐ¾î ÀúÀåÇÑ´Ù. 


					}
					cReadModeB = 21;
					break;

				case 21:
					// m_cTargetSearchRange
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cTargetSearchRange = atoi(token);
										
					cReadModeB = 22;
					break;		

				case 22:
					// Npc Àç »ý¼º±îÁöÀÇ ½Ã°£
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwRegenTime = atoi(token);
										
					cReadModeB = 23;
					break;

				case 23:
					// Attribute
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttribute = atoi(token);
										
					cReadModeB = 24;
					break;

				case 24:
					// Absorb Magic Damage
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAbsDamage = atoi(token);
					
					cReadModeB = 25;
					break;

				case 25:
					// Maximum Mana Point
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMaxMana = atoi(token);
					
					cReadModeB = 26;
					break;

				case 26:
					// MagicHitRatio
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMagicHitRatio = atoi(token);
									
					cReadModeB = 27;
					break;

				case 27:
					// AttackRange
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAttackRange = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					iNpcConfigListIndex++;
					break;
				}
				break;

			case 2:
				//m_iPlayerMaxLevel = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Npc", 3) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pNpcConfigList[iNpcConfigListIndex] = new class CNpc(" ");
			}

			/*if (memcmp(token, "world-server-max-level", 22) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}*/
		}
		token = pStrTok->pGet();
		//token = strtok(0, seps);
	}	

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPC configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) NPC(Total:%d) configuration - success!", iNpcConfigListIndex);
	PutLogList(cTxt);

	return true;
}

bool CGame::_bInitNpcAttr(class CNpc * pNpc, char * pNpcName, short sClass, char cSA)
{
 int i, iTemp;
 char cTmpName[21];
 int sTemp;
 double dV1, dV2, dV3;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pNpcName);

	for (i = 0; i < DEF_MAXNPCTYPES; i++) 
	if (m_pNpcConfigList[i] != 0) {
		if (memcmp(cTmpName, m_pNpcConfigList[i]->m_cNpcName, 20) == 0) {
			// °°Àº ÀÌ¸§À» °¡Áø NPC ¼³Á¤À» Ã£¾Ò´Ù. ¼³Á¤°ªÀ¸·Î ÃÊ±âÈ­ÇÑ´Ù.
			ZeroMemory(pNpc->m_cNpcName, sizeof(pNpc->m_cNpcName));
			memcpy(pNpc->m_cNpcName, m_pNpcConfigList[i]->m_cNpcName, 20);
			
			pNpc->m_sType  = m_pNpcConfigList[i]->m_sType;
			
			// HitDice¿¡ µû¶ó °ø½ÄÀÌ ´Ù¸£´Ù. ¸÷°£ÀÇ Â÷º°À» µÎ±â À§ÇÔ.
			if (m_pNpcConfigList[i]->m_iHitDice <= 5)
				 pNpc->m_iHP  = (iDice(m_pNpcConfigList[i]->m_iHitDice, 4) + m_pNpcConfigList[i]->m_iHitDice);
			else pNpc->m_iHP  = ((m_pNpcConfigList[i]->m_iHitDice * 4) + m_pNpcConfigList[i]->m_iHitDice + iDice(1, m_pNpcConfigList[i]->m_iHitDice));
			// v1.4 È®ÀÎÄÚµå
			if (pNpc->m_iHP == 0) pNpc->m_iHP = 1; 

			//50Cent - HP Bar
			pNpc->m_iMaxHP = pNpc->m_iHP;

			pNpc->m_iExpDiceMin		 = m_pNpcConfigList[i]->m_iExpDiceMin;
			pNpc->m_iExpDiceMax		 = m_pNpcConfigList[i]->m_iExpDiceMax;
			pNpc->m_iGoldDiceMin	 = m_pNpcConfigList[i]->m_iGoldDiceMin;
			pNpc->m_iGoldDiceMax	 = m_pNpcConfigList[i]->m_iGoldDiceMax;
			pNpc->m_iExp			 = (iDice(1, (m_pNpcConfigList[i]->m_iExpDiceMax - m_pNpcConfigList[i]->m_iExpDiceMin)) + m_pNpcConfigList[i]->m_iExpDiceMin);

			pNpc->m_iHitDice         = m_pNpcConfigList[i]->m_iHitDice;   
			pNpc->m_iDefenseRatio    = m_pNpcConfigList[i]->m_iDefenseRatio;
			pNpc->m_iHitRatio        = m_pNpcConfigList[i]->m_iHitRatio;
			pNpc->m_iMinBravery      = m_pNpcConfigList[i]->m_iMinBravery;
			pNpc->m_cAttackDiceThrow = m_pNpcConfigList[i]->m_cAttackDiceThrow;
			pNpc->m_cAttackDiceRange = m_pNpcConfigList[i]->m_cAttackDiceRange;
			pNpc->m_cSize            = m_pNpcConfigList[i]->m_cSize;
			pNpc->m_cSide            = m_pNpcConfigList[i]->m_cSide;
			pNpc->m_cActionLimit     = m_pNpcConfigList[i]->m_cActionLimit;
			pNpc->m_dwActionTime     = m_pNpcConfigList[i]->m_dwActionTime;
			pNpc->m_dwRegenTime      = m_pNpcConfigList[i]->m_dwRegenTime;
			pNpc->m_cResistMagic     = m_pNpcConfigList[i]->m_cResistMagic;
			pNpc->m_cMagicLevel      = m_pNpcConfigList[i]->m_cMagicLevel;
			pNpc->m_iMaxMana         = m_pNpcConfigList[i]->m_iMaxMana; // v1.4
			pNpc->m_iMana            = m_pNpcConfigList[i]->m_iMaxMana;
			pNpc->m_cChatMsgPresence = m_pNpcConfigList[i]->m_cChatMsgPresence;
			pNpc->m_cDayOfWeekLimit  = m_pNpcConfigList[i]->m_cDayOfWeekLimit;
			pNpc->m_cTargetSearchRange = m_pNpcConfigList[i]->m_cTargetSearchRange;
			
			switch (sClass) {
			case 43:
			case 44:
			case 45:
			case 46:
			case 47: // ÀüÀï¿ë À¯´ÖÀÇ °æ¿ì ¹«Á¶°Ç °ø°Ý¸¸ ÇÏ´Â Àü·«À» ±¸»ç.
				pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
				break;

			default: 
				pNpc->m_iAttackStrategy = iDice(1,10); 
				break;
			}
	
			pNpc->m_iAILevel		   = iDice(1,3);
			pNpc->m_iAbsDamage         = m_pNpcConfigList[i]->m_iAbsDamage;
			pNpc->m_iMagicHitRatio     = m_pNpcConfigList[i]->m_iMagicHitRatio;
			pNpc->m_iAttackRange       = m_pNpcConfigList[i]->m_iAttackRange;
			pNpc->m_cSpecialAbility    = cSA;
			pNpc->m_iBuildCount		   = m_pNpcConfigList[i]->m_iMinBravery;

			// v1.411 NPCÀÇ Æ¯¼ö È¿°ú °è»ê. °æÇèÄ¡ °¡Áß 
			switch (pNpc->m_cSpecialAbility) {
			case 1:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (DWORD)dV1;
				break;

			case 2:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 30.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (DWORD)dV1;
				break;
			
			case 3: // Absorbing Physical Damage
				if (pNpc->m_iAbsDamage > 0) {
					// ±âº»ÀûÀ¸·Î ¸¶¹ý ´ë¹ÌÁö Àý°¨ ´É·ÂÀÌ ÀÖ´Â °æ¿ì ¹°¸® ´ë¹ÌÁö Àý°¨Àº Àû¿ëµÇÁö ¾Ê´Â´Ù. 
					pNpc->m_cSpecialAbility = 0;
					cSA = 0;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage -= iTemp;
					if (pNpc->m_iAbsDamage < -90) pNpc->m_iAbsDamage = -90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)abs(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (DWORD)dV1;
				break;

			case 4: // Absorbing Magical Damage
				if (pNpc->m_iAbsDamage < 0) {
					// ±âº»ÀûÀ¸·Î ¹°¸® ´ë¹ÌÁö Àý°¨ ´É·ÂÀÌ ÀÖ´Â °æ¿ì ¸¶¹ý ´ë¹ÌÁö Àý°¨Àº Àû¿ëµÇÁö ¾Ê´Â´Ù. 
					pNpc->m_cSpecialAbility = 0;
					cSA = 0;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage += iTemp;
					if (pNpc->m_iAbsDamage > 90) pNpc->m_iAbsDamage = 90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (DWORD)dV1;
				break;

			case 5:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 15.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (DWORD)dV1;
				break;

			case 6:
			case 7:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 20.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (DWORD)dV1;
				break;

			case 8:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (DWORD)dV1;
				break;
			}

			// v1.411 À§Ä¡ ¿Å±è 
			pNpc->m_iNoDieRemainExp  = (pNpc->m_iExp) - (pNpc->m_iExp/3);

			// v1.411 NPCÀÇ Æ¯¼ö ´É·Â »ðÀÔ 
			pNpc->m_iStatus	= pNpc->m_iStatus & 0xFFFFF0FF;
			sTemp           = cSA;
			sTemp           = sTemp << 8;
			pNpc->m_iStatus = pNpc->m_iStatus | sTemp;
	
			// v1.41 NPCÀÇ Class»ðÀÔ.
			pNpc->m_iStatus			   = pNpc->m_iStatus & 0xFFFFFFF0;
			pNpc->m_iStatus            = pNpc->m_iStatus | (sClass);
	
			return true;
		}
	}

	// NPC¸®½ºÆ®¸¦ ¸ðµÎ °Ë»öÇßÀ½¿¡µµ ¹ß°ßµÇÁö ¾Ê¾Ò´Ù. 
	return false;
}

/*********************************************************************************************************************
**  int CGame::iDice(int iThrow, int iRange)																		**
**  description			:: produces a random number between the throw and range										**
**  last updated		:: November 20, 2004; 10:24 PM; Hypnotoad													**
**	return value		:: int																						**
**********************************************************************************************************************/
DWORD CGame::iDice(DWORD iThrow, DWORD iRange)
{
 int i;
 DWORD iRet;

	if (iRange <= 0) return 0;
	iRet = 0;
	for (i = 1; i <= iThrow; i++) {
		iRet += (rand() % iRange) + 1;
	}
	return iRet;
}

void CGame::CalculateGuildEffect(int iVictimH, char cVictimType, short sAttackerH)
{
	// ### ERROR POINT! ÀÓ½Ã·Î ¸·¾Æ ³í´Ù.
	return;
}

void CGame::TimeManaPointsUp(int iClientH)
{
 int iMaxMP, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled ) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] ) return;

	iMaxMP = iGetMaxMP(iClientH); // v1.4
	if (m_pClientList[iClientH]->m_iMP < iMaxMP) {
		iTotal = iDice(1, (m_pClientList[iClientH]->m_iMag+ m_pClientList[iClientH]->m_iAngelicMag));
		if (m_pClientList[iClientH]->m_iAddMP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iMP += iTotal;
		
		if (m_pClientList[iClientH]->m_iMP > iMaxMP) 
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);
	}
}

// 05/29/2004 - Hypnotoad - fixed infinite sp bug
void CGame::TimeStaminarPointsUp(int iClientH)
{
	int iMaxSP, iTotal=0;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled ) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] ) return; // v1.4 ÃÃ—Ã€ÂºÃƒÂ´Ã‡ÃÂ±Ã¢ Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã«ÃÃŸÂ¿Â¡Â´Ã‚ Â½ÂºÃ…Ã—Â¹ÃŒÂ³ÃŠ Â¿Ã€Â¸Â£ÃÃ¶ Â¾ÃŠÃ€Â½.

	iMaxSP = iGetMaxSP(iClientH);
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) {

		iTotal = iDice(1, (m_pClientList[iClientH]->m_iVit/3)); // Staminar Point´Â 10ÃÊ¸¶´Ù 1D(Vit/3)¾¿ ¿Ã¶ó°£´Ù.
		if (m_pClientList[iClientH]->m_iAddSP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}
	
		// v2.03 ·¹º§ 60 ÀÌÇÏ´Â Á¤±âÀûÀ¸·Î ½ºÅ×¹Ì³ª°¡ ¸¹ÀÌ Âù´Ù.
		if (m_pClientList[iClientH]->m_iLevel <= 20) {
			iTotal += 15;
		} else if ( m_pClientList[iClientH]->m_iLevel <= 40) {
			iTotal += 10;
		}  else if ( m_pClientList[iClientH]->m_iLevel <= 60) { 
			iTotal += 5;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP) 
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
	}
}

void CGame::DelayEventProcess()
{

}

void CGame::SendGuildMsg(int iClientH, WORD wNotifyMsgType, short sV1, short sV2, char * pString)
{
 char cData[500];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 int i, iRet;
	
	// °°Àº ±æµå¿øµé¿¡°Ô¸¸ º¸³»´Â ¸Þ½ÃÁöµé
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ( (m_pClientList[i] != 0) && 
		 (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) ) {

		// ### BUG POINT À§Ä¡°¡ Àß¸øµÇ¾î Æ÷ÀÎÅÍ ¿¬»êÀÌ Àß¸øµÇ¾ú´Ù. 
		ZeroMemory(cData, sizeof(cData));

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wNotifyMsgType;
	
		cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

		// °°Àº ±æµå ÀÌ¸§À» °®°í ÀÖ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£¾Ò´Ù.
		switch (wNotifyMsgType) {
		case DEF_NOTIFY_GUILDDISBANDED:
			if (i == iClientH) break; // <-- ±æµå ¸¶½ºÅÍ ÀÚ½Å¿¡°Ô´Â ¸Þ½ÃÁö¸¦ º¸³»Áö ¾Ê´Â´Ù.
			// ±æµå ÇØ»ê Åëº¸¿¡ ÇØ´ç Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå ·©Å©¸¦ Å¬¸®¾îÇÑ´Ù. 
			memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
			cp += 20;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 26);
			// ÇØ´ç Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå³»¿ëÀ» Å¬¸®¾îÇÑ´Ù. @@@@@@@
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1;
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_NOTIFY_EVENTMSGSTRING:
			// ±æµå¿øµé¿¡°Ô Àü´ÞµÇ´Â ÀÌº¥Æ® ¸Þ½ÃÁö ½ºÆ®¸µ 
			strcpy(cp, pString);
			cp += strlen(pString);

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
			break;

		case DEF_NOTIFY_NEWGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;

		case DEF_NOTIFY_DISMISSGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;
		}
	
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(i, true, true);
			return;
		}
	}

}

void CGame::GuildNotifyHandler(char * pData, DWORD dwMsgSize)
{
 // ´Ù¸¥ °ÔÀÓ¼­¹ö·ÎºÎÅÍ ±æµå ÀÌº¥Æ®°¡ µµÂøÇß´Ù. 
 char * cp, cCharName[11], cGuildName[21];

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	// ¾ÆÁ÷ ±¸ÇöµÇÁö ¾Ê¾Ò´Ù. 
}

void CGame::ToggleCombatModeHandler(int iClientH)
{
	short sAppr2;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled ) return;
	// Á×ÀºÃ´ÇÏ±â³ª Á×Àº »óÅÂ¿¡¼­´Â º¯È¯ÇÒ ¼ö ¾ø´Ù.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] ) return;

	sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

	m_pClientList[iClientH]->m_bIsAttackModeChange = true; // v2.172


	if (sAppr2 == 0) {
		// ºñÀüÅõ ¸ðµå¿´´Ù. ÀüÅõ¸ðµå·Î ¹Ù²Û´Ù.
		m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
	}
	else {
		// ÀüÅõ ¸ðµå¿´´Ù. ºñÀüÅõ¸ðµå·Î ¹Ù²Û´Ù.
		m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);
	}

	// Ä³¸¯ÅÍÀÇ ¿ÜÇüÀÌ ¹Ù²î¾úÀ¸¹Ç·Î ÀÌº¥Æ®¸¦ Àü´ÞÇÑ´Ù.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

}

void CGame::OnGateSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 //int   iRet;
	//
	//if (m_pGateSock == 0) return;

	//iRet = m_pGateSock->iOnSocketEvent(wParam, lParam);

	//switch (iRet) {
	//case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
	//	PutLogList("(!!!) Gate-socket connected!");
	//	SendMsgToGateServer(MSGID_REQUEST_REGISTERGAMESERVER, 0);
	//	break;
	//case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
	//	// °ÔÀÌÆ®¼­¹ö·ÎÀÇ ¿¬°áÀÌ ÀÌ·ç¾î Á³À¸¹Ç·Î °ÔÀÓ¼­¹ö µî·Ï ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
	//	// v1.41 gate-socketÀ» Àç¿¬°áÇÒ ¶§ Ä«¿îÆÃ ÇÏ´Â º¯¼ö. ¼­¹ö ÀÛµ¿ µµÁß gate-socketÀÌ ¼ÒÄÏ¿¡·¯·Î ²÷±â¸é °ð¹Ù·Î ÀçÁ¢¼ÓÀ» 
	//	// ½ÃµµÇÏ¸ç ÀÌ °ªÀÌ ÀÏÁ¤Ä¡ ÀÌ»óÀÌ µÇ¸é ¿¬°á ½ÇÆÐ·Î °£ÁÖµÇ¾î ÀÚµ¿ ¼­¹ö ¼Ë´Ù¿î ¸ðµå(4)·Î µé¾î°£´Ù. 
	//	m_iGateSockConnRetryTimes = 0;
	//	break;
	//
	//case DEF_XSOCKEVENT_READCOMPLETE:
	//	// ¸Þ½ÃÁö°¡ ¼ö½ÅµÇ¾ú´Ù.
	//	OnGateRead();
	//	break;
	//
	//case DEF_XSOCKEVENT_BLOCK:
	//	break;
	//
	//case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	//	// È®ÀÎÄÚµå°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â´Ù.
	//case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	//	// ¼ö½ÅÇØ¾ß ÇÒ ¸Þ½ÃÁö Å©±â°¡ ¹öÆÛº¸´Ù Å©´Ù.	Á¾·áÇØ¾ß¸¸ ÇÑ´Ù.
	//case DEF_XSOCKEVENT_SOCKETERROR:
	//	// ¼ÒÄÏ¿¡ ¿¡·¯°¡ ³µ´Ù.
	//case DEF_XSOCKEVENT_SOCKETCLOSED:
	//	// ¼ÒÄÏÀÌ ´ÝÇû´Ù.
	//	delete m_pGateSock;
	//	m_pGateSock = 0;
	//	PutLogList("(!!!) Gate-socket connection lost!");
	//	m_bIsGateSockAvailable = false;

	//	// v1.41 Gate Server·ÎÀÇ Àç¿¬°á ½Ãµµ 
	//	m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	//	m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
	//	m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	//	// v1.41 ¿¬°á ½Ã°£ Ã¼Å©¿ë 
	//	m_iGateSockConnRetryTimes = 1;

	//	wsprintf(G_cTxt, "(!!!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	//	PutLogList(G_cTxt);

	//	break;
	//}
}

void CGame::OnGateRead()
{
 //DWORD dwMsgSize;
 //char * pData, cKey;

	//pData = m_pGateSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	//if (bPutMsgQuene(DEF_MSGFROM_GATESERVER, pData, dwMsgSize, 0, cKey) == false) {
	//	// ¸Þ½ÃÁö Å¥¿¡ ÀÌ»óÀÌ »ý°å´Ù. Ä¡¸íÀûÀÎ ¿¡·¯.
	//	PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	//}	
}

void CGame::SendMsgToGateServer(DWORD dwMsg, int iClientH, char * pData)
{
 //DWORD * dwp;
 //WORD  * wp;
 //int     iRet, i;
 //char    cData[1000], cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;

	//if (m_pGateSock == 0) {
	//	PutLogList("(!) SendMsgToGateServer fail - Socket to Gate-Server not available.");
	//	return;
	//}

	//ZeroMemory(cData, sizeof(cData));
	//ZeroMemory(cCharName, sizeof(cCharName));
	//ZeroMemory(cAccountName, sizeof(cAccountName));
	//ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	//ZeroMemory(cAddress,  sizeof(cAddress));
	//ZeroMemory(cGuildName, sizeof(cGuildName));

	//switch (dwMsg) {
	//// New 07/05/2004
	//case MSGID_PARTYOPERATION:
	//	iRet = m_pGateSock->iSendMsg(pData, 50);
	//	break;

	//case MSGID_SERVERSTOCKMSG:
	//	iRet = m_pGateSock->iSendMsg(pData, m_iIndexGSS+1);
	//	break;
	//
	//case MSGID_ITEMLOG:
	//	// ¾ÆÀÌÅÛ Àü´Þ ·Î±×´Ù. »ç¿ëÇÏÁö ¾ÊÀ½.
	//	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_ITEMLOG;
	//	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;
	//	
	//	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	//	memcpy(cp, pData, 47);
	//	cp += 47;

	//	iRet = m_pGateSock->iSendMsg(cData, 53);
	//	break;
	//
	//case MSGID_REQUEST_REGISTERGAMESERVER:
	//	// °ÔÀÌÆ® ¼­¹ö¿¡°Ô °ÔÀÓ¼­¹ö µî·ÏÀ» ¿äÃ»ÇÑ´Ù.
	//	wsprintf(cTxt, "(!) Try to register game server(%s) - GateServer", m_cServerName);
	//	PutLogList(cTxt);
	//	
	//	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
	//	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;
	//	
	//	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	//	memcpy(cAccountName, m_cServerName, 10);
	//	if (m_iGameServerMode == 1)
	//	{
	//		memcpy(cAddress, m_cGameServerAddrInternal, strlen(m_cGameServerAddrInternal));
	//	}
	//	if (m_iGameServerMode == 2)
	//	{
	//		memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
	//	}

	//	memcpy(cp, cAccountName, 10);
	//	cp += 10;

	//	memcpy(cp, cAddress, 16);
	//	cp += 16;

	//	wp  = (WORD *)cp;
	//	*wp = m_iGameServerPort;
	//	cp += 2;

	//	*cp = m_iTotalMaps;
	//	cp++;

	//	for (i = 0; i < m_iTotalMaps; i++) {
	//		memcpy(cp, m_pMapList[i]->m_cName, 11);
	//		cp += 11;
	//	}
	//	
	//	dwp = (DWORD *)cp;
	//	*dwp = (DWORD)GetCurrentProcessId();	 // ÇÁ·Î¼¼½º ÇÚµéÀ» ±â·ÏÇÑ´Ù.

	//	cp += 4;
	//	dwp = (DWORD *)cp;
	//	*dwp = DEF_BUILDDATE;

	//	iRet = m_pGateSock->iSendMsg(cData, 43 + m_iTotalMaps*11);
	//	break;

	//case MSGID_GAMESERVERALIVE:
	//	// Á¤±âÀûÀ¸·Î °ÔÀÓ ¼­¹öÀÇ Á¤º¸¸¦ Àü¼Û 
	//	// ¸¸¾à ·Î±× ¼­¹ö¿ÍÀÇ ¼ÒÄÏ ¿¬°áÀÌ ²÷¾îÁ³´Ù¸é ¸Þ½ÃÁö¸¦ º¸³»Áö ¾Ê¾Æ ¼­¹ö¿¡ ÀÌ»óÀÌ »ý°åÀ½À» ¾Ë¸®°Ô À¯µµÇÑ´Ù.
	//	if (m_bIsLogSockAvailable == false) return;
	//	
	//	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	//	*dwp = MSGID_GAMESERVERALIVE;
	//	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	//	*wp  = DEF_MSGTYPE_CONFIRM;

	//	cp  = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	//	wp  = (WORD *)cp;
	//	*wp = m_iTotalClients;
	//	cp += 2;
	//	
	//	iRet = m_pGateSock->iSendMsg(cData, 8);
	//	break;
	//}

	//switch (iRet) {
	//case DEF_XSOCKEVENT_QUENEFULL:
	//case DEF_XSOCKEVENT_SOCKETERROR:
	//case DEF_XSOCKEVENT_CRITICALERROR:
	//case DEF_XSOCKEVENT_SOCKETCLOSED:
	//	// °ÔÀÌÆ® ¼­¹ö·Î ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù.
	//	PutLogList("(***) Socket to Gate-Server crashed! Critical error!");
	//	delete m_pGateSock;
	//	m_pGateSock = 0;
	//	m_bIsGateSockAvailable = false;

	//	// v1.41 Gate Server·ÎÀÇ Àç¿¬°á ½Ãµµ: ¼­¹ö¸¦ ¼Ë´Ù¿î ÇÏ´Â °ÍÀÌ ¾Æ´Ï´Ù. 
	//	m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	//	m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
	//	m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	//	// v1.41 ¿¬°á ½Ã°£ Ã¼Å©¿ë 
	//	m_iGateSockConnRetryTimes = 1;	

	//	wsprintf(G_cTxt, "(!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	//	PutLogList(G_cTxt);

	//	return;
	//}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is casting magic
//  last updated		:: October 29, 2004; 6:51 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
{
 char  cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 		
	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled ) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;
	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	
	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 )	{
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);		
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = 0;
	}

	m_pClientList[iClientH]->m_cDir = cDir;
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

/*********************************************************************************************************************
**  void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, bool bItemEffect, int iV1)			**
**  description			:: handles all magic related items/spells													**
**  last updated		:: November 22, 2004; 5:45 PM; Hypnotoad													**
**	return value		:: void																						**
**  commentary			::	-	added 3.51 casting detection														**
**							-	updated it so civilians can only cast certain spells on players and vice versa		**
**							-	fixed bug causing spell to be cast when mana is below required amount				**
**********************************************************************************************************************/
int  _tmp_iMCProb[]        = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int  _tmp_iMLevelPenalty[] = {0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40};
void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, bool bItemEffect, int iV1)
{
	short  * sp, sX, sY, sOwnerH, sMagicCircle, rx, ry, sRemainItemSprite, sRemainItemSpriteFrame, sLevelMagic, sTemp;
	char   * cp, cData[120], cDir, cOwnerType, cName[11], cItemName[21], cNpcWaypoint[11], cName_Master[11], cNpcName[21], cRemainItemColor, cScanMessage[256];
	double dV1, dV2, dV3, dV4;
	int    i, iErr, iRet, ix, iy, iResult, iDiceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus;
	int    tX, tY, iManaCost, iMagicAttr;
	class  CItem * pItem;
	DWORD * dwp, dwTime;
	WORD  * wp, wWeaponType;
	short sEqStatus;
	int iMapSide = 0;
	short sIDNum;
	DWORD dwAttr;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_bMagicConfirm = true;
	
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return;

	if (((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) < 1000) && (bItemEffect == 0)) {
		try
		{
			wsprintf(G_cTxt, "3.51 Detection: (%s) Player: (%s) - Magic casting speed is too fast! Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch(...)
		{
		}
		return;
	}
	m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

	if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == 0) return;

	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == 0) return;

	if ((bItemEffect == false) && (m_pClientList[iClientH]->m_cMagicMastery[sType] != 1)) return;

	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled == false) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
	//if ((var_874 ) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap ) && (m_pMagicConfigList[sType]->m_sType != 8)) return;

	if (((m_pClientList[iClientH]->m_iStatus & 0x100000) != 0) && (bItemEffect != true)) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, 0);
			return;
	}

	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);		
		if ((wWeaponType >= 34) && (wWeaponType <= 39)) {
		}
		else return;
	}

	if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND]   != -1) ||
		(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)) return;

	if ((m_pClientList[iClientH]->m_iSpellCount > 1) && (bItemEffect == false)) {
		try
		{
			wsprintf(G_cTxt, "TSearch Spell Hack: (%s) Player: (%s) - casting magic without precasting.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch(...)
		{
		}
		return;
	}

	if (m_pClientList[iClientH]->m_bInhibition ) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, 0);
		return;
	}

	/*if (((m_pClientList[iClientH]->m_iUninteruptibleCheck - (iGetMaxHP(iClientH)/10)) > (m_pClientList[iClientH]->m_iHP)) && (m_pClientList[iClientH]->m_bMagicItem == false)) {
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, 0,
			0, 0, 0, 0, 0, 0);
		return;
	}*/
	
	if (m_pMagicConfigList[sType]->m_sType == 32) { // Invisiblity
		sEqStatus = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sEqStatus != -1) && (m_pClientList[iClientH]->m_pItemList[sEqStatus] != 0)) {
			if((m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 866)) {
				bItemEffect = true;
			}
		}
	}

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	sMagicCircle = (sType / 10) + 1;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] == 0)
		dV1 = 1.0f;
	else dV1 = (double)m_pClientList[iClientH]->m_cSkillMastery[4];

	if (bItemEffect ) dV1 = (double)100.0f;
	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];
	dV1 = dV2 * dV3;
	iResult = (int)dV1;

	if ((m_pClientList[iClientH]->m_iInt+ m_pClientList[iClientH]->m_iAngelicInt) > 50)
		iResult += ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) - 50)/2;

	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;
			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			iResult += 5*abs(sMagicCircle - sLevelMagic);
		}
	}

	switch (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus) {
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break;
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}

	if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 10) {
		dV1 = (double)iResult;
		dV2 = (double)(m_pClientList[iClientH]->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1 + dV2;
		iResult = (int)dV3;
	}

	if (iResult <= 0) iResult = 1;

	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);

	iManaCost = m_pMagicConfigList[sType]->m_sValue1;
	if ((m_pClientList[iClientH]->m_bIsSafeAttackMode ) && 
		(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)) {
			iManaCost += (iManaCost / 2) - (iManaCost / 10);
		}
		
		if (m_pClientList[iClientH]->m_iManaSaveRatio > 0) {
			dV1 = (double)m_pClientList[iClientH]->m_iManaSaveRatio;
			dV2 = (double)(dV1 / 100.0f);
			dV3 = (double)iManaCost;
			dV1 = dV2 * dV3;	
			dV2 = dV3 - dV1; 
			iManaCost = (int)dV2;

			if (iManaCost <= 0) iManaCost = 1;
		}

		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 34) {
			iManaCost += 20;
		}

		if (iResult < 100) {
			iDiceRes = iDice(1,100);
			if (iResult < iDiceRes) {
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, 0);
				return;
			}
		}

		if (((m_pClientList[iClientH]->m_iHungerStatus <= 10) || (m_pClientList[iClientH]->m_iSP <= 0)) && (iDice(1,1000) <= 100)) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, 0);
			return;	
		}

		if (m_pClientList[iClientH]->m_iMP < iManaCost) {
			return;
		}

		iResult = m_pClientList[iClientH]->m_cSkillMastery[4];
		if ((m_pClientList[iClientH]->m_iMag+ m_pClientList[iClientH]->m_iAngelicMag) > 50) iResult += ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) - 50);

		sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
		if (sMagicCircle != sLevelMagic) {
			if (sMagicCircle > sLevelMagic) {
				dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
				dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
				dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
				dV4 = (dV1 / dV3)*dV2;

				iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
			}
			else {
				iResult += 5*abs(sMagicCircle - sLevelMagic);
			}
		}

		iResult += m_pClientList[iClientH]->m_iAddAR;
		if (iResult <= 0) iResult = 1;

		if (sType >= 80) iResult += 10000;

		if (m_pMagicConfigList[sType]->m_sType == 28) {
			iResult += 10000;
		}
		
		if (m_pMagicConfigList[sType]->m_cCategory == 1) {
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
		}

		iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;
		if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = 0;
		}

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if ((m_bIsCrusadeMode == false) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
			if ((m_pClientList[iClientH]->m_bIsPlayerCivil != true) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil )) {
				if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) return;
			}
			else if ((m_pClientList[iClientH]->m_bIsPlayerCivil ) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil == false)) {
				switch (m_pMagicConfigList[sType]->m_sType) {
					case 1:  // DEF_MAGICTYPE_DAMAGE_SPOT
					case 4:  // DEF_MAGICTYPE_SPDOWN_SPOT 4
					case 8:  // DEF_MAGICTYPE_TELEPORT 8
					case 10: // DEF_MAGICTYPE_CREATE 10
					case 11: // DEF_MAGICTYPE_PROTECT 11
					case 12: // DEF_MAGICTYPE_HOLDOBJECT 12
					case 16: // DEF_MAGICTYPE_CONFUSE
					case 17: // DEF_MAGICTYPE_POISON
					case 32: // DEF_MAGICTYPE_RESURRECTION
					case DEF_MAGICTYPE_HASTE:
						return;
				}
			}
		}

		if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
			switch (m_pMagicConfigList[sType]->m_sType) {
			case DEF_MAGICTYPE_HASTE:
				switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (sOwnerH == iClientH) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HASTE] != 0) goto MAGIC_NOEFFECT;
						m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HASTE] = (char)m_pMagicConfigList[sType]->m_sValue4;
						SetHasteFlag(sOwnerH, cOwnerType, true);
						break;

					case DEF_OWNERTYPE_NPC:
						goto MAGIC_NOEFFECT;
						break;
					}
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HASTE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
						sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

					if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HASTE, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
					break;
				}
				break;
				case DEF_MAGICTYPE_DAMAGE_SPOT:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
					}
					break;
				
				case DEF_MAGICTYPE_HPUP_SPOT:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
					}

					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						}
					}
					break;				
				
				case DEF_MAGICTYPE_SPDOWN_SPOT:
					break;

				case DEF_MAGICTYPE_SPDOWN_AREA:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
					break;
				
				case DEF_MAGICTYPE_POLYMORPH:
					// ÂºÂ¯Â½Ã… Â¸Â¶Â¹Ã½. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (1) { // bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								// Â¿Ã¸Â·Â¡ Ã…Â¸Ã€Ã”Ã€Â» Ã€ÃºÃ€Ã¥Ã‡Ã˜ Â³ÃµÂ´Ã‚Â´Ã™.
								m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
								// Â¹Ã™Â²Ã¯ Â¿ÃœÃ‡Ã¼Ã€Â» Ã…Ã«ÂºÂ¸Ã‡Ã˜ ÃÃ˜Â´Ã™.
								m_pClientList[sOwnerH]->m_sType = 18;
								SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								// Â¿Ã¸Â·Â¡ Ã…Â¸Ã€Ã”Ã€Â» Ã€ÃºÃ€Ã¥Ã‡Ã˜ Â³ÃµÂ´Ã‚Â´Ã™.
								m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
								// Â¹Ã™Â²Ã¯ Â¿ÃœÃ‡Ã¼Ã€Â» Ã…Ã«ÂºÂ¸Ã‡Ã˜ ÃÃ˜Â´Ã™.
								m_pNpcList[sOwnerH]->m_sType = 18;
								SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
								break;
						}

						// ÂºÂ¯Â½Ã… ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_POLYMORPH, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

						// ÃˆÂ¿Â°ÃºÂ°Â¡ Â»Ã½Â°Ã¥Ã€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
						if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POLYMORPH, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
					}
					break;

				// 05/20/2004 - Hypnotoad - Cancellation
				case DEF_MAGICTYPE_CANCELLATION:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0) && (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)) {

						// Removes Invisibility Flag 0x0010
						SetInvisibilityFlag(sOwnerH, cOwnerType, false);

						// Removes Illusion Flag 0x01000000
						SetIllusionFlag(sOwnerH, cOwnerType, false);

						// Removes Defense Shield Flag 0x02000000
						// Removes Great Defense Shield Flag 0x02000000
						SetDefenseShieldFlag(sOwnerH, cOwnerType, false);

						// Removes Absolute Magic Protection Flag 0x04000000	
						// Removes Protection From Magic Flag 0x04000000
						SetMagicProtectionFlag(sOwnerH, cOwnerType, false);

						// Removes Protection From Arrow Flag 0x08000000
						SetProtectionFromArrowFlag(sOwnerH, cOwnerType, false);

						// Removes Illusion Movement Flag 0x00200000
						SetIllusionMovementFlag(sOwnerH, cOwnerType, false);

						// Removes Berserk Flag 0x0020
						SetBerserkFlag(sOwnerH, cOwnerType, false);

						//Removes ice-added 
						SetIceFlag(sOwnerH, cOwnerType, false);

						//Remove paralyse
						
						bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
						sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
						
						bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
						sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
					
						bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INHIBITION);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
						sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
					
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
					
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_BERSERK);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
						
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
						
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

						// Update Client
						SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN:
					//  ó ʴ´.
					// ֺ  ȿ 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// ڽŵ    .
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
							//  ôϰ ִ ÷̾.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							}
						}
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_LINEAR:
					// Ã€ÃÃÃ·Â¼Â± Â»Ã³Â¿Â¡ Ã€Ã–Â´Ã‚ Â¸Ã±Ã‡Â¥Â¸Â¦ Â¸Ã°ÂµÃŽ Â°Ã¸Â°ÃÃ‡Ã‘Â´Ã™.
					sX = m_pClientList[iClientH]->m_sX;
					sY = m_pClientList[iClientH]->m_sY;

					for (i = 2; i < 10; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						// tx, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
							}

							// tx-1, ty
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
								}

								// tx+1, ty
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
									}

									// tx, ty-1
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
										(m_pClientList[sOwnerH]->m_iHP > 0) ) {
											// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
										}

										// tx, ty+1
										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
											Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
											(m_pClientList[sOwnerH]->m_iHP > 0) ) {
												// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
											}

											if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
								}
						}

						// dX, dY
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
							}
							break;

				// v2.16 2002-5-23 Â°Ã­Â±Â¤Ã‡Ã¶ 
				case DEF_MAGICTYPE_ICE_LINEAR:
					// Ã€ÃÃÃ·Â¼Â± Â»Ã³Â¿Â¡ Ã€Ã–Â´Ã‚ Â¸Ã±Ã‡Â¥Â¸Â¦ Â¸Ã°ÂµÃŽ Â¾Ã³Â¸Â®Â¸Ã§ Â°Ã¸Â°ÃÃ‡Ã‘Â´Ã™.
					sX = m_pClientList[iClientH]->m_sX;
					sY = m_pClientList[iClientH]->m_sY;

					for (i = 2; i < 10; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						// tx, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
									if (m_pClientList[sOwnerH]->m_iHP < 0) goto MAGIC_NOEFFECT;
									// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, true);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
											// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
											SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, true);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
										}
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
									// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, true);
													// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
													// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
													SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, true);
													// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
												}
											}
											break;
									}
									//
								}
							}

							// tx-1, ty
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
								// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, true);
												// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
												// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
												SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, true);
												// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
											}
										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
										// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
												if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, true);
														// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
														// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
														SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
													}
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
													if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, true);
														// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
													}
												}
												break;
										}
										//
									}
								}

								// tx+1, ty
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
									// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, true);
													// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
													// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
													SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, true);
													// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
												}
											}
											break;
									}
									//
								}

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
											// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
													// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
													if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
														if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, true);
															// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
															// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
															SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
														}
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
													if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
														if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, true);
															// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
														}
													}
													break;
											}
											//
										}
									}

									// tx, ty-1
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
										// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
												if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, true);
														// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
														// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
														SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
													}
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
													if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, true);
														// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
													}
												}
												break;
										}
										//
									}

									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
										(m_pClientList[sOwnerH]->m_iHP > 0) ) {
											// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
												// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
												switch (cOwnerType) {
													case DEF_OWNERTYPE_PLAYER:
														if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
														// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
														if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
															if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																SetIceFlag(sOwnerH, cOwnerType, true);
																// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
																bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																	sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
																// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
																SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
															}
														}
														break;

													case DEF_OWNERTYPE_NPC:
														if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
														if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
															if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																SetIceFlag(sOwnerH, cOwnerType, true);
																// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
																bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																	sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
															}
														}
														break;
												}
												//
											}
										}

										// tx, ty+1
										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
											Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
											// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
													// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
													if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
														if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, true);
															// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
															// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
															SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
														}
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
													if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
														if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, true);
															// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
														}
													}
													break;
											}
											//
										}

										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
											(m_pClientList[sOwnerH]->m_iHP > 0) ) {
												// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
													// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
													switch (cOwnerType) {
														case DEF_OWNERTYPE_PLAYER:
															if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
															// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
															if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
																if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																	SetIceFlag(sOwnerH, cOwnerType, true);
																	// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
																	bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																		sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
																	// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
																	SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
																}
															}
															break;

														case DEF_OWNERTYPE_NPC:
															if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
															if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
																if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																	SetIceFlag(sOwnerH, cOwnerType, true);
																	// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
																	bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																		sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
																}
															}
															break;
													}
													//
												}
											}

											if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
								// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, true);
												// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
												// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
												SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, true);
												// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
											}
										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
										// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
												if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, true);
														// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
														// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
														SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
													}
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
													if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, true);
														// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
													}
												}
												break;
										}
										//
									}
								}
						}

						// dX, dY
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
									// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, true);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
											// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
											SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, true);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
										}
									}
									break;
							}
							//
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
									// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, true);
													// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
													// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
													SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, true);
													// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
												}
											}
											break;
									}
									//
								}
							}
							break;


				case DEF_MAGICTYPE_INHIBITION:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INHIBITION ] != 0) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 5) goto MAGIC_NOEFFECT;
						if (m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) goto MAGIC_NOEFFECT;
						if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;
						//if (m_pClientList[sOwnerH]->m_iAdminUserLevel != 0) goto MAGIC_NOEFFECT;
						m_pClientList[sOwnerH]->m_bInhibition = true;
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
						break;
					}
					break;
	
				
				case DEF_MAGICTYPE_TREMOR: // v1.4 ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°ÃºÂ¿Â¡ Ã€ÃŒÂ¾Ã® Ã€ÃœÂ·Ã¹ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã€Ã–Â´Ã™.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {
							// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
						}

						// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
							for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
								// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
									}
							}
							break;

				case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
					// ÃÃ·Â°ÃÃ€Âº ÃƒÂ³Â¸Â®Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
					// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
								}
						}
						break;

				case DEF_MAGICTYPE_SPUP_AREA:
					// SpÂ°Â¡ Â»Ã³Â½Ã‚Ã‡Ã‘Â´Ã™.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					// Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Ã€ÃŒ Ã‡ÃŠÂ¿Ã¤Â¾Ã¸Â´Ã™. 
					Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							// Â¸Â¶Â¹Ã½Ã€ÃºÃ‡Ã—Ã€ÃŒ Ã‡ÃŠÂ¿Ã¤ Â¾Ã¸Â´Ã™.
							Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}
						break;

						// v2.16 2002-5-23 °í±¤Çö 
				case DEF_MAGICTYPE_DAMAGE_LINEAR_SPDOWN:
					// ÀÏÁ÷¼± »ó¿¡ ÀÖ´Â ¸ñÇ¥¸¦ ¸ðµÎ ¾ó¸®¸ç °ø°ÝÇÑ´Ù.
					sX = m_pClientList[iClientH]->m_sX;
					sY = m_pClientList[iClientH]->m_sY;

					for (i = 2; i < 10; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						// tx, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
							// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
									// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
									// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
											}
											break;
									}
									//
								}
							}

							// tx-1, ty
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
								// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {

											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
										// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
												}
												break;
										}
										//
									}
								}

								// tx+1, ty
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
									// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
											}
											break;
									}
									//
								}

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
											// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
													// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
														ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
														ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
													}
													break;
											}
											//
										}
									}

									// tx, ty-1
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
										// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
												}
												break;
										}
										//
									}

									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
										(m_pClientList[sOwnerH]->m_iHP > 0) ) {
											// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
												// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
												switch (cOwnerType) {
													case DEF_OWNERTYPE_PLAYER:
														if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
														// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
														if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
															Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
															Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
															ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
														}
														break;

													case DEF_OWNERTYPE_NPC:
														if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
														if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
															Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
															Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
															ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
														}
														break;
												}
												//
											}
										}

										// tx, ty+1
										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
											Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
											// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
													// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
														ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
														ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
													}
													break;
											}
											//
										}

										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
											(m_pClientList[sOwnerH]->m_iHP > 0) ) {
												// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
													// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
													switch (cOwnerType) {
														case DEF_OWNERTYPE_PLAYER:
															if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
															// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
															if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
																Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
																Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
																ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
															}
															break;

														case DEF_OWNERTYPE_NPC:
															if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
															if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
																Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
																Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
																ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
															}
															break;
													}
													//
												}
											}

											if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					// ÁÖº¯ °ø°Ý È¿°ú 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
								// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
										// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
												}
												break;
										}
										//
									}
								}
						}

						// dX, dY
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
							// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
									// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
									}
									break;
							}
							//
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
									// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);

											}
											break;
									}
									//
								}
							}
							break;

				case DEF_MAGICTYPE_TELEPORT:
					// Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® Â¸Â¶Â¹Ã½. sValue 4Â¿Â¡ ÂµÃ»Â¶Ã³Â¼Â­ Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® Â¸Ã±Ã€Ã»ÃÃ¶Â°Â¡ Â°Ã¡ÃÂ¤ÂµÃˆÂ´Ã™.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					// Ã€ÃšÂ½Ã…Ã€ÃŒ Â¼Ã’Â¼Ã“ÂµÃˆ Â¸Â¶Ã€Â»Â·ÃŽ Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â®. RecallÃ€ÃŒÂ´Ã™.
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH) ) {
						// Ã€ÃšÂ½Ã…Â¿ÃœÂ¿Â¡Â´Ã‚ RecallÃ‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
							RequestTeleportHandler(iClientH, "1   ");
					}
					break;
					}
					break;

				case DEF_MAGICTYPE_SUMMON:
					// Â¼Ã’ÃˆÂ¯Â¸Â¶Â¹Ã½ 

					// Â»Ã§Ã…ÃµÃ€Ã¥ Â³Â»Â¿Â¡Â¼Â­Â´Ã‚ Â¼Ã’ÃˆÂ¯Â¸Â¶Â¹Ã½Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰.
					if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone ) return;

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					// ÃÃ¶ÃÂ¤ÂµÃˆ OwnerÂ°Â¡ MasterÂ°Â¡ ÂµÃˆÂ´Ã™. 
					if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
						// MasterÂ·ÃŽ ÃÃ¶ÃÂ¤ÂµÃˆ Â´Ã«Â»Ã³Ã€Â» ÂµÃ»Â¶Ã³Â´Ã™Â´ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Â°Â´ÃƒÂ¼ Â¼Ã¶Â¸Â¦ Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™. 
						iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

						// Â¼Ã’ÃˆÂ¯Â¸Â¶Â¹Ã½Ã€Â» CastingÃ‡Ã‘ Ã€ÃšÃ€Ã‡ Magery/20 Â¸Â¸Ã…Â­Ã€Ã‡ Â¸Ã³Â½ÂºÃ…ÃÂ¸Â¦ Â¼Ã’ÃˆÂ¯Ã‡Ã’ Â¼Ã¶ Ã€Ã–Â´Ã™.
						if (iFollowersNum >= (m_pClientList[iClientH]->m_cSkillMastery[4]/20)) break;

						iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
						if (iNamingValue == -1) {
							// Â´ÃµÃ€ÃŒÂ»Ã³ Ã€ÃŒ Â¸ÃŠÂ¿Â¡ NPCÂ¸Â¦ Â¸Â¸ÂµÃ©Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃŒÂ¸Â§Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â±Ã¢ Â¶Â§Â¹Â®.
						}
						else {
							// NPCÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;

							// MageryÂ¿Â¡ ÂµÃ»Â¶Ã³ Â¼Ã’ÃˆÂ¯ÂµÃ‡Â´Ã‚ Â¸Ã³Â½ÂºÃ…ÃÃ€Ã‡ ÂµÃ®Â±ÃžÃ€ÃŒ Â´ÃžÂ¶Ã³ÃÃ¸Â´Ã™.
							ZeroMemory(cNpcName, sizeof(cNpcName));

							switch (iV1) {
								case 0: // Ã€ÃÂ¹ÃÃ€Ã»Ã€ÃŽ Â°Ã¦Â¿Ã¬ 
									iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);

									// v1.42 ÃƒÃ–Ã€Ãº Â¸Ã· Â·Â¹ÂºÂ§Ã€Â» Ã€Ã”Â·Ã‚ 
									if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20) 
										iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;

									switch (iResult) {
										case 1: strcpy(cNpcName, "Slime"); break;
										case 2: strcpy(cNpcName, "Giant-Ant"); break;
										case 3: strcpy(cNpcName, "Amphis"); break;
										case 4: strcpy(cNpcName, "Orc"); break;
										case 5: strcpy(cNpcName, "Skeleton"); break;
										case 6:	strcpy(cNpcName, "Clay-Golem"); break;
										case 7:	strcpy(cNpcName, "Stone-Golem"); break;
										case 8: strcpy(cNpcName, "Orc-Mage"); break;
										case 9:	strcpy(cNpcName, "Hellbound"); break;
										case 10:strcpy(cNpcName, "Cyclops"); break;
									}
									break;

								case 1:	strcpy(cNpcName, "Orc"); break;
								case 2: strcpy(cNpcName, "Skeleton"); break;
								case 3: strcpy(cNpcName, "Clay-Golem"); break;
								case 4: strcpy(cNpcName, "Stone-Golem"); break;
								case 5: strcpy(cNpcName, "Hellbound"); break;
								case 6: strcpy(cNpcName, "Cyclops"); break;
								case 7: strcpy(cNpcName, "Troll"); break;
								case 8: strcpy(cNpcName, "Orge"); break;
							}

							if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, 0, 0, m_pClientList[iClientH]->m_cSide, false, true) == false) {
								// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·ÃŽ Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								ZeroMemory(cName_Master, sizeof(cName_Master));
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										memcpy(cName_Master, m_pClientList[sOwnerH]->m_cCharName, 10);
										break;
									case DEF_OWNERTYPE_NPC:
										memcpy(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
										break;
								}
								bSetNpcFollowMode(cName, cName_Master, cOwnerType);
							}
						}
					}
					break;

				case DEF_MAGICTYPE_CREATE:
					// Â¹Â«Â¾Ã°Â°Â¡Â¸Â¦ Â»Ã½Â¼ÂºÂ½ÃƒÃ…Â°Â´Ã‚ Â¸Â¶Â¹Ã½ 

					// Ã€Â§Ã„Â¡Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â°Ã·Â¿Â¡Â´Ã‚ Â»Ã½Â±Ã¢ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
					if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == false )
						goto MAGIC_NOEFFECT;

					pItem = new class CItem;

					switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					// Food
					if (iDice(1,2) == 1)
						wsprintf(cItemName, "Meat");
					else wsprintf(cItemName, "Baguette");
					break;
					}

					_bInitItemAttr(pItem, cItemName);

					// v2.15 Â¸Â¶Â¹Ã½Ã€Â¸Â·ÃŽ Â»Ã½Â±Ã¤ Â¾Ã†Ã€ÃŒÃ…Ã›Â¿Â¡ Â°Ã­Ã€Â¯Â¹Ã¸ÃˆÂ£ Ã€ÃºÃ€Ã¥ 
					pItem->m_sTouchEffectType   = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1,100000);
					pItem->m_sTouchEffectValue2 = iDice(1,100000);
					pItem->m_sTouchEffectValue3 = (short)timeGetTime();

					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

					// v1.41 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¶Â³Â¾Ã®Â¶ÃŸÂ¸Â° Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â·ÃŽÂ±Ã—Â¸Â¦ Â³Â²Â±Ã¤Â´Ã™. 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);

					// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						dX, dY, pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color
					break;

				case DEF_MAGICTYPE_PROTECT:
					// ÂºÂ¸ÃˆÂ£ Â¸Â¶Â¹Ã½ 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					// ÂºÂ¸ÃˆÂ£ Â»Ã³Ã…Ã‚Â¶Ã³Â´Ã‚ Â°ÃÃ€Â» Â¼Â³ÃÂ¤Ã‡ÃÂ±Ã¢ Ã€Ã¼Â¿Â¡ Ã€ÃŒÂ¹ÃŒ Ã‡Ã˜Â´Ã§ ÂºÂ¸ÃˆÂ£Â°Â¡ Â°Ã‰Â·ÃÃ€Ã–Â´Ã‚ÃÃ¶ ÃˆÂ®Ã€ÃŽÃ‡ÃÂ°Ã­ Â°Ã‰Â·ÃÃ€Ã–Â´Ã™Â¸Ã© Â¸Â¶Â¹Ã½Ã€Âº Â¹Â«Â½ÃƒÂµÃˆÂ´Ã™. 
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
							// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” Â¸Â¶Â¹Ã¦Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
							if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
							switch (m_pMagicConfigList[sType]->m_sValue4){
							case 1:
								SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
								break;
							case 2:
							case 5:
								SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
								break;
							case 3:
							case 4:
								SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
								break;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
							// ÃÂ¤Ã€Ã» NPCÂµÃ©Ã€Âº ÂºÂ¸ÃˆÂ£ Â¸Â¶Â¹Ã½ Ã€Ã»Â¿Ã« Â¾ÃˆÂµÃŠ.				
							if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;

							switch (m_pMagicConfigList[sType]->m_sValue4){
							case 1:
								SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_NPC, true);
								break;
							case 2:
							case 5:
								SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_NPC, true);
								break;
							case 3:
							case 4:
								SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_NPC, true);
								break;
							}
							break;
					}

					// ÂºÂ¸ÃˆÂ£ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
						sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

					// ÃˆÂ¿Â°ÃºÂ°Â¡ Â»Ã½Â°Ã¥Ã€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
					if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
					break;

				case DEF_MAGICTYPE_SCAN:
					ZeroMemory(cScanMessage, sizeof(cScanMessage));
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								wsprintf(cScanMessage, " Player: %s HP:%d MP:%d.", m_pClientList[sOwnerH]->m_cCharName, m_pClientList[sOwnerH]->m_iHP, m_pClientList[sOwnerH]->m_iMP);
								ShowClientMsg(iClientH, cScanMessage);
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								wsprintf(cScanMessage, " NPC: %s HP:%d MP:%d", m_pNpcList[sOwnerH]->m_cNpcName, m_pNpcList[sOwnerH]->m_iHP, m_pNpcList[sOwnerH]->m_iMana);
								ShowClientMsg(iClientH, cScanMessage);
								break;
						}
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, 10, (short)10);
					}
					break;

				case DEF_MAGICTYPE_HOLDOBJECT:
					// Â¿Ã€ÂºÃªÃÂ§Ã†Â®Ã€Ã‡ Â¿Ã²ÃÃ·Ã€Ã“Ã€Â» ÂºÃ€Â¼Ã¢Ã‡Ã‘Â´Ã™. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {

						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;
								// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” Ã†ÃÂ·Â²Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
								if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
								// 2002-09-10 #2 Â¾ÃˆÃ€Ã¼ÃÃ¶Â´Ã«(No-Attack-Area) Ã†ÃÂ·Â² Â¸Â¶Â¹Ã½ Â¾ÃˆÂµÃ‡Â°Ã” Ã‡Ã”
								if (  cOwnerType == DEF_OWNERTYPE_PLAYER )  {

									if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
									if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
								}

								// 2002-09-10 #3 Ã€Ã¼Â¸Ã©Ã€Ã¼Â½ÃƒÂ¿Ã Â¹ÃŒÂµÃ©Â·Â£ÂµÃ¥Â¿Â¡Â¼Â­Â¸Â¦ ÃÂ¦Â¿ÃœÃ‡ÃÂ°Ã­ Â°Â°Ã€Âº Ã†Ã­Â¿Â¡Â°Ã”Â´Ã‚ Ã†ÃÂ·Â² Â¾ÃˆÂµÃŠ
								if( strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland") != 0 &&
									m_bIsCrusadeMode == false &&
									m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide )
									goto MAGIC_NOEFFECT;

								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT; // v1.4 Â¸Â¶Â¹Ã½ Â·Â¹ÂºÂ§ 6Ã€ÃŒÂ»Ã³Ã€ÃŽ Â¸Â®Ã„Â¡Â±Ãž Ã€ÃŒÂ»Ã³Ã€Ã‡ Â¸Â¶Â¹Ã½ Â¸Ã³Â½ÂºÃ…ÃÂ¿Â¡Â°Ã”Â´Ã‚ Â¸Â¶ÂºÃ± Â¸Â¶Â¹Ã½ Ã…Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break;
						}

						// ÂºÂ¸ÃˆÂ£ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

						// ÃˆÂ¿Â°ÃºÂ°Â¡ Â»Ã½Â°Ã¥Ã€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
						if (cOwnerType == DEF_OWNERTYPE_PLAYER)
							SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
					}
					break;

				case DEF_MAGICTYPE_INVISIBILITY:
					switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((sOwnerH != iClientH) && ((memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) || (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)) && ((memcmp(m_pClientList[sOwnerH]->m_cLocation, "elvhunter", 9) != 0) || (memcmp(m_pClientList[sOwnerH]->m_cLocation, "arehunter", 9) != 0))) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
							if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;

							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
							SetInvisibilityFlag(sOwnerH, cOwnerType, true);
							RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;

							if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
								// Ã€ÃŒÂµÂ¿Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚ NPCÂ´Ã‚ Ã…ÃµÂ¸Ã­ Â¸Â¶Â¹Ã½Ã€Â» Â°Ã‰ Â¼Ã¶ Â¾Ã¸Â´Ã™.
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								SetInvisibilityFlag(sOwnerH, cOwnerType, true);
								// Ã€ÃŒ NPCÂ¸Â¦ ÃƒÃŸÃ€Ã»Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã¸ Â¸Ã³Â½ÂºÃ…ÃÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
								RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);	
							}
							break;
							}

							// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
								sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
							break;

						case 2:
							// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” ÃÃŸÂµÂ¶Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
							if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
							if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) || (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)) goto MAGIC_NOEFFECT;

							// dX, dY Â¹ÃÂ°Ã¦ 8 ÃÃ–ÂºÂ¯Ã€Ã‡ Invisibility Â»Ã³Ã…Ã‚Ã€ÃŽ ObjectÂ°Â¡ Ã€Ã–Ã€Â¸Â¸Ã© Ã‡Ã˜ÃÂ¦ Â½ÃƒÃ…Â²Â´Ã™.
							for (ix = dX - 8; ix <= dX + 8; ix++)
								for (iy = dY - 8; iy <= dY + 8; iy++) {
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (sOwnerH != 0) {
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = 0;
													SetInvisibilityFlag(sOwnerH, cOwnerType, false);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = 0;
													SetInvisibilityFlag(sOwnerH, cOwnerType, false);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
												}
												break;
										}
									}
								}
								break;
					}
					break;

				case DEF_MAGICTYPE_CREATE_DYNAMIC:
					// Dynamic ObjectÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡ÃÂ°Ã­ ÃˆÂ¿Â·Ã‚Ã€ÃŒ ÃÃ¶Â¼Ã“ÂµÃ‡Â´Ã‚ Ã…Â¸Ã€Ã”.

					// v2.1 Â¸Â¶Ã€Â» Â³Â»Â¿Â¡Â¼Â­Â´Ã‚ Ã‡ÃŠÂµÃ¥ Â¸Â¶Â¹Ã½ Â±ÃÃÃ¶(Ã€Ã¼Â¸Ã©Ã€Ã¼Â½Ãƒ ÃÂ¦Â¿Ãœ)
					if (m_bIsCrusadeMode == false) {
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) return;
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) return;
						// v2.14
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) return;
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0) return;
					}

					switch (m_pMagicConfigList[sType]->m_sValue10) {
				case DEF_DYNAMICOBJECT_PCLOUD_BEGIN: // ÂµÂ¶Â±Â¸Â¸Â§

				case DEF_DYNAMICOBJECT_FIRE:   // Fire Ã€ÃŒÂ´Ã™.
				case DEF_DYNAMICOBJECT_SPIKE:  // Spike

		#ifdef DEF_TAIWANLOG 
					short sTemp_X, sTemp_Y ;
					// v2.15 Â¸Â¶Â¹Ã½Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Â§Ã„Â¡Â¸Â¦ Ã‡Â¥Â½ÃƒÃ‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã‘ ÂºÂ¯Â¼Ã¶
					sTemp_X = m_pClientList[iClientH]->m_sX ;
					sTemp_Y = m_pClientList[iClientH]->m_sY ;

					m_pClientList[iClientH]->m_sX = dX;
					m_pClientList[iClientH]->m_sY = dY;

					_bItemLog(DEF_ITEMLOG_SPELLFIELD,iClientH,m_pMagicConfigList[sType]->m_cName,0) ;

					m_pClientList[iClientH]->m_sX = sTemp_X;
					m_pClientList[iClientH]->m_sY = sTemp_Y;
		#endif

					switch (m_pMagicConfigList[sType]->m_sValue11) {
				case 1: 
					// wall - type
					cDir = m_Misc.cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY);
					switch (cDir) {
				case 1:	rx = 1; ry = 0;   break;
				case 2: rx = 1; ry = 1;   break;
				case 3: rx = 0; ry = 1;   break;
				case 4: rx = -1; ry = 1;  break;
				case 5: rx = 1; ry = 0;   break;
				case 6: rx = -1; ry = -1; break;
				case 7: rx = 0; ry = -1;  break;
				case 8: rx = 1; ry = -1;  break;
					}

					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000);	

					bAnalyzeCriminalAction(iClientH, dX, dY);

					for (i = 1; i <= m_pMagicConfigList[sType]->m_sValue12; i++) {
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX + i*rx, dY + i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX + i*rx, dY + i*ry);

						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX - i*rx, dY - i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX - i*rx, dY - i*ry);
					}
					break;

				case 2:
					// Field - Type
					bool bFlag = false;
					int cx, cy;
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue12; ix <= dX + m_pMagicConfigList[sType]->m_sValue12; ix++)
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue12; iy <= dY + m_pMagicConfigList[sType]->m_sValue12; iy++) {
							iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
								ix, iy, m_pMagicConfigList[sType]->m_dwLastTime*1000, m_pMagicConfigList[sType]->m_sValue5);	

							// Â¸Â¸Â¾Ã  Â¸Â¶Ã€Â»Â¿Â¡Â¼Â­ Ã‡ÃŠÂµÃ¥Â¸Â¦ Â±Ã± Â°Ã·Â¿Â¡ Â¹Â«Â°Ã­Ã‡Ã‘ Ã€ÃšÂ°Â¡ Ã€Ã–Â¾ÃºÂ´Ã™Â¸Ã© Â°Ã¸Â°ÃÃ€ÃšÂ´Ã‚ Â°Â¡ÂµÃ¥Ã€Ã‡ Â°Ã¸Â°ÃÃ€Â» Â¹ÃžÂ°Ã” ÂµÃˆÂ´Ã™. 
							if (bAnalyzeCriminalAction(iClientH, ix, iy, true) ) {
								bFlag = true;
								cx = ix;
								cy = iy;
							}
						}
						// Ã‡ÃŠÂµÃ¥Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â°Ã¦ÂºÃ±Â¸Â¦ 1Â¸Ã­Â¸Â¸ Â¼Ã’ÃˆÂ¯Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã”.
						if (bFlag ) bAnalyzeCriminalAction(iClientH, cx, cy);
						break;
					}
					//
					break;

				case DEF_DYNAMICOBJECT_ICESTORM:
					// Ice-Storm Dynamic Object 
					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000,
						m_pClientList[iClientH]->m_cSkillMastery[4]);	
					break;

				default:
					break;
					}
					break;

				case DEF_MAGICTYPE_POSSESSION:
					// Â¿Ã¸Â°Ã…Â¸Â®Â¿Â¡ Â¶Â³Â¾Ã®ÃÂ® Ã€Ã–Â´Ã‚ Â¹Â°Â°Ã‡Ã€Â» ÃÃ½Â¾Ã®Â¿Ã€Â´Ã‚ Â¸Â¶Â¹Ã½Ã€ÃŒÂ´Ã™. 
					// v2.12 ÃÃŸÂ¸Â³Ã€Âº Ã†Ã·ÃÂ¦Â¼Ã‡ Â¸Â¶Â¹Ã½ Â»Ã§Â¿Ã« ÂºÃ’Â°Â¡ 
					if (m_pClientList[iClientH]->m_cSide == 0) goto MAGIC_NOEFFECT;

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (sOwnerH != 0) break; // v1.41 Ã†Ã·ÃÂ¦Â¼Ã‡ Â¸Â¶Â¹Ã½Ã€Âº Â»Ã§Â¶Ã·Ã€ÃŒ Â¼Â­ Ã€Ã–Â´Ã‚ Ã€Â§Â¿Â¡Â´Ã‚ ÃˆÂ¿Â·Ã‚Ã€ÃŒ Â¾Ã¸Â´Ã™. 

					pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(dX, dY, &sIDNum, &cRemainItemColor, &dwAttr);
					if (pItem != 0) {
						// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃÂ¿Â´Â´Ã™. 
						if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {
							// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.

							// v1.411 Â·ÃŽÂ±Ã— Â³Â²Â±Ã¤Â´Ã™.
							_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

							dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
							*dwp = MSGID_NOTIFY;
							wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
							*wp  = DEF_NOTIFY_ITEMOBTAINED;

							cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

							// 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™. <- Â¿Â©Â±Ã¢Â¼Â­ 1Â°Â³Â¶Ãµ Ã„Â«Â¿Ã®Ã†Â®Â¸Â¦ Â¸Â»Ã‡ÃÂ´Ã‚ Â°ÃÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™
							*cp = 1;
							cp++;

							memcpy(cp, pItem->m_cName, 20);
							cp += 20;

							dwp  = (DWORD *)cp;
							*dwp = pItem->m_dwCount;
							cp += 4;

							*cp = pItem->m_cItemType;
							cp++;

							*cp = pItem->m_cEquipPos;
							cp++;

							*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·ÃŽ Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
							cp++;

							sp  = (short *)cp;
							*sp = pItem->m_sLevelLimit;
							cp += 2;

							*cp = pItem->m_cGenderLimit;
							cp++;

							wp = (WORD *)cp;
							*wp = pItem->m_wCurLifeSpan;
							cp += 2;

							wp = (WORD *)cp;
							*wp = pItem->m_wWeight;
							cp += 2;

							sp  = (short *)cp;
							*sp = pItem->m_sSprite;
							cp += 2;

							sp  = (short *)cp;
							*sp = pItem->m_sSpriteFrame;
							cp += 2;

							*cp = pItem->m_cItemColor;
							cp++;

							*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
							cp++;

							dwp = (DWORD *)cp;
							*dwp = pItem->m_dwAttribute;
							cp += 4;
							/*
							*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃŽÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃŽ 
							cp++;
							*/

							if (iEraseReq == 1) delete pItem;

							// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃÂ°Ã­Â³Â­ ÃˆÃ„ Â³Â²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã‹Â¸Â°Â´Ã™. 
							SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
								dX, dY, sIDNum, 0, cRemainItemColor, dwAttr); // v1.4

							// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
							iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);

							switch (iRet) {
								case DEF_XSOCKEVENT_QUENEFULL:
								case DEF_XSOCKEVENT_SOCKETERROR:
								case DEF_XSOCKEVENT_CRITICALERROR:
								case DEF_XSOCKEVENT_SOCKETCLOSED:
									// Â¸ÃžÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
									DeleteClient(iClientH, true, true);
									return;
							}
						}
						else 
						{
							// Â°Ã¸Â°Â£Ã€ÃŒ ÂºÃŽÃÂ·Ã‡ÃÂ°Ã…Â³Âª Ã‡Ã‘Â°Ã¨ÃÃŸÂ·Â®Ã€Â» ÃƒÃŠÂ°ÃºÃ‡ÃŸÂ´Ã™. Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¾Ã²Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.

							// Â°Â¡ÃÂ®Â¿Ã”Â´Ã¸ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¿Ã¸Â»Ã³ÃˆÂ¸ÂºÂ¹Â½ÃƒÃ…Â²Â´Ã™. 
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

							dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
							*dwp = MSGID_NOTIFY;
							wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
							*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;

							iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
							switch (iRet) {
								case DEF_XSOCKEVENT_QUENEFULL:
								case DEF_XSOCKEVENT_SOCKETERROR:
								case DEF_XSOCKEVENT_CRITICALERROR:
								case DEF_XSOCKEVENT_SOCKETCLOSED:
									// Â¸ÃžÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
									DeleteClient(iClientH, true, true);
									return;
							}
						}
					}
					//
					break;

				case DEF_MAGICTYPE_CONFUSE:
					// if the caster side is the same as the targets side, no effect occurs
						switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1: // confuse LanguageÃ¬ÂÂ´Ã«â€¹Â¤. 
						case 2: // Confusion, Mass Confusion 	
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
								for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
									// Ã¬Å¾ÂÃ¬â€¹Â Ã«Ââ€ž Ã­â€Â¼Ã­ÂÂ­Ã«ÂÂ  Ã¬Ë†Ëœ Ã¬Å¾Ë†Ã¬Å“Â¼Ã«â€¹Ë† Ã¬Â£Â¼Ã¬ÂËœ.
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										// Ã­â€¢Â´Ã«â€¹Â¹ Ã¬Å“â€žÃ¬Â¹ËœÃ¬â€”Â Ã¬ÂºÂÃ«Â¦Â­Ã­â€žÂ°ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤.
										if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										if ((bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide)) {
											// Ã¬Æ’ÂÃ«Å’â‚¬Ã«Â°Â©Ã¬ÂÂ´ Ã«Â§Ë†Ã«Â²â€¢ Ã¬Â â‚¬Ã­â€¢Â­Ã¬â€”Â Ã¬â€¹Â¤Ã­Å’Â¨Ã­â€“Ë†Ã«â€¹Â¤.
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //Ã¬ÂÂ´Ã«Â¯Â¸ Ã«â€¹Â¤Ã«Â¥Â¸ ConfuseÃ­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤Ã«Â©Â´ Ã«Â¬Â´Ã¬â€¹Å“Ã«ÂÅ“Ã«â€¹Â¤.
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

											// Ã­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã­â€¢Â´Ã¬Â Å“Ã«ÂÂ  Ã«â€¢Å’ Ã«Â°Å“Ã¬Æ’ÂÃ­â€¢Â  Ã«â€Å“Ã«Â Ë†Ã¬ÂÂ´ Ã¬ÂÂ´Ã«Â²Â¤Ã­Å Â¸Ã«Â¥Â¼ Ã«â€œÂ±Ã«Â¡ÂÃ­â€¢Å“Ã«â€¹Â¤.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
												sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

											// Ã«Â§Ë†Ã«Â²â€¢Ã¬â€”Â ÃªÂ±Â¸Ã«Â Â¸Ã¬ÂÅ’Ã¬Ââ€ž Ã¬â€¢Å’Ã«Â¦Â°Ã«â€¹Â¤.
											SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
										}
									}
								}	
								break;

						case 3: // Ilusion, Mass-Ilusion
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
								for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
									// Ã¬Å¾ÂÃ¬â€¹Â Ã«Ââ€ž Ã­â€Â¼Ã­ÂÂ­Ã«ÂÂ  Ã¬Ë†Ëœ Ã¬Å¾Ë†Ã¬Å“Â¼Ã«â€¹Ë† Ã¬Â£Â¼Ã¬ÂËœ.
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										// Ã­â€¢Â´Ã«â€¹Â¹ Ã¬Å“â€žÃ¬Â¹ËœÃ¬â€”Â Ã¬ÂºÂÃ«Â¦Â­Ã­â€žÂ°ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤.
										if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										if ((bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide)) {
											// Ã¬Æ’ÂÃ«Å’â‚¬Ã«Â°Â©Ã¬ÂÂ´ Ã«Â§Ë†Ã«Â²â€¢ Ã¬Â â‚¬Ã­â€¢Â­Ã¬â€”Â Ã¬â€¹Â¤Ã­Å’Â¨Ã­â€“Ë†Ã«â€¹Â¤.
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //Ã¬ÂÂ´Ã«Â¯Â¸ Ã«â€¹Â¤Ã«Â¥Â¸ ConfuseÃ­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤Ã«Â©Â´ Ã«Â¬Â´Ã¬â€¹Å“Ã«ÂÅ“Ã«â€¹Â¤.
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

											switch (m_pMagicConfigList[sType]->m_sValue4) {
												case 3:
													SetIllusionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
													break;
											}

											// Ã­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã­â€¢Â´Ã¬Â Å“Ã«ÂÂ  Ã«â€¢Å’ Ã«Â°Å“Ã¬Æ’ÂÃ­â€¢Â  Ã«â€Å“Ã«Â Ë†Ã¬ÂÂ´ Ã¬ÂÂ´Ã«Â²Â¤Ã­Å Â¸Ã«Â¥Â¼ Ã«â€œÂ±Ã«Â¡ÂÃ­â€¢Å“Ã«â€¹Â¤.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
												sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

											// Ã«Â§Ë†Ã«Â²â€¢Ã¬â€”Â ÃªÂ±Â¸Ã«Â Â¸Ã¬ÂÅ’Ã¬Ââ€ž Ã¬â€¢Å’Ã«Â¦Â°Ã«â€¹Â¤.
											SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, 0);
										}
									}
								}	
								break;

						case 4: // Ilusion Movement
							if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) break;
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
							for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										if ((bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break;
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;
											switch (m_pMagicConfigList[sType]->m_sValue4) {
												case 4:
													SetIllusionMovementFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
													break;
											}

											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
												sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

											SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, 0);
										}
									}
								}	
					}
					break;


				case DEF_MAGICTYPE_POISON:
					// ÃÃŸÂµÂ¶ Â¸Â¶Â¹Ã½. Â¸Ã•Ã€Ãº Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Ã€Â» Â±Â¼Â¸Â®Â°Ã­ Â´Ã™Ã€Â½Ã€Â¸Â·ÃŽ ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—Ã€Â» Ã‡Ã‘Â¹Ã¸ Â´Ãµ Â±Â¼Â¸Â°Â´Ã™. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					if (m_pMagicConfigList[sType]->m_sValue4 == 1) {
						// ÃÃŸÂµÂ¶Ã€Â» Â°Ã…Â´Ã‚ Â¸Â¶Â¹Ã½ 
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” ÃÃŸÂµÂ¶Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
								if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;

								// Â¹Ã¼ÃÃ‹Ã‡Ã Ã€Â§Â¶Ã³Â¸Ã© 
								bAnalyzeCriminalAction(iClientH, dX, dY);

								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									// Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™. ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—Ã€Â» Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™.
									if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == false) {
										// ÃÃŸÂµÂ¶ÂµÃ‡Â¾ÃºÂ´Ã™.
										m_pClientList[sOwnerH]->m_bIsPoisoned  = true;
										m_pClientList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5;
										m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
										// 05/06/2004 - Hypnotoad - poison aura appears when cast Poison
										SetPoisonFlag(sOwnerH, cOwnerType, true);
										// ÃÃŸÂµÂ¶ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pMagicConfigList[sType]->m_sValue5, 0, 0);
					#ifdef DEF_TAIWANLOG
										_bItemLog(DEF_ITEMLOG_POISONED,sOwnerH,(char *) 0,0) ;
					#endif
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_iHP > 0) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									// Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™. ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—Ã€Â» Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™.
									if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == false) {
										// ÃÃŸÂµÂ¶ÂµÃ‡Â¾ÃºÂ´Ã™.

									}
								}
								break;
						}
					}
					else if (m_pMagicConfigList[sType]->m_sValue4 == 0) {
						// ÃÃŸÂµÂ¶Ã€Â» Ã‡ÂªÂ´Ã‚ Â¸Â¶Â¹Ã½ 
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;

								if (m_pClientList[sOwnerH]->m_bIsPoisoned ) {
									// ÃÃŸÂµÂ¶ÂµÃˆ Â»Ã³Ã…Ã‚Â¿Â´Â´Ã™Â¸Ã© ÃÃŸÂµÂ¶Ã€Â» Ã‡Â¬Â´Ã™.
									m_pClientList[sOwnerH]->m_bIsPoisoned = false;
									// 05/06/2004 - Hypnotoad - poison aura removed when cure cast
									SetPoisonFlag(sOwnerH, cOwnerType, false);
									// ÃÃŸÂµÂ¶Ã€ÃŒ Ã‡Â®Â·ÃˆÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, 0, 0, 0);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								break;
						}
					}
					break;

				case DEF_MAGICTYPE_BERSERK:
					switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1:
							// Â¹Ã¶Â¼Â­Ã„Â¿ Â¸Ã°ÂµÃ¥Â·ÃŽ Ã€Ã¼ÃˆÂ¯ÂµÃˆÂ´Ã™.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetBerserkFlag(sOwnerH, cOwnerType, true);
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
									// ÃÂ¤Ã€Ã» NPCÂµÃ©Ã€Âº Â±Â¤ÂºÃ Â¾ÃˆÂµÃŠ				
									if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
									// 2002-09-11 #3 Ã€Ã» Â¸Ã³Â½ÂºÃ…ÃÂ´Ã‚ Â±Â¤ÂºÃÂµÃ‡ÃÃ¶ Â¾ÃŠÃ€Â½
									if ( m_pClientList[iClientH]->m_cSide != m_pNpcList[sOwnerH]->m_cSide ) goto MAGIC_NOEFFECT;

									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetBerserkFlag(sOwnerH, cOwnerType, true);
									break;
							}

							// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
								sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
							break;
					}
					break;

					// v2.16 2002-5-23 Â°Ã­Â±Â¤Ã‡Ã¶ Â¼Ã¶ÃÂ¤
				case DEF_MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK:
					// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
								// Â¹Ã¦Â¾Ã®Â±Â¸Ã€Ã‡ Â¼Ã¶Â¸Ã­Ã€Â» ÃÃ™Ã€ÃŽÂ´Ã™.
								ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
										// Â¹Ã¦Â¾Ã®Â±Â¸Ã€Ã‡ Â¼Ã¶Â¸Ã­Ã€Â» ÃÃ™Ã€ÃŽÂ´Ã™.
										ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
									}
								}
						}
						break;

						// Resurrection Magic. 
				case DEF_MAGICTYPE_RESURRECTION: 
					// 10 Mins once
					if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) goto MAGIC_NOEFFECT;
					m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC/2;
					// Get the ID of the dead Player/NPC on coords dX, dY. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY); 
					switch (cOwnerType) { 
								// For Player. 
						case DEF_OWNERTYPE_PLAYER: 
							// The Player has to exist. 
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT; 
							// Resurrection is not for alive Players. 
							if (m_pClientList[sOwnerH]->m_bIsKilled == false) goto MAGIC_NOEFFECT; 
							// Set Deadflag to Alive. 
							m_pClientList[sOwnerH]->m_bIsKilled = false; 
							// Player's HP becomes half of the Max HP. 
							m_pClientList[sOwnerH]->m_iHP = ((m_pClientList[sOwnerH]->m_iLevel * 2) + (m_pClientList[sOwnerH]->m_iVit * 3) + ((m_pClientList[sOwnerH]->m_iStr+ m_pClientList[sOwnerH]->m_iAngelicStr) / 2)) / 2;
							// Send new HP to Player. 
							SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0); 
							// Make Player stand up. (Currently, by a fake damage). 
							m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->ClearDeadOwner(dX, dY); 
							m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->SetOwner(sOwnerH, DEF_OWNERTYPE_PLAYER, dX, dY); 
							SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, 0, 0); 
							SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0); 
							break; 
							// Resurrection is not for NPC's. 
						case DEF_OWNERTYPE_NPC: 
							goto MAGIC_NOEFFECT; 
							break; 
					} 
					break;

				case DEF_MAGICTYPE_ICE:
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								// Â´Ã«Â¹ÃŒÃÃ¶Â¿Ã Ã‡Ã”Â²Â²
								//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, true);
												// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
												// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
												SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, true);
												// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
											}
										}
										break;
								}

							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {

										//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
										// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº. ÃÃ—ÃÃ¶ Â¾ÃŠÂ¾Ã’Ã€Â¸Â¸Ã© Ã€Ã»Â¿Ã« 
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, true);
												// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);

												SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
											}
										}
									}
								}
						}
						break;

				default:
					break;
			}
		}
		else {
			// Casting ÃˆÃ„ ÂµÃ´Â·Â¹Ã€ÃŒÂ°Â¡ Â°Ã‰Â¸Â®Â´Ã‚ Â¸Â¶Â¹Ã½
			// Resurrection wand(MS.10) or Resurrection wand(MS.20)

				if (m_pMagicConfigList[sType]->m_sType == DEF_MAGICTYPE_RESURRECTION) {
					//Check if player has resurrection wand
					if (m_pClientList[iClientH] != 0 && m_pClientList[iClientH]->m_iSpecialAbilityTime == 0 &&
						m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == false) {
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
							if(m_pClientList[sOwnerH] != 0){
							// GM's can ressurect ne1, and players must be on same side to ressurect

							if ((m_pClientList[iClientH]->m_iAdminUserLevel < 1) &&
								(m_pClientList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
								return;
							}
							if (cOwnerType == DEF_OWNERTYPE_PLAYER && m_pClientList[sOwnerH] != 0 &&
								m_pClientList[sOwnerH]->m_iHP <= 0){
								m_pClientList[sOwnerH]->m_bIsBeingResurrected = true;
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_RESURRECTPLAYER, 0, 0, 0, 0);
									if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
										m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = true;
										m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;
										m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
										m_pClientList[iClientH]->m_iSpecialAbilityTime = m_pMagicConfigList[sType]->m_dwDelayTime;

										sTemp = m_pClientList[iClientH]->m_sAppr4;
										sTemp = 0xFF0F & sTemp;
										sTemp = sTemp | 0x40;
										m_pClientList[iClientH]->m_sAppr4 = sTemp;
									}
								SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, 0);
								SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
							}
						}
					}
				}
			}

MAGIC_NOEFFECT:

		if (m_pClientList[iClientH] == 0) return;
		
		//Mana Slate
		if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
			iManaCost = 0;
		}

		// ManaÂ¸Â¦ Â°Â¨Â¼Ã’Â½ÃƒÃ…Â°Â°Ã­ Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™.
		m_pClientList[iClientH]->m_iMP -= iManaCost; // sValue1Ã€ÃŒ Mana Cost
		if (m_pClientList[iClientH]->m_iMP < 0) 
			m_pClientList[iClientH]->m_iMP = 0;

		CalculateSSN_SkillIndex(iClientH, 4, 1 );

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);

		// Â¸Â¶Â¹Ã½ ÃˆÂ¿Â°ÃºÂ¸Â¦ Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™. Â¸Â¶Â¹Ã½Â¹Ã¸ÃˆÂ£ + 100Ã€ÃŒ Â¿Â¡Ã†Ã¥Ã†Â® Â¹Ã¸ÃˆÂ£ 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (sType+100), m_pClientList[iClientH]->m_sType);

}


void CGame::NpcMagicHandler(int iNpcH, short dX, short dY, short sType)
{
 short  sOwnerH;
 char   cOwnerType;
 int i, iErr, ix, iy, sX, sY, tX, tY, iResult, iWhetherBonus, iMagicAttr;
 DWORD  dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == 0) return;
	if ((dX < 0) || (dX >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY)) return;
									   
	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == 0) return;
	
	// ġ  Ұ ̶  Ұ 
	if (m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->m_bIsAttackEnabled == false) return;
	
	//    ߷ Է 
	iResult = m_pNpcList[iNpcH]->m_iMagicHitRatio;
	
	//    ݷ   
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cWhetherStatus);

	// v1.41  Ӽ 
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		//  ȿ   
		switch (m_pMagicConfigList[sType]->m_sType) {
		case DEF_MAGICTYPE_INVISIBILITY:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				//  ʴ · . 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, true);
					//  ĳ͸ ϰ ִ ͸ Ų.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, true);
					//  NPC ϰ ִ ͸ Ų.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC);
					break;
				}
			
				// ȿ   ߻  ̺Ʈ Ѵ.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
				break;

			case 2:
				// dX, dY ݰ 8 ֺ Invisibility  Object   Ų.
				for (ix = dX - 8; ix <= dX + 8; ix++)
				for (iy = dY - 8; iy <= dY + 8; iy++) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != 0) {
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto NMH_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) {
								if (m_pClientList[sOwnerH]->m_sType != 66) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = 0;
									SetInvisibilityFlag(sOwnerH, cOwnerType, false);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto NMH_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) {
								if (m_pClientList[sOwnerH]->m_sType != 66) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = 0;
									SetInvisibilityFlag(sOwnerH, cOwnerType, false);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
								}
							}
							break;
						}
					}
				}
				break;
			}
			break;

		case DEF_MAGICTYPE_HOLDOBJECT:
			// Ʈ  Ѵ. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
				
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
					
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto NMH_NOEFFECT; // v1.4   6̻ ġ ̻  ͿԴ    ʴ´.
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}
				
				//  ȿ   ߻  ̺Ʈ Ѵ.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
				
				// ȿ  ˷ش.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
			}
			break;
		
		
		case DEF_MAGICTYPE_DAMAGE_LINEAR:
			//   ִ ǥ  Ѵ.
			sX = m_pNpcList[iNpcH]->m_sX;
			sY = m_pNpcList[iNpcH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
			
				// tx, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					//  ôϰ ִ ÷̾.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx-1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					//  ôϰ ִ ÷̾.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx+1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					//  ôϰ ִ ÷̾.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx, ty-1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					//  ôϰ ִ ÷̾.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx, ty+1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					//  ôϰ ִ ÷̾.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// ֺ  ȿ 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// ڽŵ    .
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					//  ôϰ ִ ÷̾.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}
			}

			// dX, dY
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				//  ôϰ ִ ÷̾.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);
			}
			break;
		
		case DEF_MAGICTYPE_DAMAGE_SPOT:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				//  ôϰ ִ ÷̾.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_HPUP_SPOT:
			//   ߷  .
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				//  ôϰ ִ ÷̾.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
			}
			
			// ֺ  ȿ 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// ڽŵ    .
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					//  ôϰ ִ ÷̾.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
			//   ʴ´.			
			// ֺ  ȿ 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// ڽŵ    .
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					//  ôϰ ִ ÷̾.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_SPDOWN_AREA:
			// Sp پ.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// ֺ  ȿ 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// ڽŵ    .
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_SPUP_AREA:
			// Sp Ѵ.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			//   ʿ. 
			Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// ֺ  ȿ 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// ڽŵ    .
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				//  ʿ .
				Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		}
	}
	else {
		// Casting  ̰ ɸ 

	}

NMH_NOEFFECT:

	// Mana ҽŲ.
	m_pNpcList[iNpcH]->m_iMana -= m_pMagicConfigList[sType]->m_sValue1; // sValue1 Mana Cost
	if (m_pNpcList[iNpcH]->m_iMana < 0) 
		m_pNpcList[iNpcH]->m_iMana = 0;

	//  ȿ ٸ Ŭ̾Ʈ Ѵ. ȣ + 100 Ʈ ȣ 
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pNpcList[iNpcH]->m_cMapIndex,
					            m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, dX, dY, (sType+100), m_pNpcList[iNpcH]->m_sType);

}

void CGame::RequestTeleportHandler(int iClientH, char * pData, char * cMapName, int dX, int dY)
{
	char  * pBuffer, cTempMapName[21];
	DWORD * dwp;
	WORD  * wp;
	char  * cp, cDestMapName[11], cDir, cMapIndex, cQuestRemain;
	short * sp, sX, sY, sSummonPoints;
	int   * ip, i, iRet, iSize, iDestX, iDestY, iExH, iMapSide;
	bool    bRet, bIsLockedMapNotify;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled ) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess ) return;
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsRecallImpossible ) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) &&
		(m_pClientList[iClientH]->m_bIsKilled == false) && (m_bIsApocalypseMode )  && (m_pClientList[iClientH]->m_iHP > 0)) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NORECALL, 0, 0, 0, 0);
		return;
	}
	// v2.16 2002-6-2     ʴ´.
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0)
		&& (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0)
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		&& ((pData[0] == '1')  || (pData[0] == '3'))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
		&& (m_bIsCrusadeMode == false)) return;

	// v2.16 2002-6-2     ʴ´.
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) 
		&& (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0)
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		&& ((pData[0] == '1')  || (pData[0] == '3'))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
		&& (m_bIsCrusadeMode == false)) return;

	bIsLockedMapNotify = false;

	// ë§Œì•½ êµí™˜ ëª¨ë“œë¼ë©´ êµí™˜ì„ ì·¨ì†Œí•œë‹¤.
	if (m_pClientList[iClientH]->m_bIsExchangeMode ) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// ì¤‘ë¦½ì´ ë¦¬ì½œ ë§ˆë²•ì„ ì‚¬ìš©í•˜ë©´ íˆ¬ëª…í•˜ê²Œ ë˜ëŠ” ë²„ê·¸ ìˆ˜ì • 
	// ì¤‘ë¦½ì´ë©´ ë¦¬ì½œ ë§ˆë²•ì„ ì‚¬ìš©í•˜ì§€ ëª»í•˜ê²Œ ëœë‹¤. 
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && (pData[0] == '1'))
		return;

	// í˜„ìž¬ ì´ í”Œë ˆì´ì–´ë¥¼ ëª©í‘œë¡œ ì‚¼ê³  ìžˆëŠ” ëª¹ë“¤ì˜ ê³µê²©í–‰ë™ì„ ë©ˆì¶”ê²Œ í•œë‹¤. 
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

	// í˜„ìž¬ ë§µ ìœ„ì¹˜ì—ì„œ ì§€ìš´ë‹¤.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER, 
		m_pClientList[iClientH]->m_sX, 
		m_pClientList[iClientH]->m_sY);

	// ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ë“¤ì—ê²Œ í”Œë ˆì´ì–´ê°€ í˜„ ìœ„ì¹˜ì—ì„œ ì‚¬ë¼ì§ì„ ì•Œë¦°ë‹¤. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, 0, 0, 0);

	// í˜„ìž¬ í…”ë ˆí¬íŠ¸ê°€ ë§ˆë²•ì— ì˜í•œ ê²ƒì¸ì§€, ì•„ë‹ˆë©´ ì¼ë°˜ì ì¸ í…”ë ˆí¬íŠ¸ íƒ€ì¼ì— ì˜í•œ ê²ƒì¸ì§€ë¥¼ ì²´í¬í•œë‹¤. 
	// ë§Œì•½ ì¼ë°˜ì ì¸ í…”ë ˆí¬íŠ¸ íƒ€ì¼ì— ì˜í•œ ê²ƒì´ë¼ë©´ í…”ë ˆí¬íŠ¸í•  ìœ„ì¹˜ì˜ ë§µì´ë¦„, ì¢Œí‘œë¥¼ êµ¬í•´ì™€ì„œ 
	// ê·¸ ë§µì´ í˜„ìž¬ ì„œë²„ì— ì¡´ìž¬í•˜ëŠ”ì§€ë¥¼ ê²€ìƒ‰í•œë‹¤. ë§Œì•½ í˜„ìž¬ ì„œë²„ì— ì¡´ìž¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ 
	// ë‹¤ë¥¸ ì„œë²„ë¡œì˜ ì ‘ì†ì„ ì‹œë„í•˜ë¼ëŠ” ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ë‹¤. 

	// ë¨¼ì € í”Œë ˆì´ì–´ê°€ ì„œìžˆëŠ” ìœ„ì¹˜ê°€ í…”ë ˆí¬íŠ¸ íƒ€ì¼ì¸ì§€ ì•Œì•„ë‚¸ë‹¤. 
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	ZeroMemory(cDestMapName, sizeof(cDestMapName));
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

	// Crusade
	if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
		// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
		// ë§Œì•½ ê°ˆ ë§µì´ ê±´ë¬¼ ë‚´ë¶€ë¼ë©´  
		iMapSide = iGetMapLocationSide(cDestMapName);
		if (iMapSide > 3) iMapSide -= 2; // New 18/05/2004
		if ((iMapSide != 0) && (m_pClientList[iClientH]->m_cSide == iMapSide)) {
		// ë“¤ì–´ê°€ê³ ìž í•˜ëŠ” ë§µì´ ê°™ì€ íŽ¸ì˜ ê±´ë¬¼ ë‚´ë¶€ë¼ë©´ ë“¤ì–´ê°ˆ ìˆ˜ ìžˆë‹¤.
		}
		else {
			iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = true;
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);
		}
	}

	if ((bRet ) && (cMapName == 0)) {
		// í”Œë ˆì´ì–´ê°€ í…”ë ˆí¬íŠ¸ íƒ€ì¼ ìœ„ì— ì„œ ìžˆë‹¤. í…”ë ˆí¬íŠ¸ í•  ë§µì´ í˜„ìž¬ ì„œë²„ì— ì¡´ìž¬í•˜ëŠ”ì§€ ê²€ìƒ‰í•œë‹¤. ë¬¼ë¡  ëª©ì ì§€ê°€ ì§€ì •ë˜ì§€ ì•Šì€ í…”ë ˆí¬íŠ¸ì—¬ì•¼í•œë‹¤.
		for (i = 0; i < DEF_MAXMAPS; i++)
			if (m_pMapList[i] != 0) {
				if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
					// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸í•  ë§µì´ ì¡´ìž¬í•œë‹¤.
					m_pClientList[iClientH]->m_sX   = iDestX;	  // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
					m_pClientList[iClientH]->m_sY   = iDestY;
					m_pClientList[iClientH]->m_cDir = cDir;
					m_pClientList[iClientH]->m_cMapIndex = i; // ë§µ ì¸ë±ìŠ¤ë¥¼ ë°”ê¾¼ë‹¤.
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
					goto RTH_NEXTSTEP;
				}
			}

			// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
			m_pClientList[iClientH]->m_sX   = iDestX;	  // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
			m_pClientList[iClientH]->m_sY   = iDestY;
			m_pClientList[iClientH]->m_cDir = cDir;
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.

			// New 18/05/2004
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
				m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], 0, 0);
			SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

			// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì €ìž¥í–ˆë‹¤ëŠ” ì‘ë‹µì´ ì˜¤ë©´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì ‘ì†ì„ ë‹¤ì‹œ í• ê²ƒì„ ì•Œë ¤ì¤€ë‹¤.
			//bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false);  // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.
			// !!!!
			m_pClientList[iClientH]->m_bIsOnServerChange = true;
			m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
			return;
	}
	else {
		// ë§ˆë²•ì— ì˜í•œ í…”ë ˆí¬íŠ¸ì´ë‹¤. 
		switch (pData[0]) {
		case '0':
			// Forced Recall. 
			// ë ˆë²¨ ì œí•œì´ ìžˆëŠ” ë§µì— ë“¤ì–´ê°”ì„ë•Œ ì¼ì–´ë‚œë‹¤. 
			ZeroMemory(cTempMapName, sizeof(cTempMapName));
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				strcpy(cTempMapName, "default");
			}
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0) {
				strcpy(cTempMapName, "arefarm");
			}
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) {
				strcpy(cTempMapName, "elvfarm");
			}
			else strcpy(cTempMapName, m_pClientList[iClientH]->m_cLocation);

			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
				bIsLockedMapNotify = true;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for (i = 0; i < DEF_MAXMAPS; i++)
				if (m_pMapList[i] != 0) {
					if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
						// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸í•  ë§µì´ ì¡´ìž¬í•œë‹¤.
						GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

						m_pClientList[iClientH]->m_cMapIndex = i; // ë§µ ì¸ë±ìŠ¤ë¥¼ ë°”ê¾¼ë‹¤.
						ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
						goto RTH_NEXTSTEP;
					}
				}

				// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
				m_pClientList[iClientH]->m_sX   = -1;	  // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
				m_pClientList[iClientH]->m_sY   = -1;	  // -1ì€ InitialPointë¥¼ ë§í•œë‹¤.

				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.

				// New 18/05/2004
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
					m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], 0, 0);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

				// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì‘ë‹µì„ ë°›ì€ í›„ ìž¬ì ‘ì†ì„ ì•Œë ¤ì•¼ í•œë‹¤.
				//bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false); // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.

				m_pClientList[iClientH]->m_bIsOnServerChange = true;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
				return;

		case '1':
			// Recall.í”Œë ˆì´ì–´ê°€ ì†Œì†ëœ ë§ˆì„ì˜ ì§„ìž… í¬ì¸íŠ¸ë¡œ ê°„ë‹¤.
			// ë§Œì•½ ë¶€í™œì¡´ì´ë¼ë©´ ë¦¬ì½œë˜ì§€ ì•ŠëŠ”ë‹¤.
			// if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, "resurr", 6) == 0) return;

			ZeroMemory(cTempMapName, sizeof(cTempMapName));
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				strcpy(cTempMapName, "default");
			}
			else {				
				// v2.14 ·¹º§ 80 ÀÌÇÏ´Â ¸®ÄÝ½Ã ³ó°æÁö·Î °£´Ù.
				if (m_pClientList[iClientH]->m_iLevel > 80)
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) 
						strcpy(cTempMapName, "aresden");
					else strcpy(cTempMapName, "elvine");
				else {
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) 
						strcpy(cTempMapName, "arefarm");
					else strcpy(cTempMapName, "elvfarm");
				}
			}
			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
				bIsLockedMapNotify = true;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for (i = 0; i < DEF_MAXMAPS; i++)
				if (m_pMapList[i] != 0) {
					if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
						// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸í•  ë§µì´ ì¡´ìž¬í•œë‹¤.

						GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

						m_pClientList[iClientH]->m_cMapIndex = i; // ë§µ ì¸ë±ìŠ¤ë¥¼ ë°”ê¾¼ë‹¤.
						ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
						goto RTH_NEXTSTEP;
					}
				}

				// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
				m_pClientList[iClientH]->m_sX   = -1;	  // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
				m_pClientList[iClientH]->m_sY   = -1;	  // -1ì€ InitialPointë¥¼ ë§í•œë‹¤.

				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.

				// New 18/05/2004
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
					m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], 0, 0);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

				// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì‘ë‹µì„ ë°›ì€ í›„ ìž¬ì ‘ì†ì„ ì•Œë ¤ì•¼ í•œë‹¤.
				//bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false); // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.
				// !!!
				m_pClientList[iClientH]->m_bIsOnServerChange   = true;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
				return;

		case '2':
			// ëª©ì ì§€ê°€ ì§€ì •ëœ í…”ë ˆí¬íŠ¸.

			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = true;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			else {
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}

			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				// í˜„ìž¬ ì„œë²„ì— ëª©ì ì§€ê°€ ì—†ë‹¤. 
				// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
				m_pClientList[iClientH]->m_sX   = dX; //-1;	  // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
				m_pClientList[iClientH]->m_sY   = dY; //-1;	  // -1ì€ InitialPointë¥¼ ë§í•œë‹¤.

				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
				// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì‘ë‹µì„ ë°›ì€ í›„ ìž¬ì ‘ì†ì„ ì•Œë ¤ì•¼ í•œë‹¤.

				// New 18/05/2004
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
					m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], 0, 0);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

				//bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false); // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.
				// !!!
				m_pClientList[iClientH]->m_bIsOnServerChange   = true;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
				return;
			}

			m_pClientList[iClientH]->m_sX   = dX;
			m_pClientList[iClientH]->m_sY   = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;

			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			break;
		}
	}

RTH_NEXTSTEP:

	// New 17/05/2004
	SetPlayingStatus(iClientH);
	int iTemp, iTemp2;
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFFFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;

	// Crusade
	if (bIsLockedMapNotify ) SendNotifyMsg(0, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, 0, 0, m_pClientList[iClientH]->m_cLockedMapName);

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);

	// ë§µë°ì´í„°ë¥¼ ì „ì†¡í•œë‹¤.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	// í”Œë ˆì´ì–´ì˜ ìœ„ì¹˜ë¥¼ í™•ì •í•œë‹¤.
	if (m_pClientList[iClientH]->m_bIsObserverMode == false)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// ì „ì†¡í•  ë§µ ë°ì´í„°ì˜ ê¸°ì¤€ìœ„ì¹˜. í”Œë ˆì´ì–´ëŠ” ê¸°ì¤€ìœ„ì¹˜ (x, y)ë¡œë¶€í„° (x+14, y+12)ì— ìœ„ì¹˜í•œë‹¤.
	sp  = (short *)cp;
	*sp = iClientH;		// Player ObjectID
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;
	// v1.4 ApprColor
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;

	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4;//Original 2

	// (!) í”Œë ˆì´ì–´ê°€ ìœ„ì¹˜í•˜ëŠ” ë§µì´ë¦„ì„ ê¸°ë¡í•œë‹¤.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	// ëª…ì¹­ìƒì˜ ë§µ ì´ë¦„ì„ ìž…ë ¥í•œë‹¤. 
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	// ì£¼ì•¼ê°„ ëª¨ë“œë¥¼ ì‚½ìž… 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode ) 
		*cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	// ê¸°ìƒ ìƒíƒœ ëª¨ë“œë¥¼ ì‚½ìž… 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode ) 
		*cp = 0;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;

	// @@@ í”Œë ˆì´ì–´ë¥¼ ë§µìƒì— ìµœì´ˆë¡œ ìœ„ì¹˜ì‹œí‚¨ë‹¤.
	if (m_pClientList[iClientH]->m_bIsObserverMode == false) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, 
			DEF_OWNERTYPE_PLAYER, 
			m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;

	// v1.41 
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;
	//Unknown variable
	*cp = 0;
	cp++;

	// ë§µì˜ ì •ë³´ë¥¼ ì¶”ê°€í•œë‹¤. 
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 12, m_pClientList[iClientH]->m_sY - 9, iClientH, cp );
	// ë©”ì‹œì§€ ì „ì†¡ 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4 + 3); //Zabuza fix
	//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4); // v1.41
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ë•Œ ì—ëŸ¬ê°€ ë°œìƒí–ˆë‹¤ë©´ ì œê±°í•œë‹¤.
		DeleteClient(iClientH, true, true);
		if(pBuffer != 0) delete[] pBuffer;
		return;
	}

	if(pBuffer != 0) delete[] pBuffer;

	// ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ë“¤ì—ê²Œ í”Œë ˆì´ì–´ê°€ ìƒˆë¡œìš´ ìœ„ì¹˜ì— ë‚˜íƒ€ë‚¬ìŒì„ ì•Œë¦°ë‹¤. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);

	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) && 
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) && 
		(m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = true;
			// New 17/05/2004
			CheckForceRecallTime(iClientH);
		}
	else if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) && 
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) && 
			(m_pClientList[iClientH]->m_iAdminUserLevel == 0) ) {

				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = true;

				// New 17/05/2004
				CheckForceRecallTime(iClientH);
			}
		else if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone  ) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = true;
			SetForceRecallTime(iClientH) ;

			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;  

		} else {
			m_pClientList[iClientH]->m_bIsWarLocation = false;	
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
			SetForceRecallTime(iClientH) ;
		}

		// No entering enemy shops
		int iMapside, iMapside2;

		iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
		if (iMapside > 3) iMapside2 = iMapside - 2;
		else iMapside2 = iMapside;
		m_pClientList[iClientH]->m_bIsInsideOwnTown = false;
		if ((m_pClientList[iClientH]->m_cSide != iMapside2) && (iMapside != 0)) {
			if ((iMapside <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
				if (m_pClientList[iClientH]->m_cSide != 0) {
					m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
					m_pClientList[iClientH]->m_bIsWarLocation = true;
					m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
					m_pClientList[iClientH]->m_bIsInsideOwnTown = true;
				}
			}
		}
		else{
			if (m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsFightZone  &&
				m_iFightzoneNoForceRecall == false && 
				m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
					m_pClientList[iClientH]->m_bIsWarLocation = true;
					GetLocalTime(&SysTime);
					m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;
				}
			else{
				if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "arejail", 7) == 0 ||
					memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "elvjail", 7) == 0) {
						if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
							m_pClientList[iClientH]->m_bIsWarLocation = true;
							m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
							if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0)
								m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
							else if(m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100)
								m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
						}
					}
			}
		}

		// ì¶”ê°€ë¡œ ë³´ë‚´ì¤˜ì•¼ í•  ì •ë³´ë¥¼ ë³´ë‚¸ë‹¤. v1.1
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SAFEATTACKMODE, 0, 0, 0, 0);
		// v1.3
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, 0, 0, 0);
		// V1.3
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMPOSLIST, 0, 0, 0, 0);
		// v1.4 
		_SendQuestContents(iClientH);
		_CheckQuestEnvironment(iClientH);

		// v1.432
		if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0)
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, 0, 0, 0, 0);

		// Crusade íš‰ì² ?ì±Œ íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ CrusadeGUIDì§¸ì§• 0 íšŠì§š?ì¨˜ íš‰ì² ?ì±Œì©”íš’ ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢ì¨ì±• íš„ì¨€?ì© íš‰íš˜ì¨ˆì±Œì¨‰íš‰ì¨ˆíš‚ ì§¸íš’?íš‘ì¨ˆíš¢. íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì©”ì§§íš‰íš˜ íš„íšŽì§¹ì°½íšŠì§¯.
		if (m_bIsCrusadeMode ) {
			if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
				// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ GUIDì§¸ì§• 0?íš‘ì¨‹ì²œ ì§¸íš’?ì¨˜ íš„ì¨€?ì© íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…ì©”ì§• ì¨‰ì±•ì©ì±¤ì©”íššì¨ˆíš¢ì¨ˆíš‚ ?íš‰ì¨”íš‘. ì©”ì§§íš‰íš˜ íš„íšŽì§¹ì°½íšŠì§¯.
				m_pClientList[iClientH]->m_iCrusadeDuty = 0;
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
				m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			}
			else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
				// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ GUIDì§¸ì§• íš‰ì² ?ì±Œ íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì©íšˆ?íš‘ì¨‰ì±¨ì©”íš’ ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢ì¨ˆíš‚ ì§¸íš’?ì¨˜ ?ì²¬ì¨”ì²©ì©”ì§• ì¨”ì²¬ì©ì±¤íšì¨€ì¨ˆì²© íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…?íš‰ ì§¸ì°¼ì§¸ì²¬?íš‘ì¨ˆíš¢.
				// ?íš‘ì¨Œì§¹ ì§¸ì±ˆì©”ì±™ ?ì²´ì§¸ì²©ì©”ì§• ì¨‰ì²­ì¨ì§œ íšˆì²¨ì¨©ì²˜?ì¨© íš‰íš˜ ì©Œì²  ì©ì²©ì¨ˆíš¢. íš„íšœì©Œíš˜íš‰íš— íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…ì§¸ì§• íšì©ì¨Œì°¼ì¨‰íšŠ ì¨ˆíš¢?ì© ì¨ˆíš¢?ì© ?ì²´ì¨ì±•?ì²´?íš‘ ì©íš„?íš¤ì¨‰íš‰ì§¹ì°½ ?ì²´ì©”ì§• íšì§–ì©Œíš™?ì¨© íš‰íš ì©íš© íšˆì²¨ì¨©ì²˜?ì¨© ì©ì±µ?ì¨© ì©Œì²  ?íšœì¨ˆíš¢.
				// ?íš‘?ì²´ì©”ì§• íš‰íš˜ì¨ˆì±Œì¨‰íš‰ì©ì²¬ì¨ˆì²© ì©”ì§§íš‰íš˜, ì§¸íš‰ì©Œì¨€ íšˆì²¨?íš“íšˆì§°, ?ì²´?ì±¦ ì§¸ì²©íš‰ì±…ì¨‰ì¨‰ íš„íšŽì§¹ì°½íšŠì§¯.
				m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
				m_pClientList[iClientH]->m_iWarContribution   = 0;
				m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
				// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… GUIDì§¸ì§• ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢. íšˆì²¨ì¨©ì²˜ ì¨˜íš˜ì§¸ì§•.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);		
			}
			m_pClientList[iClientH]->m_cVar = 1;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, 0);
		}
		else if (m_bIsHeldenianMode ) {
			sSummonPoints = m_pClientList[iClientH]->m_iCharisma*300;
			if (sSummonPoints > DEF_MAXSUMMONPOINTS) sSummonPoints = DEF_MAXSUMMONPOINTS;
			if (m_pClientList[iClientH]->m_dwHeldenianGUID == 0) {
				m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
				m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			}
			else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) {
				m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
				m_pClientList[iClientH]->m_iWarContribution = 0;
				m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
			}
			m_pClientList[iClientH]->m_cVar = 2;
			if (m_bIsHeldenianMode ) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, 0);
			}
			if (m_bHeldenianInitiated ) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0);
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, 0);
			UpdateHeldenianStatus();
		}
		else if ((m_pClientList[iClientH]->m_cVar == 1) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
		}
		else {
			if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
				if (m_pClientList[iClientH]->m_cVar == 1) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);
				}
			}
			else {
				m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
				m_pClientList[iClientH]->m_iWarContribution   = 0;
				m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			}
		}		

		// v1.42
		// 2002-7-4 Â»Ã§Ã…ÃµÃ€Ã¥Ã€Ã‡ Â°Â¹Â¼Ã¶Â¸Â¦ Â´ÃƒÂ¸Â± Â¼Ã¶ Ã€Ã–ÂµÂµÂ·Ã 
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
			PutLogEventFileList(G_cTxt);
		}

		// Crusade
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, 0);

		// v2.15
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

		if (m_bIsHeldenianMode ) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, 0);
			if (m_bHeldenianInitiated ) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0);
			}
			else {
				UpdateHeldenianStatus();
			}
		}
		
		if (m_pClientList[iClientH]->m_iQuest != 0) { 
				cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, 0, 0, 0);
				_bCheckIsQuestCompleted(iClientH);
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_HUNGER, m_pClientList[iClientH]->m_iHungerStatus, 0, 0, 0);
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
}

void CGame::ReleaseFollowMode(short sOwnerH, char cOwnerType)
{
 int i;

	for (i = 0; i < DEF_MAXNPCS; i++)
	if ((i != sOwnerH) && (m_pNpcList[i] != 0)) {
		if ((m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) &&
			(m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) &&
			(m_pNpcList[i]->m_cFollowOwnerType == cOwnerType)) {
			
			m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
		}
	}
}

bool CGame::_bDecodeMagicConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iMagicConfigListIndex = 0;
 class CStrTok * pStrTok;

 char cData[50000] = {};
 DWORD lpNumberOfBytesRead;
 HANDLE hFile = CreateFile(pData, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
 DWORD dwFileSize = GetFileSize(hFile, 0);
 if (dwFileSize == -1) {
	 wsprintf(G_cTxt, "(X) CRITICAL ERROR! Cannot open configuration file(%s)!", pData);
	 PutLogList(pData);
	 return false;
 }

 SetFilePointer(hFile, 0, 0, FILE_BEGIN);

 ReadFile(hFile, cData, dwFileSize, &lpNumberOfBytesRead, 0);
 CloseHandle(hFile);

 pContents = new char[dwFileSize + 1];
 ZeroMemory(pContents, dwFileSize + 1);
 memcpy(pContents, cData, dwFileSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != 0 ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ¸¶¹ý ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					if (m_pMagicConfigList[atoi(token)] != 0) {
						// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Duplicate magic number.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[atoi(token)] = new class CMagic;
					iMagicConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// ¸¶¹ý ÀÌ¸§ 
					ZeroMemory(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, sizeof(m_pMagicConfigList[iMagicConfigListIndex]->m_cName));
					memcpy(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// ¸¶¹ý Á¾·ù m_sType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// ¸¶¹ý µô·¹ÀÌ ½Ã°£ m_dwDelayTime
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// ¸¶¹ý Áö¼Ó½Ã°£ m_dwLastTime
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwLastTime = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 7;
					break;
				
				case 7:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// m_sValue7
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue7 = atoi(token);
					cReadModeB = 13;
					break;
				
				case 13:
					// m_sValue8
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue8 = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// m_sValue9
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue9 = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// m_sValue10
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue10 = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// m_sValue11
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue11 = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// m_sValue12
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue12 = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// m_sIntLimit
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sIntLimit = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// m_iGoldCost
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iGoldCost = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_iAttribute
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iAttribute = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(0, seps);
	}	

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) MAGIC(Total:%d) configuration - success!", iMagicConfigListIndex);
	PutLogList(cTxt);

	return true;

}



bool CGame::_bDecodeSkillConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iSkillConfigListIndex = 0;
 class CStrTok * pStrTok;

 char cData[50000] = {};
 DWORD lpNumberOfBytesRead;
 HANDLE hFile = CreateFile(pData, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
 DWORD dwFileSize = GetFileSize(hFile, 0);
 if (dwFileSize == -1) {
	 wsprintf(G_cTxt, "(X) CRITICAL ERROR! Cannot open configuration file(%s)!", pData);
	 PutLogList(pData);
	 return false;
 }

 SetFilePointer(hFile, 0, 0, FILE_BEGIN);

 ReadFile(hFile, cData, dwFileSize, &lpNumberOfBytesRead, 0);
 CloseHandle(hFile);

 pContents = new char[dwFileSize + 1];
 ZeroMemory(pContents, dwFileSize + 1);
 memcpy(pContents, cData, dwFileSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != 0 ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ½ºÅ³ ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					if (m_pSkillConfigList[atoi(token)] != 0) {
						// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Duplicate magic number.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pSkillConfigList[atoi(token)] = new class CSkill;
					iSkillConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// ½ºÅ³ ÀÌ¸§ 
					ZeroMemory(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, sizeof(m_pSkillConfigList[iSkillConfigListIndex]->m_cName));
					memcpy(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// ½ºÅ³ Á¾·ù m_sType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(0, seps);
	}	

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) SKILL(Total:%d) configuration - success!", iSkillConfigListIndex);
	PutLogList(cTxt);

	return true;
}

// 12-22 Ĵ   ⿡   Ŭ̾Ʈ ش.
void CGame::RequestStudyMagicHandler(int iClientH, char * pName, bool bIsPurchase)
{
 char  * cp, cMagicName[31], cData[100];
 DWORD * dwp, dwGoldCount;
 WORD  * wp;
 int   * ip, iReqInt, iCost, iRet;
 bool bMagic = true ;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	//  . 
	ZeroMemory(cData, sizeof(cData));	

	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);
	
	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) {
		// ̷ ̸   ʴ´. Ѵ. 

	}
	else {
		if (bIsPurchase ) {
			if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = false ; // Ϲ   ̶( )   .
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if ((DWORD)iCost > dwGoldCount)  bMagic = false ; //  ص   .
		}
	    //wizard remove
		//if (m_pClientList[iClientH]->m_bIsInsideWizardTower == false && bIsPurchase) return;
		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;

		if ((iReqInt <= (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt)) && (bMagic ) ) {
			
			//   ˸.
			if (bIsPurchase ) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);
			
			// ǰ  ߷   
			iCalcTotalWeight(iClientH);
		
			//   ɷ ǥ .
			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;
	
			//  ٴ ޽ Ѵ.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYSUCCESS;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			
			//  ȣ 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			//   
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);

			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ޽   ߻ߴٸ Ѵ.
				DeleteClient(iClientH, true, true);
				return;
			}
		}
		else {
			//   ʾ    .
			//   ٴ ޽ Ѵ.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYFAIL;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// .
			*cp = 1;
			cp++;

			//  ȣ 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			ip = (int *)cp;
			*ip = iCost;
			cp += 4;

			ip = (int *)cp;
			*ip = iReqInt;
			cp += 4;

			//   
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ޽   ߻ߴٸ Ѵ.
				DeleteClient(iClientH, true, true);
				return;
			}
		}
	}
}

int CGame::_iGetMagicNumber(char * pMagicName, int * pReqInt, int * pCost)
{
 int i;
 char cTmpName[31];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) 
	if (m_pMagicConfigList[i] != 0) {
		if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {
			// °°Àº ÀÌ¸§À» °¡Áø ¸¶¹ý ¼³Á¤À» Ã£¾Ò´Ù. ¸¶¹ý ¹øÈ£¸¦ ¹ÝÈ¯ÇÑ´Ù.
			*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
			*pCost   = (int)m_pMagicConfigList[i]->m_iGoldCost;
			
			return i;
		}
	}
	
	return -1;
}

void CGame::TrainSkillResponse(bool bSuccess, int iClientH, int iSkillNum, int iSkillLevel)
{
 char  * cp, cData[100];
 DWORD * dwp;
 WORD  * wp;
 int   iRet;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((iSkillNum < 0)	|| (iSkillNum > 100)) return;
	if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;

	if (bSuccess ) {
		// ̹   ¶ ҿ .
		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] != 0) return;
		
		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
		//     Ѵ.
		bCheckTotalSkillMasteryPoints(iClientH, iSkillNum);

		//  ٴ ޽ Ѵ.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_SKILLTRAINSUCCESS;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// ȣ
		*cp = iSkillNum;
		cp++;
		
		//   .
		*cp = iSkillLevel;
		cp++;
	 
		//wsprintf(G_cTxt, "Skill Improve: (%s) increased (%s) at %s (%d,%d).", m_pClientList[iClientH]->m_cCharName, m_pSkillConfigList[iSkillNum]->m_cName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		//PutLogFileList(G_cTxt);

		if (m_pSkillConfigList[iSkillNum]->m_cName != 0) 
			_bItemLog(DEF_ITEMLOG_SKILLLEARN,iClientH,m_pSkillConfigList[iSkillNum]->m_cName,0);

		//   
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 8);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ޽   ߻ߴٸ Ѵ.
			DeleteClient(iClientH, true, true);
			return;
		}
	}
	else {


	}

}


int CGame::_iGetSkillNumber(char * pSkillName)
{
 int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pSkillName);

	for (i = 1; i < DEF_MAXSKILLTYPE; i++) 
	if (m_pSkillConfigList[i] != 0) {
		if (memcmp(cTmpName, m_pSkillConfigList[i]->m_cName, 20) == 0) {
			// °°Àº ÀÌ¸§À» °¡Áø ±â¼ú ¼³Á¤À» Ã£¾Ò´Ù. ±â¼ú ¹øÈ£¸¦ ¹ÝÈ¯ÇÑ´Ù.
			return i;
		}
	}
	
	return 0;
}

bool CGame::bPlayerItemToBank(int iClientH, short sItemIndex)
{
 int i, iIndex;

	if (m_pClientList[iClientH] == 0) return false;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {
		iIndex = i;
		goto NEXT_STEP_PLTB;
	}
	// ´õÀÌ»ó ÀúÀåÇÒ °ø°£ÀÌ ¾ø´Ù. 
	return false;

NEXT_STEP_PLTB:

	// ¾ÆÀÌÅÛÀ» ÀúÀåÇÒ °ø°£ÀÌ ³²¾ÆÀÖ´Ù. 
	// ¸ÕÀú ÀåÂøµÇ¾î ÀÖ´Ù¸é ÇØÁ¦½ÃÅ²´Ù.
	ReleaseItemHandler(iClientH, sItemIndex, true);

	// ¾ÆÀÌÅÛ Å¬·¡½ºÀÇ ÁÖ¼Ò¸¦ ¹Ù²Û´Ù. 
	m_pClientList[iClientH]->m_pItemInBankList[iIndex] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
	// ÇÃ·¹ÀÌ¾î ¾ÆÀÌÅÛ ¸®½ºÆ®¸¦ Å¬¸®¾îÇÏ°í 
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;

	// ¾ÆÀÌÅÛ ¸®½ºÆ®ÀÇ ºó °ø°£À» »èÁ¦ÇÑ´Ù.
	for (i = 1; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i-1] == 0) && (m_pClientList[iClientH]->m_pItemList[i] != 0)) {
		m_pClientList[iClientH]->m_pItemList[i-1]       = m_pClientList[iClientH]->m_pItemList[i];	
		m_pClientList[iClientH]->m_bIsItemEquipped[i-1] = m_pClientList[iClientH]->m_bIsItemEquipped[i];	
		m_pClientList[iClientH]->m_pItemList[i]   = 0;
		m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;
	}

	return true;
}



bool CGame::bBankItemToPlayer(int iClientH, short sItemIndex)
{
 int i, iIndex;

	if (m_pClientList[iClientH] == 0) return false;
	
	if (m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] == 0) return false;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == 0) {
		iIndex = i;
		goto NEXT_STEP_PLTB;
	}
	// ´õÀÌ»ó °®°íÀÖÀ» °ø°£ÀÌ ¾ø´Ù. 
	return false;

NEXT_STEP_PLTB:

	// ¾ÆÀÌÅÛÀ» ¼ÒÁöÇÒ °ø°£ÀÌ ³²¾ÆÀÖ´Ù. 
	
	// ¾ÆÀÌÅÛ Å¬·¡½ºÀÇ ÁÖ¼Ò¸¦ ¹Ù²Û´Ù. 
	m_pClientList[iClientH]->m_pItemList[iIndex] = m_pClientList[iClientH]->m_pItemInBankList[sItemIndex]; 
	
	m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] = 0;

	return true;
}



bool CGame::__bReadMapInfo(int iMapIndex)
{
 char * pContents, * token, * pTile,  cTxt[250], cFn[255];	 
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iTeleportLocIndex  = 0;
 int  iWayPointCfgIndex  = 0;
 int  iTotalNpcSetting   = 0;
 int  iMGARCfgIndex      = 0;
 int  iSMGRCfgIndex      = 0;
 int  iNMRCfgIndex       = 0;
 int  iFishPointIndex 	 = 0;
 int  iMineralPointIndex = 0;
 int  iStrategicPointIndex = 0;
 int  iIndex = 0;

 int  iNamingValue;
 class CStrTok * pStrTok;
 HANDLE hFile;
 DWORD  dwFileSize, dwReadSize;
 FILE * pFile;

 char cName[6], cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix;
 short sIPindex, dX, dY;

	// »çÅõÀåÀÎÁö¸¦ ÆÇ´Ü.
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fightzone", 9) == 0) 
		m_pMapList[iMapIndex]->m_bIsFightZone = true;

	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0) 
		m_pMapList[iMapIndex]->m_bIsSnowEnabled = true;

	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");
	
	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) return false;
	dwFileSize = GetFileSize(hFile, 0);
	CloseHandle(hFile);


	pContents = new char[dwFileSize+1];
	ZeroMemory(pContents, dwFileSize+1);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		// ¸Ê Á¤º¸ÆÄÀÏÀ»  ÀÐÀ» ¼ö ¾ø´Ù.
		wsprintf(cTxt, "(!) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return false;
	}
	else {
		wsprintf(cTxt, "(!) Reading Map info file : %s", cFn);
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != 0 ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ÅÚ·¹Æ÷Æ® ¼Ò½º ÁÂÇ¥ X  
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// ÅÚ·¹Æ÷Æ® ¼Ò½º ÁÂÇ¥ Y 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö ¸Ê ÀÌ¸§ 
					ZeroMemory(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, 
						       sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
					strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
					cReadModeB = 4;
					break;

				case 4:
					// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö À§Ä¡ X 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö À§Ä¡ Y 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
					cReadModeB = 6;
					break;
				
				case 6:
					// ÅÚ·¹Æ÷Æ® ÈÄ ¹æÇâ  
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
					iTeleportLocIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2:
				switch (cReadModeB) {
				case 1:
					// waypoint ¹øÈ£   
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iWayPointCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Waypoint ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// waypoint ÁýÇÕ Á¤ÀÇ X  
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// waypoint ÁýÇÕ Á¤ÀÇ Y  
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 3:
				// Npc¸¦ Æ¯Á¤À§Ä¡¿¡ À§Ä¡½ÃÅ²´Ù.
				switch (cReadModeB) {
				case 1:
					// NPCÀÇ ÀÌ¸§. 
					ZeroMemory(cNpcName, sizeof(cNpcName));
					strcpy(cNpcName, token);
					cReadModeB = 2;
					break;
				case 2:
					// NpcMoveType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					cNpcMoveType = atoi(token);
					cReadModeB = 3;
					break;
				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					cNpcWaypointIndex[cReadModeB-3] = atoi(token);
					cReadModeB++;
					break;
				case 13:
					// cNamePrefix
					cNamePrefix = token[0];
					// ÀÌÁ¦ ÀÌ°÷¿¡¼­ NPC¸¦ »ý¼ºÇÑ´Ù. 
					
					iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {
						// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
					}
					else {
						// NPC¸¦ »ý¼ºÇÑ´Ù.
						ZeroMemory(cName, sizeof(cName));
						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = cNamePrefix;
						cName[1] = iMapIndex+65;
											
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, 0, 0, cNpcWaypointIndex, 0, 0, -1, false) == false) {
							// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
							m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
						} 
					}
					cReadModeA = 0;
					cReadModeB = 0;
					iTotalNpcSetting++;
					break;
				}
				break;

			case 4:
				switch (cReadModeB) {
				case 1:
					// Random-Mob-Generator »ç¿ë ¿©ºÎ 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_bRandomMobGenerator = (bool)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// Mob- Level
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:
				// Maximum object
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}

				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6:
				// Ä³¸¯ÅÍ ·£´ý »ý¼º ±ÝÁö ±¸¿ª : ¸¶À» Áß½ÉºÎ °°Àºµ¥¼­ ¸÷ÀÌ ¹ß»ýµÇ¸é °ï¶õÇÏ¹Ç·Î 
				switch (cReadModeB) {
				case 1:
					// Rect ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iMGARCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Waypoint ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete[] pContents;
						delete pStrTok;
						return false;
					}

					cReadModeB = 2;
					break;

				case 2:
					// left
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// top
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// right
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// bottom
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 7:
				// Æ¯Á¤Áö¿ª ¸÷ »ý¼º 
				switch (cReadModeB) {
				case 1:
					// Rect ¹øÈ£ m_stSpotMobGenerator[]
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iSMGRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined ) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â ¸÷ Á¦³Ê·¹ÀÌÅÍ ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error - ");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = true;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
						cReadModeB = 3;
					else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
						cReadModeB = 9;  // RECT°¡ ¾Æ´Ï¶ó WaypointÁýÇÕÀ» ÀÐ¾î¾ß ÇÑ´Ù.
					break;

				case 3:
					// left
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// top
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// right
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// bottom
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// Max Mobs
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
			   		break;

				case 19:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			  	}
				break;

			case 8:
				// ¸ÊÀÌ ¼ÓÇÑ Àå¼Ò ÀÌ¸§ 
				ZeroMemory(m_pMapList[iMapIndex]->m_cLocationName, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
				memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 9:
				switch (cReadModeB) {
				case 1:
					// Initial-Point Index
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					sIPindex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// Initial-Point X
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Initial-Point Y
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
		
			case 10:
				// °ø°Ý ¹«È¿È­ ¿µ¿ª RECT
				switch (cReadModeB) {
				case 1:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iNMRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â No-Magic-Rect ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 11:
				m_pMapList[iMapIndex]->m_bIsFixedDayMode = (bool)atoi(token);
				if (m_pMapList[iMapIndex]->m_bIsFixedDayMode )
					m_pMapList[iMapIndex]->m_bIsSnowEnabled = false;
				cReadModeA = 0;
				break;

			case 12:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iFishPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Fish Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pMapList[iMapIndex]->m_iTotalFishPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

				cReadModeA = 0;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_cType = atoi(token);

				cReadModeA = 0;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 16:
				// ±¤¹° Á¦³×·¹ÀÌÅÍÀÇ Á¸ÀçÀ¯¹«¿Í µî±Þ 
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_bMineralGenerator = (bool)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 17:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iMineralPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Mineral Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 18:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

				cReadModeA = 0;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 20:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iStrategicPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != 0) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Strategic Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 21:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != 0) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Energy-Sphere-Creation Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 22:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 66 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != 0) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Energy-Sphere-Goal Point ¹øÈ£ÀÌ´Ù.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
						PutLogList(G_cTxt);
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 68 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);
					
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 23:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != 0) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â  Point ¹øÈ£ÀÌ´Ù.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
						PutLogList(G_cTxt);
						delete[] pContents;
						delete pStrTok;
						return false;
					}
										
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
					cReadModeB = 5;
					break;


				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);
					
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);
					
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);
					
					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);
					
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);
					
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);
					
					cReadModeB = 12;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);
					
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);
					
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);
					
					cReadModeB = 15;
					break;

				case 15:
					ZeroMemory(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
					strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);
					
					m_pMapList[iMapIndex]->m_iTotalStrikePoints++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break; // end 23

			case 24:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != 0) {
						// ̹ ҴǾִ Item-Event ȣ̴.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
						PutLogList(G_cTxt);
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pMapList[iMapIndex]->m_iTotalItemEvents++;
					cReadModeB = 2;
					break;
				
				case 2:
					strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);
					
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 25: //mobevent-amount
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
					cReadModeB = 0;
					break;
				}
				break;

			case 26: //ApocalypseMobGenType
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMobGenType - Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_iApocalypseMobGenType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 27: // ApocalypseBossMob
				switch (cReadModeB) {
				case 1: // 3CB6Ch m_pMapList[]->m_ApocalypseBossMobNpcID
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = atoi(token);
					cReadModeB = 2;					
					break;
				case 2: // 3CB70h m_pMapList[]->ApocalypseBossMobRectX1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectX1 = atoi(token);
					cReadModeB = 3;					
					break;
				case 3: // 3CB74h m_pMapList[]->ApocalypseBossMobRectY1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectY1 = atoi(token);
					cReadModeB = 4;					
					break;
				case 4: // 3CB78h m_pMapList[]->ApocalypseBossMobRectX2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectX2 = atoi(token);
					cReadModeB = 5;					
					break;
				case 5: // 3CB7Ch m_pMapList[]->ApocalypseBossMobRectY2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectY2 = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;					
					break;
				}
				break;

			case 28: //DynamicGateType // 28
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateType - Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_cDynamicGateType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
								
			case 29: //DynamicGateCoord // 29
				// DynamicGateCoord	= 59 196 60 197        abaddon	   -1  -1
				switch (cReadModeB) {
				case 1: // 3CA20h
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 = atoi(token);
					cReadModeB = 2;
					break;

				case 2: // 3CA24h
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 = atoi(token);
					cReadModeB = 3;
					break;

				case 3: // 3CA28h
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2 = atoi(token);
					cReadModeB = 4;
					break;

				case 4: // 3CA2Ch
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5: // 3CA30h
					memcpy(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, token, strlen(token));
					cReadModeB = 6;
					break;

				case 6: // 3CA3Ch
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // (ty = 3CB60h) unknown (3CA3Eh)
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 30: // RecallImpossible // 30
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error RecallImpossible -  Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsRecallImpossible = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 31: // ApocalypseMap // 31
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMap -  Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsApocalypseMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
			
			case 32: // CitizenLimit // 32
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsCitizenLimit = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
					
			case 33: // HeldenianMap
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsHeldenianMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 34: // HeldenianTower
				switch (cReadModeB) {
				case 1: // NpcID
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian tower type id - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].sTypeID = atoi(token);
					cReadModeB = 2;
					break;
				case 2: // side 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Side - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].cSide = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // sX
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower X pos - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].dX = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // sY
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Y pos - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 35: // HeldenianModeMap
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
					delete[] pContents;
					delete pStrTok;
					return false;
				}
				m_pMapList[iMapIndex]->m_cHeldenianModeMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 36: // HeldenianWinningZone
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					dX = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					dY = atoi(token);
					pTile = 0;
					pTile = (char *)(m_pMapList[iMapIndex]->m_pTile + dX + dY*m_pMapList[iMapIndex]->m_sSizeY);
					if (pTile == 0) {
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map Info file error HeldenianWinningZone - pTile is Null dx(%d), dy(%d).", dX, dY);
						PutLogList(cTxt);
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					//pTile->m_iAttribute = 1;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 37: // HeldenianGateDoor // 37
				switch (cReadModeB) {
				case 1: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Direction - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].cDir = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door X pos - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dX = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Y pos - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dY = atoi(token);
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "maximum-object", 14) == 0) 
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;	
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;	
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;	

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;	
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;	// v1.4
			if (memcmp(token, "strategic-point", 15) == 0) {	// v1.41
				cReadModeA = 20;	
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "item-event", 10) == 0) {
				cReadModeA = 24;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "energy-sphere-auto-creation", 27) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				m_pMapList[iMapIndex]->m_bIsEnergySphereAutoCreation = true;
			}

			if (memcmp(token, "mobevent-amount", 15) == 0) {
				cReadModeA = 25;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMobGenType", 20) == 0) {
				cReadModeA = 26;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseBossMob", 17) == 0) {
				cReadModeA = 27;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateType", 15) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateCoord", 16) == 0) {
				cReadModeA = 29;
				cReadModeB = 1;
			}

			if (memcmp(token, "RecallImpossible", 16) == 0) {
				cReadModeA = 30;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "ApocalypseMap", 13) == 0) {
				cReadModeA = 31;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "CitizenLimit", 12) == 0) {
				cReadModeA = 32;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianMap", 12) == 0) {
				cReadModeA = 33;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianTower", 14) == 0) {
				cReadModeA = 34;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianModeMap", 16) == 0) {
				cReadModeA = 35;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianWinningZone", 20) == 0) {
				cReadModeA = 36;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianGateDoor", 17) == 0) {
				cReadModeA = 37;
				cReadModeB = 1;
			}

			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}	

RMI_SKIPDECODING:

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! map info file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) Map info file decoding(%s) - success! TL(%d) WP(%d) LNPC(%d) MXO(%d) RMG(%d / %d)", cFn, iTeleportLocIndex, iWayPointCfgIndex, iTotalNpcSetting, m_pMapList[iMapIndex]->m_iMaximumObject, m_pMapList[iMapIndex]->m_bRandomMobGenerator, m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel);
	PutLogList(cTxt);

	// Crusade °ø°Ý ºÒ°¡´É ¿µ¿ªÀ» Å¸ÀÏ¿¡ Ç¥½ÃÇÑ´Ù.
	m_pMapList[iMapIndex]->_SetupNoAttackArea();

	return true;

}

void CGame::Quit()
{
 int i;	

	// ¾²·¹µå¸¦ Á×ÀÎ´Ù.
	G_bIsThread = false;
	Sleep(300);
		
	/*if (m_pMainLogSock != 0) delete m_pMainLogSock;
	if (m_pGateSock != 0) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != 0) delete m_pSubLogSock[i];*/

	if (_lsock != 0) delete _lsock;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != 0) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != 0) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != 0) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != 0) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != 0) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != 0) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != 0) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != 0) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != 0) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != 0) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
	if (m_pNoticeMsgList[i] != 0) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != 0) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != 0) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		if (m_pPortionConfigList[i] != 0) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != 0) delete m_pCraftingConfigList[i];	// Crafting
	}

//	for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
//	if (m_pTeleportConfigList[i] != 0) delete m_pTeleportConfigList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != 0) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != 0) delete m_pDupItemIDList[i];

	if (m_pNoticementData != 0) delete m_pNoticementData;

}

DWORD CGame::iGetLevelExp(int iLevel)
{
 DWORD iRet;
	
	if (iLevel == 0) return 0;
	
	iRet = iGetLevelExp(iLevel - 1) + iLevel * ( 50 + (iLevel * (iLevel / 17) * (iLevel / 17) ) );

	return iRet;
}

int CGame::_iCalcSkillSSNpoint(int iLevel)
{
 int iRet;

	if (iLevel < 1) return 1;
	
	if (iLevel <= 50) 
		iRet = iLevel;
	else if (iLevel > 50) {
		iRet = ( iLevel * 2 );
	}

	return iRet;
}

/*****************************************************************
**---------------------------FUNCTION---------------------------**
**             void Game::CheckLevelUp(int iClientH)            **
**-------------------------DESCRIPTION--------------------------**
** Level-Up                                                     **
**  - Level +1                                                  **
**  - +3 Level Up Points                                        **
**  - Reset Next Level EXP                                      **
**  - Civilian Level Limit                                      **
**      Player mode switches to Combatant                       **
**      when the limit is reached                               **
**  - Majestic Points +1                                        **
**  - Reset Next Level EXP                                      **
**------------------------CREATION DATE-------------------------**
**                January 30, 2007; 3:06 PM; Dax                **
*****************************************************************/
bool CGame::bCheckLevelUp(int iClientH)
{

 if (m_pClientList[iClientH] == 0) return false;
 if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return false;

	while (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) 
	{
		if (m_pClientList[iClientH]->m_iLevel < m_iPlayerMaxLevel) 
		{
			// ·¹º§ÀÌ ¿Ã¶ú´Ù.
			m_pClientList[iClientH]->m_iLevel++;
			m_pClientList[iClientH]->m_iLU_Pool += 3;
			// ·¹º§ÀÌ ¿À¸¥°Í¿¡ ´ëÇÑ Æ¯¼ºÄ¡ Æ÷ÀÎÆ®¸¦ Áõ°¡½ÃÄÑ¾ß ÇÑ´Ù. 
//			if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
//	  		      m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) <= DEF_TOTALLEVELUPPOINT) {
				// ·¹º§ ¾÷ ¼¼ÆÃÀÌ 3º¸´Ù °°°Å³ª ÀÛ¾Æ¾ß À¯È¿ÇÏ´Ù. 

//			}

			// ¼³Á¤Ä¡¸¦ È®ÀÎÇÑ´Ù. 
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iStr = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iDex = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iVit = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iInt = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iMag = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iCharisma = DEF_CHARPOINTLIMIT;

			// New 17/05/2004
			if (m_pClientList[iClientH]->m_iLevel > 100)
				if (m_pClientList[iClientH]->m_bIsPlayerCivil )
					ForceChangePlayMode(iClientH, true);

			// centu - max hp,mp,sp when level up
			m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
			m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
			m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);

			// ·¹º§ÀÌ ¿À¸¥°ÍÀ» Åëº¸ÇÑ´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_LEVELUP, 0, 0, 0, 0);

			// ´ÙÀ½ ·¹º§·ÎÀÇ °æÇèÄ¡°ª °è»ê, ÇÒ´ç.
			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);
		
			// Æ¯¼ºÄ¡ Àç °è»ê. 
			CalcTotalItemEffect(iClientH, -1, false);

			//v1.4 ´ÙÀ½ ·¹º§ 
			//wsprintf(G_cTxt, "(!) Level up: Player (%s) Level (%d) Experience(%d) Next Level Experience(%d)", m_pClientList[iClientH]->m_cCharName,m_pClientList[iClientH]->m_iLevel, m_pClientList[iClientH]->m_iExp, m_pClientList[iClientH]->m_iNextLevelExp);
			//PutLogFileList(G_cTxt);
		}
		else { 
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;
			
			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_iPlayerMaxLevel + 1];
			m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[m_iPlayerMaxLevel];
			//addon
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 1, 0, 0);
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
	}
	
	return false;
}
// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ¾µ¼ö ÀÖ´Ù...
/////////////////////////////////////////////////////////////////////////////////////
//  StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
//  desc		 :: ÁöÁ¸Æ÷ÀÎÆ®¸¦ ·¹º§¾÷ Æ÷ÀÎÆ®·Î µ¹¸°´Ù...
//	return value :: void
//  date		 :: [2003-04-14]    stupid koreans
/////////////////////////////////////////////////////////////////////////////////////
void CGame::StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cStateChange1, cStateChange2, cStateChange3;
 char cStr, cVit, cDex, cInt, cMag, cChar;
 char cStateTxt[512];
 int iOldStr, iOldVit, iOldDex, iOldInt, iOldMag, iOldChar;
 int iTotalSetting = 0;
	
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;

	cStr = cVit = cDex = cInt = cMag = cChar = 0;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cStateChange1 = *cp;
	cp++;

	cStateChange2 = *cp;
	cp++;

	cStateChange3 = *cp;
	cp++;

	iOldStr	= m_pClientList[iClientH]->m_iStr;
	iOldVit	= m_pClientList[iClientH]->m_iVit;
	iOldDex = m_pClientList[iClientH]->m_iDex;
	iOldInt = m_pClientList[iClientH]->m_iInt;
	iOldMag = m_pClientList[iClientH]->m_iMag;
	iOldChar = m_pClientList[iClientH]->m_iCharisma;
	
	try
	{
		wsprintf(G_cTxt, "(*) Char(%s) Str(%d) Vit(%d) Dex(%d) Int(%d) Mag(%d) Chr(%d) ", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iStr, m_pClientList[iClientH]->m_iVit, m_pClientList[iClientH]->m_iDex, m_pClientList[iClientH]->m_iInt, m_pClientList[iClientH]->m_iMag, m_pClientList[iClientH]->m_iCharisma);
		PutLogList(G_cTxt);
	}
	catch(...)
	{
	}
	
	if(!bChangeState(cStateChange1,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}
	if(!bChangeState(cStateChange2,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}
	if(!bChangeState(cStateChange3,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	try
	{
		wsprintf(G_cTxt, "(*) Char(%s) St1(%d) St2(%d) St3(%d) Str(%d) Vit(%d) Dex(%d) Int(%d) Mag(%d) Chr(%d) ", m_pClientList[iClientH]->m_cCharName,cStateChange1,cStateChange2,cStateChange3, cStr, cVit, cDex, cInt, cMag, cChar);
		PutLogList(G_cTxt);
	}
	catch(...)
	{
	}

	//±æµå ¸¶½ºÅÍ¸é cChar¸¦ ¸ø ³»¸°´Ù..
	if(m_pClientList[iClientH]->m_iGuildRank == 0 )
	{
		if(m_pClientList[iClientH]->m_iCharisma - cChar < 20)
		{
			//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
			return;
		}
	}

	//Æ¯¼ºÄ¡ °ªÀÌ ·¹º§°ú ¸ÂÁö ¾Ê´Ù¸é ³»¸±¼ö ¾ø´Ù..
	if(iOldStr +iOldVit +iOldDex +iOldInt +iOldMag +iOldChar != (179*3 + 70))
	{
		//ÇØÅ·ÀÌ´Ù... Å¬¶óÀÌ¾ðÆ®¿¡¼­ ¸øº¸³»°Ô µÇ¾î ÀÖ´Ù ±Ùµ¥ ¿Ô´Ù¸é ÇØÅ·...
		return;
	}


	if(cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0
		|| cStr + cVit + cDex + cInt + cMag + cChar != 3)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	// Æ¯¼ºÄ¡°ªÀÌ 10ÀÌÇÏ·Î ¸ø³»·Á °£´Ù... Á¦ÇÑÀ» ³ÑÀ»¼öµµ ¾ø´Ù...
	if ((m_pClientList[iClientH]->m_iStr - cStr > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iStr - cStr < 10)) 
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if ((m_pClientList[iClientH]->m_iDex - cDex > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iDex - cDex < 10)) 
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if ((m_pClientList[iClientH]->m_iInt - cInt > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iInt - cInt < 10)) 
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if ((m_pClientList[iClientH]->m_iVit - cVit > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iVit - cVit < 10)) 
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if ((m_pClientList[iClientH]->m_iMag - cMag > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iMag - cMag < 10)) 
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if ((m_pClientList[iClientH]->m_iCharisma - cChar > DEF_CHARPOINTLIMIT)
		 || (m_pClientList[iClientH]->m_iCharisma - cChar < 10)) 
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	if (m_pClientList[iClientH]->m_iLU_Pool < 3) m_pClientList[iClientH]->m_iLU_Pool = 3;

	// ¿À·ù°¡ ¾øÀ¸¸é °ªÀ» ÇÒ´çÇÑ´Ù.
	//m_pClientList[iClientH]->m_iLU_Pool += 3;
	
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;

	//HBest uuendus, hp,mp,sp lowering, skillcheck
	m_pClientList[iClientH]->m_iHP -= (cStr+3*cVit);
	m_pClientList[iClientH]->m_iMP -= (cInt+2*cMag);
	m_pClientList[iClientH]->m_iSP -= (2*cStr);
	m_pClientList[iClientH]->m_iStr  -= cStr;
	m_pClientList[iClientH]->m_iVit  -= cVit;
	m_pClientList[iClientH]->m_iDex  -= cDex;
	m_pClientList[iClientH]->m_iInt  -= cInt;
	//2003-04-22ÀÏ ¸¶¹ýÀ» »èÁ¦ ½ÃÅ²´Ù.... ÀÎÆ®°¡ ³»·Á°¡°í ³ª¼­ µ¹¾Æ°¡¾ß ÇÑ´Ù...
	if(cInt > 0)
		bCheckMagicInt(iClientH);
	m_pClientList[iClientH]->m_iMag  -= cMag;
	m_pClientList[iClientH]->m_iCharisma -= cChar;
	//SkillCheck(iClientH);

	try
	{
	ZeroMemory(cStateTxt,sizeof(cStateTxt));

	wsprintf(cStateTxt, "STR(%d->%d)VIT(%d->%d)DEX(%d->%d)INT(%d->%d)MAG(%d->%d)CHARISMA(%d->%d)",
		iOldStr, m_pClientList[iClientH]->m_iStr,
		iOldVit, m_pClientList[iClientH]->m_iVit,
		iOldDex, m_pClientList[iClientH]->m_iDex,
		iOldInt, m_pClientList[iClientH]->m_iInt,
		iOldMag, m_pClientList[iClientH]->m_iMag,
		iOldChar,m_pClientList[iClientH]->m_iCharisma				
		);
	}
	catch(...)
	{

	}

	//_bCustomLog(DEF_ITEMLOG_CUSTOM,iClientH,0,cStateTxt);

	//2003-04-22ÀÏ ½ºÅ³À» ³»·Á°¡°Ô ÇÑ´Ù... 
	//bCheckSkillState(iClientH);

	//¼º°ø..!!!
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
}

// 2003-04-21 ÀÎÆ®¿¡ µû¸¥ ¸¶¹ýÀ» »èÁ¦ ½ÃÄÑÁØ´Ù...
/////////////////////////////////////////////////////////////////////////////////////
//  bool CGame::bCheckMagicInt(int iClientH)  //another retarded korean function
//  desc		 :: ÀÎÆ®°¡ ³»·Á°¬À»¶§ »èÁ¦ÇÒ ¸¶¹ýÀ» Ã³¸®ÇÑ´Ù... Ã¼Å©¸¸...
//	return value :: ¹«Á¶°Ç true   // ....dumbass koreans
//  date		 :: 2003-04-21
/////////////////////////////////////////////////////////////////////////////////////
bool CGame::bCheckMagicInt(int iClientH)
{

	for(int i = 0;i < DEF_MAXMAGICTYPE ;i++)
	{
		if(m_pMagicConfigList[i] != 0)
		if(m_pMagicConfigList[i]->m_sIntLimit > (m_pClientList[iClientH]->m_iInt+ m_pClientList[iClientH]->m_iAngelicInt))
		{
			m_pClientList[iClientH]->m_cMagicMastery[i] = 0;	
		}
	}

	return true;
}

// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ¾µ¼ö ÀÖ´Ù...
/////////////////////////////////////////////////////////////////////////////////////
//  bChangeState(char cStateChange 
//  		  ,char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
//  desc		 :: ÁöÁ¸ Æ÷ÀÎÆ®·Î Æ¯¼º°ª ¹Ù²Üƒ”À» ´õÇØ ÁØ´Ù...
//	return value :: BOOLÇü 0(FASLE) ¿¡·¯ ·¹º§ ¼öÁ¤ ºÒ°¡...
//  date		 :: [2003-04-14] 
/////////////////////////////////////////////////////////////////////////////////////
bool CGame::bChangeState(char cStateChange, char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
{
	if(cStateChange == DEF_STR)
	{
		*cStr += 1;
	}
	else if(cStateChange == DEF_VIT)
	{
		*cInt += 1;
//		if(m_pClientList[iClientH]->m_iStr - cVit < 10 || m_pClientList[iClientH]->cVit - cVit < DEF_CHARPOINTLIMIT )
//			return 0;
	}
	else if(cStateChange == DEF_DEX)
	{
		*cVit += 1;
	}
	else if(cStateChange == DEF_INT)
	{
		*cDex += 1;
	}
	else if(cStateChange == DEF_MAG)
	{
		*cMag += 1;
	}
	else if(cStateChange == DEF_CHR)
	{
		*cChar += 1;
	}
	else
	{
		//Å¬¶óÀÌ¾ðÆ®°¡ Àß¸øµÈ °ªÀ» º¸³» ¿Ô´Ù..
//		::MessageBox(0, "Å¬¶óÀÌ¾ðÆ® ¹ö±×? - 클라이언트 버그?","debug", MB_ICONEXCLAMATION | MB_YESNO) ;
		return 0;
	}

	return cStateChange;
}

void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp;
	int iTotalSetting = 0;

	short* sp;
	short cStr, cVit, cDex, cInt, cMag, cChar;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iLU_Pool <= 0) 
	{
		//ÇØÄ¿ÀÎ°¡??
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
		return ;
	}

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short*)cp;
	cStr = *sp;
	cp += 2;

	sp = (short*)cp;
	cVit = *sp;
	cp += 2;

	sp = (short*)cp;
	cDex = *sp;
	cp += 2;

	sp = (short*)cp;
	cInt = *sp;
	cp += 2;

	sp = (short*)cp;
	cMag = *sp;
	cp += 2;

	sp = (short*)cp;
	cChar = *sp;
	cp += 2;

//	if(m_pClientList[iClientH]->m_iLU_Pool < 3) {
//		m_pClientList[iClientH]->m_iLU_Pool = 3;
//	}


	if ( (cStr + cVit + cDex + cInt + cMag + cChar) > m_pClientList[iClientH]->m_iLU_Pool) { // -3
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
			return;
	}

	// Level-Up Setting°ª¿¡ ¿À·ù°¡ ÀÖ´ÂÁö °Ë»çÇÑ´Ù.
	if ((m_pClientList[iClientH]->m_iStr + cStr > DEF_CHARPOINTLIMIT) || (cStr < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iDex + cDex > DEF_CHARPOINTLIMIT) || (cDex < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iInt + cInt > DEF_CHARPOINTLIMIT) || (cInt < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iVit + cVit > DEF_CHARPOINTLIMIT) || (cVit < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iMag + cMag > DEF_CHARPOINTLIMIT) || (cMag < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iCharisma + cChar > DEF_CHARPOINTLIMIT) || (cChar < 0)) 
		return;

	iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + 
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	//(·¹º§ Æ¯¼º°ª + ·¹º§¾÷ Æ÷ÀÎÆ® > ·¹º§¾÷ Æ¯¼º°ª Á¤»óÄ¡)¸é ºñÁ¤»óÀÌ´Ù.. Ã³¸® ºÒ°¡.. ·¹º§¾÷ Æ÷ÀÎÆ®¸¦ Á¤»óÄ¡·Î ¸¶Ãß°í Ã³¸® ºÒ°¡..
	if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool -3 > ((m_pClientList[iClientH]->m_iLevel-1)*3 + 70))
	{

		m_pClientList[iClientH]->m_iLU_Pool = /*m_cLU_Str ÃÊ±â°ª*/3 + (m_pClientList[iClientH]->m_iLevel-1)*3 + 70 - iTotalSetting;

		//iTotalSetting°ªÀÌ Àß¸øµÈ °æ¿ì´Ù...
		if(m_pClientList[iClientH]->m_iLU_Pool < 3)
			m_pClientList[iClientH]->m_iLU_Pool = 3;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
		return ;
	}

	//(·¹º§ Æ¯¼º°ª + ·¹º§¾÷ ½ÃÅ³ Æ÷ÀÎÆ® ÁD > ·¹º§¾÷ Æ¯¼º°ª Á¤»óÄ¡)ÀÌ¸é Ã³¸® ºÒ°¡..
	if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChar) > ((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) 
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
		return;
	}

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (cStr + cVit + cDex + cInt + cMag + cChar);

	m_pClientList[iClientH]->m_iStr  += cStr;
	m_pClientList[iClientH]->m_iVit  += cVit;
	m_pClientList[iClientH]->m_iDex  += cDex;
	m_pClientList[iClientH]->m_iInt  += cInt;
	m_pClientList[iClientH]->m_iMag  += cMag;
	m_pClientList[iClientH]->m_iCharisma += cChar;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);

}

//}

// v1.4311-3 Ãß°¡ »çÅõÀå ¿¹¾à ÇÔ¼ö FightzoneReserveHandler
void CGame::FightzoneReserveHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char cData[100];
 int iFightzoneNum ,* ip ,  iEnableReserveTime ;
 DWORD * dwp, dwGoldCount ;
 WORD  * wp, wResult;
 int     iRet, iResult=1, iCannotReserveDay;
 SYSTEMTIME SysTime;
 
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
 
	GetLocalTime(&SysTime);
	
	// ¿¹¾à °¡´ÉÇÑ ½Ã°£ : µÎ½Ã°£ °£°ÝÀ¸·Î ¿¹¾àÀÌ °¡´ÉÇÏ¸ç »ç¿ë¿Ï·á 5ºÐÀü¿¡´Â ¿¹¾àÀÌ ºÒ°¡´ÉÇÏ´Ù.
	iEnableReserveTime  = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 5*20;
	
	dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	// ¿¹¾àÀ» ¿øÇÏ´Â »çÅõÀå ¹øÈ£¸¦ ¹Þ´Â´Ù.
	iFightzoneNum = *ip;

	// Àß¸øµÈ fightzone ¹øÈ£¸¦ °É·¯³½´Ù.
	if ((iFightzoneNum < 1) || (iFightzoneNum > DEF_MAXFIGHTZONE)) return;

	// »çÅõÀåÀÌ Áßº¹µÇÁö ¾Ê°Ô ÇÏ±â À§ÇØ ¿äÀÏ¿¡ µû¶ó »ç¿ëÇÒ¼ö ÀÖ´Â »çÅõÀåÀÌ ´Ù¸£°Ô ÇÏ±â À§ÇÑ º¯¼ö´Ù.
	// È¦¼ö³¯¿¡´Â ¾Æ·¹½ºµ§ 2 4 6 8 ¿¤¹ÙÀÎÀÌ 1 3 5 7  »çÅõÀåÀÌ »ç¿ë°¡´ÉÇÏ´Ù 
    //             ex) 1ÀÏÀÎ°æ¿ì => {1 + 1 (¾Æ·¹½ºµ§) + 1 (»çÅõÀå ¹øÈ£ )} %2 == 1 ÀÌ¹Ç·Î 
	//                            ¾Æ·¹½ºµ§Àº È¦¼ö³¯ È¦¼ö »çÅõÀåÀ»  ¿¹¾à ÇÒ¼ö ¾ø´Ù. 

	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_cSide + iFightzoneNum ) % 2 ;
	if (iEnableReserveTime <= 0 ){
		// ¿¹¾à¿¡ ½ÇÆÐÇß´Ù. 
		// ¸¸¾à ¿¹¾à °¡´ÉÇÑ ½Ã°£ÀÌ ¾Æ´Ï¸é 0 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³»°í 
		wResult = DEF_MSGTYPE_REJECT;
		iResult = 0 ;
	} else if (m_iFightZoneReserve[iFightzoneNum-1] != 0){
		// »çÅõÀåÀÌ ¿¹¾à µÇ¾î ÀÖÀ¸¸é  -1 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -1 ;
	} else if ( dwGoldCount < 1500 ) {
		// ÇÃ·¹ÀÌ¾î°¡ °®°íÀÖ´Â Gold°¡ ÀÔÀå±Ç °¡°Ý¿¡ ºñÇØ Àû´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -2 ;	           // µ·ÀÌ ÀûÀ¸¸é -2 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡°Ô º¸³½´Ù.
	} else if( iCannotReserveDay ) {
		// ¿À´ÃÀº ¿¹¾àÇÒ ¼ö ¾ø´Â ³¯ÀÌ´Ù. ÀÌ¶§´Â -3 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -3 ;
	} else if( m_pClientList[iClientH]-> m_iFightzoneNumber != 0 ) {
		// ÀÌ¹Ì ´Ù¸¥ »çÅõÀåÀ» ¿¹¾àÇß´Ù. ÀÌ¶§´Â -4 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -4 ;
	} else {
		// »ç¿ëÀÚ°¡ °í¸¥ »çÅõÀåÀÌ ¿¹¾àÀÌ µÇ¾î ÀÖÁö ¾Ê°í 
		// ¿¹¾à¿¡ ÇÊ¿äÇÑ ±Ý¾×µµ °¡Áö°í ÀÖ°í
		// ¿¹¾à °¡´ÉÇÑ ½Ã°£ÀÌ¸é  ¿¹¾àÇÑ´Ù.
	
		// ¿¹¾à¿¡ ¼º°ø Çß´Ù. 
		wResult = DEF_MSGTYPE_CONFIRM;

		// »çÅõÀå ¿¹¾àÀ» À§ÇÑ ±Ý¾×À» °¨¼Ò ½ÃÅ²´Ù.
		SetItemCount(iClientH, "Gold", dwGoldCount - 1500);
		iCalcTotalWeight(iClientH);
		
		// »çÅõÀåÀ» ¿¹¾àÇÑ Å¬¶óÀÌ¾ðÆ®ÀÇ ID¸¦ ³Ö´Â´Ù.
		m_iFightZoneReserve[iFightzoneNum-1] = iClientH;
		
		m_pClientList[iClientH]->m_iFightzoneNumber  = iFightzoneNum ;
		m_pClientList[iClientH]->m_iReserveTime	 =  SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour ;  

		if (SysTime.wHour%2 )	m_pClientList[iClientH]->m_iReserveTime  += 1  ;	// È¦¼ö ½Ã°£´ëÀÌ¸é ÇÑ½Ã°£ ÈÄ±îÁö ¿¹¾àµÈ´Ù.
		else					m_pClientList[iClientH]->m_iReserveTime  += 2  ;    // Â¦¼ö ½Ã°£´ëÀÌ¸é µÎ ½Ã°£ ÈÄ±îÁö ¿¹¾àµÈ´Ù.
		wsprintf(G_cTxt, "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);		
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		m_pClientList[iClientH]->m_iFightZoneTicketNumber  = 50 ;  
		iResult = 1 ;
	}  

	ZeroMemory(cData, sizeof(cData));

	dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_FIGHTZONE_RESERVE;

	wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp =  wResult ;

	ip  = (int *)(cData + DEF_INDEX2_MSGTYPE+2) ; 
	*ip =  iResult ;
	ip+= 4;
	
	// »çÅõÀå ¿¹¾à ÀÀ´ä ¸Þ¼¼Áö  Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
		
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
 
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, true, true);
		return;
	}
}



bool CGame::bCheckLimitedUser(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return false;
	
	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && 
		 (m_pClientList[iClientH]->m_iExp >= m_iLevelExp20 ) ) {
		// ¿©ÇàÀÚ°¡ ·¹º§ 20 °æÇèÄ¡¸¦ ¾ò¾ú´Ù¸é 19¼öÁØÀ¸·Î È¯¿ø. 

		m_pClientList[iClientH]->m_iExp = m_iLevelExp20 - 1;	
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_TRAVELERLIMITEDLEVEL, 0, 0, 0, 0);
		return true;
	}


	return false;
}

void CGame::RequestCivilRightHandler(int iClientH, char *pData)
{
 char * cp, cData[100];
 DWORD * dwp;
 WORD * wp, wResult;
 int  iRet;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((m_bAdminSecurity ) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;

	// ?횑쨔횑 횉횗 쨍쨋?쨩?횉 쩌횘쩌횙?횑 ?횜쨈횢쨍챕 쩍횄쨔횓짹횉?쨩 째징횁첬 쩌철 쩐첩쨈횢. 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) wResult = 0;
	else wResult = 1;

	// 쨌쨔쨘짠?횑 5 ?횑횉횕쨋처쨉쨉 쩍횄쨔횓짹횉?쨩 쩐챵?쨩 쩌철 쩐첩쨈횢. 
	if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;
	
	if (wResult == 1) {
		// 횉철?챌 쨍횎?횉 ?횑쨍짠?쨩 횉횘쨈챌횉횗쨈횢.
		ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
	}

	// Side 횉횘쨈챌
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) 
		m_pClientList[iClientH]->m_cSide = 1;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) 
		m_pClientList[iClientH]->m_cSide = 2;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_CIVILRIGHT;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wResult;

	// v1.41 쨍횎 ?횑쨍짠 쩐횏쨌횁횁횥 
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp += 10;

	// ??쨈채 쨍횧쩍횄횁철쨍짝 횇짭쨋처?횑쩐챨횈짰쩔징째횚 ?체쩌횤
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 쨍횧쩍횄횁철쨍짝 쨘쨍쨀쩐쨋짠 쩔징쨌짱째징 쨔횩쨩첵횉횩쨈횢쨍챕 횁짝째횇횉횗쨈횢.
		DeleteClient(iClientH, true, true);
		return;
	}
	// 횈짱쩌쨘?횑 쨔횢짼챤쨔횉쨌횓 쩔횥쩐챌?쨩 쨩천쨌횓 쨘쨍쨀쩍쨈횢. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}



void CGame::RequestRetrieveItemHandler(int iClientH, char *pData)
{
 char * cp, cBankItemIndex, cMsg[100];
 int i, j, iRet, iItemWeight;
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cBankItemIndex = *cp;
	//wh remove
	//if (m_pClientList[iClientH]->m_bIsInsideWarehouse == false) return;

	if ((cBankItemIndex < 0) || (cBankItemIndex >= DEF_MAXBANKITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == 0) {
		// ¿À·ù´Ù. 
		ZeroMemory(cMsg, sizeof(cMsg));
			
		dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_RETRIEVEITEM;
		wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
	}
	else {
		// Áß·®°è»ê 
		/*
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			//iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight * m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount;
			iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		}
		else iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], 1); //m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight;
		*/
		// v1.432
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		
		if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
			// ÇÑ°èÁß·® ÃÊ°ú, ¾ÆÀÌÅÛÀ» Ã£À» ¼ö ¾ø´Ù. 
			// ½ÇÆÐ ¸Þ½ÃÁö¸¦ º¸³½´Ù.
			ZeroMemory(cMsg, sizeof(cMsg));
			
			// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, true, true);
				break;
			}
			return;
		}
		
		//!!!
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			// Áßº¹ÀÌ °¡´ÉÇÑ ¾ÆÀÌÅÛÀÌ¶ó¸é ¼ö·®¸¸ Áõ°¡½ÃÅ²´Ù.	
			for (i = 0; i < DEF_MAXITEMS; i++)
			if ( (m_pClientList[iClientH]->m_pItemList[i] != 0) && 
				 (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) && 
			 	 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0) ) {
				// °°Àº Çü½ÄÀÇ ¾ÆÀÌÅÛÀ» Ã£¾Ò´Ù. ¼ö·®À» Áõ°¡½ÃÅ²´Ù.
				// v1.41 !!! 
				SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
				
				// ¹ðÅ© ¾ÆÀÌÅÛ »èÁ¦ 
				delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = 0;

				// ºó °ø°£À» ¾ø¾Ø´Ù. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != 0) && (m_pClientList[iClientH]->m_pItemInBankList[j] == 0)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = 0;
					}
				}
				
				// ¼º°ø ¸Þ½ÃÁö¸¦ º¸³½´Ù.
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
			
				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);
				// È­»ì ÇÒ´ç
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
								
				// ¸Þ½ÃÁö Àü¼Û 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}
				return;
			}

			// °°Àº ÀÌ¸§À» °®°í ÀÖ´Â ¾ÆÀÌÅÛÀÌ ¾ø´Ù. »õ·Î Ãß°¡ÇØ¾ß ÇÑ´Ù. 
			goto RRIH_NOQUANTITY;
		} 
		else {
RRIH_NOQUANTITY:
			// ¼ö·®°³³äÀÌ ¾ø´Â ¾ÆÀÌÅÛ 
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] == 0) {
				// ºó °ø°£À» Ã£¾Ò´Ù. 
				// ¸ÕÀú ÁÖ¼Ò¸¦ ¿Å±ä´Ù. 
				m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				// v1.3 1-27 12:22
				m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
				m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
			
				m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;
				
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = 0;
				
				// ºó °ø°£À» ¾ø¾Ø´Ù. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != 0) && (m_pClientList[iClientH]->m_pItemInBankList[j] == 0)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = 0;
					}
				}
								
				// ¼º°ø ¸Þ½ÃÁö¸¦ º¸³½´Ù.
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
					
				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);
		
				// È­»ì ÇÒ´ç
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
					
				// ¸Þ½ÃÁö Àü¼Û 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}
				return;
			}
			// ¾ÆÀÌÅÛÀ» µÇÃ£À» °ø°£ÀÌ ¾ø´Ù. ¿À·ù
			ZeroMemory(cMsg, sizeof(cMsg));
			
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_RETRIEVEITEM;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
		}
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, true, true);
		return;
	}
}

bool CGame::bSetItemToBankItem(int iClientH, short sItemIndex)
{
 int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];
 class CItem * pItem;
	
	// ¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛÀ» º¸°üÇÑ´Ù.
	if (m_pClientList[iClientH] == 0) return false;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return false;
	//wh remove
	//if (m_pClientList[iClientH]->m_bIsInsideWarehouse == false) return false;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {
		// ºñ¾îÀÖ´Â À§Ä¡¸¦ Ã£¾Ò´Ù.
				
		m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
		pItem = m_pClientList[iClientH]->m_pItemInBankList[i];
		// !!! ¾ÆÀÌÅÛÀÇ Æ÷ÀÎÅÍ¸¦ ÀÌµ¿ÇßÀ¸´Ï ±âÁ¸ÀÇ Æ÷ÀÎÅÍ´Â NULL°ªÀ¸·Î ÇÒ´ç. 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;
		
		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);			   
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);		       
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; // À§Ä¡ ÀúÀå 
		cp++;

		// 1°³.
		*cp = 1;
		cp++;						    

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		// v1.432
		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù. v1.41 Á¦°ÅÇÏÁö ¾Ê´Â´Ù.
			// DeleteClient(iClientH, true, true);
			return true; // v1.41 FALSE¸¦ ¹ÝÈ¯ÇÏ¸é ¾ÆÀÌÅÛÀÌ ¹Ù´Ú¿¡ º¹»çµÈ´Ù.
		}

		return true;
	}

	// ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¿©À¯°ø°£ÀÌ ¾ø´Ù.
	return false;
}
// 05/21/2004 - Hypnotoad - send player to jail
void CGame::ApplyPKpenalty(short sAttackerH, short sVictumH)
{
	DWORD iV1, iV2;

	if (m_pClientList[sAttackerH] == 0) return;
	if (m_pClientList[sVictumH] == 0) return;
	// ¾ÈÀü °ø°Ý ¸ðµå°¡ ÄÑÁø »óÅÂ¿¡¼­ °ø°ÝÀ¸·Î ÀÎÇØ °°Àº ÆíÀÌ Á×À»¼ö´Â ¾øÁö¸¸ ¸¸¾à ÀÖÀ»°æ¿ì ¹«½Ã 
	// ´Ü °ø°ÝÀÚ°¡ ¹üÁËÀÚ°¡ ¾Æ´Ï¾î¾ß¸¸ ÇØ´çµÈ´Ù.
	if ((m_pClientList[sAttackerH]->m_bIsSafeAttackMode ) && (m_pClientList[sAttackerH]->m_iPKCount == 0)) return; 
	if ((strcmp(m_pClientList[sVictumH]->m_cLocation, "aresden") != 0) && (strcmp(m_pClientList[sVictumH]->m_cLocation, "elvine") != 0) && (strcmp(m_pClientList[sVictumH]->m_cLocation, "elvhunter") != 0) && (strcmp(m_pClientList[sVictumH]->m_cLocation, "arehunter") != 0)) {
		return;
	}

	// PK Count Áõ°¡  
	m_pClientList[sAttackerH]->m_iPKCount++;

	_bPKLog(DEF_PKLOG_BYPK,sAttackerH,sVictumH,0) ;

	// °æÇèÄ¡ °¨¼Ò 
	iV1 = iDice((m_pClientList[sVictumH]->m_iLevel/2)+1, 50); 
	iV2 = iDice((m_pClientList[sAttackerH]->m_iLevel/2)+1, 50);

	m_pClientList[sAttackerH]->m_iExp -= iV1; 
	m_pClientList[sAttackerH]->m_iExp -= iV2;
	if (m_pClientList[sAttackerH]->m_iExp < 0) m_pClientList[sAttackerH]->m_iExp = 0;

	// Æä³ÎÆ¼¸¦ ¸Ô¾úÀ½À» ¾Ë·ÁÁØ´Ù.
	SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_PKPENALTY, 0, 0, 0, 0);	

	// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù. 
	SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

	// v1.4 ·Î±× ÆÄÀÏ¿¡ ±â·Ï 
	//wsprintf(G_cTxt, "(!) PK-penalty: °ø°ÝÀÚ(%s) ¼Õ½Ç °æÇèÄ¡(%d) °æÇèÄ¡(%d) ", m_pClientList[sAttackerH]->m_cCharName, iV1+iV2, m_pClientList[sAttackerH]->m_iExp);
	//PutLogFileList(G_cTxt);

	// v1.4 Å©¶óÀÓ È½¼ö Áõ°¡ 
	m_stCityStatus[m_pClientList[sAttackerH]->m_cSide].iCrimes++;

	// v1.41 Rating ÇÏ¶ô 
	m_pClientList[sAttackerH]->m_iRating -= 10;
	if (m_pClientList[sAttackerH]->m_iRating > 10000)  m_pClientList[sAttackerH]->m_iRating =  10000;
	if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = -10000;


	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "aresden") == 0) {
		if ( (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk11") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk12") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk21") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk22") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "aresden") == 0)   ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone2") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "areuni") == 0)    ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arefarm") == 0)) {

				// ¾Æ·¹½ºµ§ ±Ù±³¿¡¼­ PK¸¦ Çß´Ù. ºí¸®µù ÅÚ·¹Æ÷Æ® 5ºÐ
				// v2.16 ¼ºÈÄ´Ï ¼öÁ¤
				ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
				strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
				m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
				RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
				return;		
			}
	}

	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "elvine") == 0) {
		if ( (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk11") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk12") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk21") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk22") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvine") == 0)    ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone1") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvuni") == 0)    ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {

				// ¿¤¹ÙÀÎ ±Ù±³¿¡¼­ PK¸¦ Çß´Ù. ºí¸®µù ÅÚ·¹Æ÷Æ® 5ºÐ
				ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
				strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
				m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
				RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
				return;		
			}
	}
}


// 05/17/2004 - Hypnotoad - register pk log
void CGame::PK_KillRewardHandler(short sAttackerH, short sVictumH)
{
	if (m_pClientList[sAttackerH] == 0) return;
	if (m_pClientList[sVictumH] == 0)   return;

	_bPKLog(DEF_PKLOG_BYPLAYER,sAttackerH,sVictumH,0) ;

	if (m_pClientList[sAttackerH]->m_iPKCount != 0) {
		// PK¸¦ ÀâÀº »ç¶÷ÀÌ PK¸é ¾Æ¹«·± µæÀÌ ¾ø´Ù.

	}
	else {
		// Æ÷»ó±Ý¸¸ ´©Àû. °æÇèÄ¡´Â ¿À¸£Áö ¾Ê´Â´Ù. 
		m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictumH]->m_iExp) * 3;


		if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0) 
			m_pClientList[sAttackerH]->m_iRewardGold = 0;

		SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_PKCAPTURED, m_pClientList[sVictumH]->m_iPKCount, m_pClientList[sVictumH]->m_iLevel, 0, m_pClientList[sVictumH]->m_cCharName);
	}
}

void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{
	// enemy-kill-mode = 1 | 0
	// if m_bEnemyKillMode is true than death match mode

	// DEATHMATCH MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and gets an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and gets an EK

	// CLASSIC MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and doesnt get an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and doesnt get an EK

	int iEK_Level;
	DWORD iRewardExp;

	// if the attacker doesnt exist no result
	if (m_pClientList[iAttackerH] == 0) return;
	// if the target doesnt exist no result
	if (m_pClientList[iClientH] == 0)   return;

	// Log the EK (killed by enemy)
	_bPKLog(DEF_PKLOG_BYENERMY,iAttackerH,iClientH,0) ;
	
	// set EK level to 30
	iEK_Level = 30;
	// if attacker's level is greater than 80, set ek level to 80
	if (m_pClientList[iAttackerH]->m_iLevel >= 80) iEK_Level = 80;
	// check if attacker level is less than or equal to max level
	if (m_pClientList[iAttackerH]->m_iLevel >= m_iPlayerMaxLevel) {
		// if the
		if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
			// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
				&& (m_bEnemyKillMode == false)) {
				// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
				m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
			}
			
			if (m_bEnemyKillMode ) {
				// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
				m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
			}
		}
		// Æ÷»ó±Ý ´©Àû 
		m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
		if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
			m_pClientList[iAttackerH]->m_iRewardGold = 0;

		// ÀûÀ» Àâ¾Ò´Ù´Â ¸Þ½ÃÁö º¸³¿ 
		SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, 0, 0, 0);
		return;
	}

	if (m_pClientList[iAttackerH]->m_iPKCount != 0) {
		// ÀûÀ» ÀâÀº »ç¶÷ÀÌ PK¸é ¾Æ¹«·± µæÀÌ ¾ø´Ù.
	}	
	else {
		// Èñ»ýÀÚÀÇ ½Ã¹Î, ±æµå¿ø ¿©ºÎ¿¡ µû¶ó Æ÷»óÀÌ ´Þ¶óÁø´Ù. 
		if (m_pClientList[iClientH]->m_iGuildRank == -1) {
			// ±æµå¿øÀÌ ¾Æ´Ï¹Ç·Î ½Ã¹Î. (¿©ÇàÀÚÀÇ °æ¿ì¿¡´Â ÀÌ ÇÔ¼ö°¡ È£ÃâµÇÁö ¾ÊÀ¸¹Ç·Î)
			// v2.15 ÀûÀ» Á×¿´À»¶§ Æò±Õ°æÇèÄ¡¸¦ ¾ò±âÀ§ÇØ 
			iRewardExp = (iDice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;

			if (m_bIsCrusadeMode ) {
				// Å©·ç¼¼ÀÌµå ¸ðµå¶ó¸é °æÇèÄ¡ÀÇ (1/3)*3À» ¸ÕÀú ÁÖ°í ³ª¸ÓÁö´Â 6¹è·Î ÀüÀï °øÇåµµ¿¡ ´©Àû 
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp/3)*4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp/3))*12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);

				// ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, 0, 0);

				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
					if (m_bEnemyKillMode ) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				// ÀÏ¹Ý ¸ðµå.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
						&& (m_bEnemyKillMode == false)) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
					
					if (m_bEnemyKillMode ) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}
		else {
			// v2.15 ÀûÀ» Á×¿´À»¶§ Æò±Õ°æÇèÄ¡¸¦ ¾ò±âÀ§ÇØ 
			iRewardExp = (iDice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;

			// ±æµå¿øÀÌ´Ù.
			if (m_bIsCrusadeMode ) {
				// Å©·ç¼¼ÀÌµå ¸ðµå.
				// Å©·ç¼¼ÀÌµå ¸ðµå¶ó¸é °æÇèÄ¡ÀÇ 1/3À» ¸ÕÀú ÁÖ°í ³ª¸ÓÁö´Â 2¹è·Î ÀüÀï °øÇåµµ¿¡ ´©Àû 
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp/3)*4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp/3))*12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);

				// ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, 0, 0);

				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
						&& (m_bEnemyKillMode == false)) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
					
					if (m_bEnemyKillMode ) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				// ÀÏ¹Ý ¸ðµå.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
						&& (m_bEnemyKillMode == false)) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
					
					if (m_bEnemyKillMode ) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}	
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}

		// ÀûÀ» Àâ¾Ò´Ù´Â ¸Þ½ÃÁö º¸³¿ 
		SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, 0, 0, 0);

		if (bCheckLimitedUser(iAttackerH) == false) {
			// Ã¼ÇèÆÇ »ç¿ëÀÚ Á¦ÇÑ¿¡ ÇØ´çµÇÁö ¾ÊÀ¸¸é °æÇèÄ¡°¡ ¿Ã¶ú´Ù´Â Åëº¸¸¦ ÇÑ´Ù.
			SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
		}
		// ·¹º§ÀÌ ¿Ã¶ú´ÂÁö¸¦ °Ë»çÇÑ´Ù.
		bCheckLevelUp(iAttackerH);

		//v1.4 ±³Àü¿¡¼­ ÀÌ±ä Ä«¿îÆ®¸¦ ¿Ã¸°´Ù.
		m_stCityStatus[m_pClientList[iAttackerH]->m_cSide].iWins++;
	}
}

// 05/22/2004 - Hypnotoad - register in pk log
void CGame::ApplyCombatKilledPenalty(int iClientH, int cPenaltyLevel, bool bIsSAattacked)
{  
	DWORD iExp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// Crusade
	if (m_bIsCrusadeMode ) {
		// Å©·ç¼¼ÀÌµå ¸ðµåÀÎ °æ¿ì ÀüÀïÁß¿¡ Á×¾îµµ ¾Æ¹«·± Æä³ÎÆ¼°¡ ¾ø´Ù.
		// PKcount¸¸ °¨¼Ò 
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PKPENALTY, 0, 0, 0, 0);	
			// v2.15 
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,0,iClientH,0) ;

		}
		return;
	}
	else {
		// PKcount °¨¼Ò 
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PKPENALTY, 0, 0, 0, 0);	
			// v2.15
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,0,iClientH,0) ;
		}

		// ÇÃ·¹ÀÌ¾î·ÎºÎÅÍÀÇ °ø°ÝÀ» ¹Þ°í ÀüÀïÁß »ç¸ÁÇß´Ù.
		iExp = iDice(1, (5*cPenaltyLevel*m_pClientList[iClientH]->m_iLevel));

		// Áß¸³ÀÎ °æ¿ì Á×¾úÀ» ¶§ ¶³¾îÁö´Â °æÇèÄ¡´Â 1/3
		if (m_pClientList[iClientH]->m_bIsNeutral ) iExp = iExp / 3;

		// v2.17 2002-7-31 ÃÖ°í·¾Àº Á×¾úÀ»¶§ °æÄ¡°¡ ¶³¾îÁöÁö ¾Ê´Â´Ù. ¼öÁ¤ 
		// if (m_pClientList[iClientH]->m_iLevel == DEF_PLAYERMAXLEVEL) iExp = 0;

		m_pClientList[iClientH]->m_iExp -= iExp;
		if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);

		// v1.41 Áß¸³Àº ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê´Â´Ù.
		if (m_pClientList[iClientH]->m_bIsNeutral != true) {
			if (m_pClientList[iClientH]->m_iLevel < 80) {
				// ·¹º§ 80 ¹Ì¸¸Àº ¾ÆÀÌÅÛÀÌ ÇÏ³ª Àû°Ô ¶³¾îÁø´Ù.
				// v2.03 60 -> 80
				cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
			}
			else _PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
		}
	}
}

// 05/29/2004 - Hypnotoad - Limits some items from not dropping
void CGame::_PenaltyItemDrop(int iClientH, int iTotal, bool bIsSAattacked)
{
 int i, j, iRemainItem;
 char cItemIndexList[DEF_MAXITEMS], cItemIndex;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((m_pClientList[iClientH]->m_iAlterItemDropIndex != -1) && (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex] != 0)) {
		// Testcode
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) {
			// v2.04 ½ºÅæ ¿Àºê »õÅ©¸®ÆÄÀÌ½º°¡ ¸Â´ÂÁö È®ÀÎ
			// ´ëÃ¼ÀûÀ¸·Î ¶³¾îÁö´Â ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é ´Ù¸¥ ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê°í ÀÌ ¾ÆÀÌÅÛ¸¸ ¶³¾îÁø´Ù. 
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0) {
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CURLIFESPAN, m_pClientList[iClientH]->m_iAlterItemDropIndex, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan, 0, 0);
			}
			DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);

			m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
		}
		else {
			// v2.04 testcode
			PutLogFileList("Alter Drop Item Index Error1");
			// ´Ù½Ã °Ë»ö 
			for (i = 0; i < DEF_MAXITEMS; i++) 
			if ((m_pClientList[iClientH]->m_pItemList[i] != 0) && (m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
				m_pClientList[iClientH]->m_iAlterItemDropIndex = i;
				if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0) {
					m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CURLIFESPAN, m_pClientList[iClientH]->m_iAlterItemDropIndex, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan, 0, 0);
				}
				DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);	
				m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
				return;
			}

			// ¿À·ù¹ß»ý! Èñ»ý¼®ÀÌ ¾ø´Ù. 
			goto PID_DROP;
		}
		return;
	}

PID_DROP:

	for (i = 1; i <= iTotal; i++) {
		iRemainItem = 0;
		ZeroMemory(cItemIndexList, sizeof(cItemIndexList));
		
		for (j = 0; j < DEF_MAXITEMS; j++) 
		if (m_pClientList[iClientH]->m_pItemList[j] != 0) {
			cItemIndexList[iRemainItem] = j;
			iRemainItem++;
		}
		
		if (iRemainItem == 0) return;
		cItemIndex = cItemIndexList[ iDice(1, iRemainItem) - 1 ];
		
	
		if ((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectType != 0) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
			// °³ÀÎ¿¡°Ô ¼ÓÇÑ ¾ÆÀÌÅÛÀ¸·Î ¶³¾îÁöÁö ¾Ê´Â´Ù. ¸ÁÅä°°Àº °³ÀÎ¿ë ¾ÆÀÌÅÛ 
		}

		else if (
				 (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum >= 400) && 
				 (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum != 402) && 
				 (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum <= 428)) {
		}

		else if (((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) ||
			     (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) &&
			     (bIsSAattacked == false)) {
			// Æ¯¼ö ´É·ÂÀ» °¡Áø ¾ÆÀÌÅÛÀÌ Æ¯¼ö °ø°ÝÀ» ¹ÞÀº°Ô ¾Æ´Ï¶ó¸é ¶³¾îÁöÁö ¾Ê´Â´Ù.
		}

		else if ((m_pClientList[iClientH]->m_bIsLuckyEffect ) && (iDice(1,10) == 5)) {
			// Ä³¸¯ÅÍ¿¡°Ô Çà¿îÈ¿°ú°¡ ÀÖÀ¸¸é 10% È®·ü·Î ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê´Â´Ù.
		}

		else DropItemHandler(iClientH, cItemIndex, -1, m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_cName);
	}
}

void CGame::GetRewardMoneyHandler(int iClientH)		    
{
 int iRet, iEraseReq, iWeightLeft;
 DWORD * dwp, iRewardGoldLeft;
 WORD  * wp;
 char  * cp, cData[100], cItemName[21];
 class CItem * pItem;
 short * sp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	
	// ³²Àº Áß·®À» °è»êÇÑ´Ù. 
	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
		
	if (iWeightLeft <= 0) return;
	// Áß·®À» ¹ÝÀ¸·Î ³ª´«´Ù. <- Ã£Àº µ·À¸·Î ¾ÆÀÌÅÛÀ» »ì °ø°£Àº ¸¶·ÃÇØ µÖ¾ß ÇÏ¹Ç·Î.
	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItem, cItemName);
	//pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
	
	// (iWeightLeft / pItem->m_wWeight)°¡ ÃÖ´ë ¹ÞÀ» ¼ö ÀÖ´Â Gold°¹¼ö. °®°íÀÖ´Â Æ÷»ó±Ý°ú ºñ±³ÇÑ´Ù. 
	if ((iWeightLeft / iGetItemWeight(pItem, 1)) >= m_pClientList[iClientH]->m_iRewardGold) {
		// Æ÷»ó±ÝÀ» ¸ðµÎ ¹ÞÀ» ¼ö ÀÖ´Ù. 
		pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	}
	else {
		// (iWeightLeft / pItem->m_wWeight)¸¸ ¹Þ´Â´Ù.
		pItem->m_dwCount = (iWeightLeft / iGetItemWeight(pItem, 1));
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - (iWeightLeft / iGetItemWeight(pItem, 1));
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
		
		// ³²Àº Æ÷»ó±Ý ³»¿ª °è»ê.
		m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		// 1°³ È¹µæÇß´Ù. <- ¿©±â¼­ 1°³¶õ Ä«¿îÆ®¸¦ ¸»ÇÏ´Â °ÍÀÌ ¾Æ´Ï´Ù
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;

		*cp = pItem->m_cGenderLimit;
		cp++;

		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		cp++;
		*/

		if (iEraseReq == 1) delete pItem;
		
		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
						
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, true, true);
			return;
		}

		// ±× ´ÙÀ½ ³²Àº Æ÷»ó±ÝÀ» ¾Ë·ÁÁØ´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REWARDGOLD, 0, 0, 0, 0);
	}
	else {
		// ¹ÞÀ» ¼ö ¾ø´Â °æ¿ì´Â ¾Æ¹«·± Ã³¸®¸¦ ÇÏÁö ¾Ê´Â´Ù. 

	}
}


int CGame::_iCalcMaxLoad(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return 0;

	return ((m_pClientList[iClientH]->m_iStr+ m_pClientList[iClientH]->m_iAngelicStr) * 500 + m_pClientList[iClientH]->m_iLevel*500);
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, DWORD dwLastTime, int iV1)
{
 int i;
 short sPreType;
 DWORD dwTime, dwRegisterTime;

	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != 0) return 0;

	switch (sType) {	
	case DEF_DYNAMICOBJECT_FIRE3:
	case DEF_DYNAMICOBJECT_FIRE:
		if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == false)
			return 0;
		if (dwLastTime != 0)  {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	dwLastTime = dwLastTime - (dwLastTime / 2);       break;
			case 2:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
			case 3:	dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
			}

			if (dwLastTime == 0) dwLastTime = 1000;
		}
		break;
	
	case DEF_DYNAMICOBJECT_FISHOBJECT:
	case DEF_DYNAMICOBJECT_FISH:
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == false)
			return 0;
		break;

	case DEF_DYNAMICOBJECT_ARESDENFLAG1:
	case DEF_DYNAMICOBJECT_ELVINEFLAG1:
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == false)
			return 0;
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, false);
		break;

	}
   	
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] == 0) {
		dwTime = timeGetTime();
		
		if (dwLastTime != 0) 
			dwLastTime += (iDice(1,4)*1000);

		m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
		m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, 0, (short)0);

		return i;
	}
	return 0;
}

void CGame::CheckDynamicObjectList()
{
 int i;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
 short sType;

	// ³¯¾¾ È¿°ú¿¡ µû¸¥ µ¿Àû °´Ã¼ÀÇ Áö¼Ó½Ã°£ ´ÜÃàÀ» °è»êÇÑ´Ù. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) { 
		if ( (m_pDynamicObjectList[i] != 0) && (m_pDynamicObjectList[i]->m_dwLastTime != 0) ) {
		
			switch (m_pDynamicObjectList[i]->m_sType) {
			case DEF_DYNAMICOBJECT_FIRE3:
			case DEF_DYNAMICOBJECT_FIRE:
				// ºÒÀÇ °æ¿ì ºñ°¡ ¿ÈÀ¸·Î ÀÎÇØ ¼ö¸íÀÌ ±Þ°ÝÈ÷ ´ÜÃàµÈ´Ù.
				switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) {
				case 0: break;
				case 1: 
				case 2:
				case 3:
					// (³²Àº ½Ã°£/10)*ºñ¿À´Â »óÅÂ ¸¸Å­ ½Ã°£À» »«´Ù.
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime - 
						                                    (m_pDynamicObjectList[i]->m_dwLastTime/10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
					break;
				}
				break;
			}
		}
	}

	// ½Ã°£ÀÌ ¸¸·áµÈ °´Ã¼¸¦ Á¾·á½ÃÅ²´Ù. Áö¼Ó½Ã°£ÀÌ NULLÀÌ¸é ¿µ¿øÈ÷ ³²¾ÆÀÖ´Â µ¿Àû °´Ã¼ÀÌ´Ù.
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) { 
		if ( (m_pDynamicObjectList[i] != 0) && (m_pDynamicObjectList[i]->m_dwLastTime != 0) && 
			 ((dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime) >= m_pDynamicObjectList[i]->m_dwLastTime) ) {
		
			// Áö¼Ó½Ã°£ÀÌ °æ°úÇÑ µ¿Àû °´Ã¼¸¦ Ã£¾Ò´Ù.
			m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject( m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime );
			// µî·Ï½Ã°£ÀÌ ÀÏÄ¡ÇÑ´Ù¸é °´Ã¼°¡ »ç¶óÁø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»Áà¾ß ÇÑ´Ù.
			
			if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
				SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, 0, (short)0);
				// ¸Ê¿¡¼­ »èÁ¦ÇÑ´Ù.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			}

			switch (sType) {
			case DEF_DYNAMICOBJECT_FISHOBJECT:
			case DEF_DYNAMICOBJECT_FISH:
				// ¹°°í±â ¿ÀºêÁ§Æ®°¡ »ç¶óÁ³À¸¹Ç·Î Ã³¸®ÇÑ´Ù.
				bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2); // ½Ã°£ÀÌ Áö³ª¼­ ¹°°í±â°¡ »ç¶óÁø´Ù.
				break;
			}
	
			// ¸®½ºÆ®¸¦ »èÁ¦ÇÑ´Ù.
			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = 0;
		}
	}
}

void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
 short sSkillIndex;
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled ) return;
	
	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		 (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		
		switch (sSkillIndex) {
		case 0:  // Mining
		case 5:  // Hand-Attack
		case 13: // Manufacturing
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr+ m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3: // Magic-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:  // Magic
		case 18: // Crafting
		case 21: // Staff-Attack
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag+ m_pClientList[iClientH]->m_iAngelicMag) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:  // Fishing
		case 6:  // Archery
		case 7:  // Short-Sword
		case 8:  // Long-Sword
		case 9:  // Fencing 
		case 10: // Axe-Attack
		case 11: // Shield        	
		case 14: // Hammer 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex+ m_pClientList[iClientH]->m_iAngelicDex) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:	 // Farming
		case 12: // Alchemy
		case 15: // óġ
		case 19: // Pretend-Corpse
		case 20: // Enchanting
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt+ m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // Poison-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		//   ִ ų ö   ⸦  ̶  ߷ 1 Ѵ. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// īƮ 0̸ ų  öٴ ǹ. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// չⰡ Ǿ ־. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// Ȱ 뿡  ų ̾. ߷ 1 ø. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// Ⱑ Ǿ ־. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// ̳ Mace 뿡  ų ̾. ߷ 1 ø. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
	 		
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKill  600  ٸ ų ϳ 1 . 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
			// Skill öٴ  Ŭ̾Ʈ ˷ش.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], 0, 0);
		}
	}
}

void CGame::CalculateSSN_SkillIndex(int iClientH, short sSkillIndex, int iValue)
{
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_bIsKilled ) return;

	// ±â¼ú ¼öÁØÀÌ 0ÀÌ¶ó¸é ½ºÅ³Àº ¿À¸£Áö ¾Ê´Â´Ù.
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

#ifdef DEF_TESTSERVER
	iValue = iValue *100;
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	// ¸¸¾à SkillSSNÀÌ Á¦ÇÑÄ¡¸¦ ³Ñ¾î¼¹´Ù¸é Skill°ªÀÌ Áõ°¡ÇÑ´Ù. 
	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		// ½ºÅ³ÀÌ ¿Ã¶ú´Ù.
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		// Æ¯¼ºÄ¡ Á¦ÇÑÀÌ ÀÖ´Â SkillÀ» Ã³¸®ÇÑ´Ù.
		switch (sSkillIndex) {
		case 0:
		case 5:
		case 13:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr+ m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:
			// ¸¶¹ý ÀúÇ×Àº ÃÖ´ë Level*2¸¸Å­ ¿À¸¥´Ù.
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 18: // Crafting
		case 21:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag+ m_pClientList[iClientH]->m_iAngelicMag) * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex+ m_pClientList[iClientH]->m_iAngelicDex) * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:
		case 12:
		case 14:
		case 15:
		case 19:
		case 20: // Enchanting
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt+ m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // µ¶¼º ÀúÇ× 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		// ¸¸¾à ¹«±â¿Í °ü·ÃÀÖ´Â ½ºÅ³ÀÌ ¿Ã¶ú°í ÇöÀç ±× ¹«±â¸¦ »ç¿ë ÁßÀÌ¶ó¸é ÇöÀç ¸íÁß·ü¿¡ 1À» ´õÇÑ´Ù. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// Ä«¿îÆ®°¡ 0ÀÌ¸é ½ºÅ³ÀÌ Á¤»óÀûÀ¸·Î ¿Ã¶ú´Ù´Â ÀÇ¹Ì. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// °ËÀÌ³ª Mace·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
			
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKillÀÇ ÃÑÇÕÀÌ 700À» ³ÑÀ¸¸é ´Ù¸¥ ½ºÅ³Áß ÇÏ³ª¸¦ 1 ³»¸°´Ù. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
		
			// SkillÀÌ ¿Ã¶ú´Ù´Â °ÍÀ» Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], 0, 0);
		}
	}
}

void CGame::MobGenerator()
{
	int i, x, j, iNamingValue, iResult, iTotalMob;
	char cNpcName[21], cName_Master[11], cName_Slave[11], cWaypoint[11];
	char cSA;
	int  pX, pY, iMapLevel, iProbSA, iKindSA, iResultNum, iNpcID;
	bool bMaster, bFirmBerserk, bIsSpecialEvent;

	if (m_bOnExitProcess ) return;

	for (i = 0; i < DEF_MAXMAPS; i++) {
		// Random Mob Generator

		//if ( (m_pMapList[i] != 0) && (m_pMapList[i]->m_bRandomMobGenerator ) && 
		//	 ((m_pMapList[i]->m_iMaximumObject - 30) > m_pMapList[i]->m_iTotalActiveObject) ) {

		if (m_pMapList[i] != 0) {
			//if (m_bIsCrusadeMode ) 
			//	 iResultNum = (m_pMapList[i]->m_iMaximumObject - 30) / 3;
			//else iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		}

		if ( (m_pMapList[i] != 0) && (m_pMapList[i]->m_bRandomMobGenerator ) && (iResultNum > m_pMapList[i]->m_iTotalActiveObject) ) {
			if ((m_iMiddlelandMapIndex != -1) && (m_iMiddlelandMapIndex == i) && (m_bIsCrusadeMode )) break;

			iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {
				// Master Mob????????.
				ZeroMemory(cName_Master, sizeof(cName_Master));
				wsprintf(cName_Master, "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = i + 65;

				ZeroMemory(cNpcName, sizeof(cNpcName));

				bFirmBerserk = false;
				iResult = iDice(1,100);
				switch (m_pMapList[i]->m_cRandomMobGeneratorLevel) {

				case 1: // arefarm, elvfarm, aresden, elvine
					if ((iResult >= 1) && (iResult < 20)) {
						iResult = 1; // Slime
					}
					else if ((iResult >= 20) && (iResult < 40)) {
						iResult = 2; // Giant-Ant
					}
					else if ((iResult >= 40) && (iResult < 85)) {
						iResult = 24; // Rabbit
					}
					else if ((iResult >= 85) && (iResult < 95)) {
						iResult = 25; // Cat
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 3; // Orc
					}
					iMapLevel = 1;
					break;

				case 2:
					if ((iResult >= 1) && (iResult < 40)) {
						iResult = 1;
					}
					else if ((iResult >= 40) && (iResult < 80)) {
						iResult = 2;
					}
					else iResult = 10;
					iMapLevel = 1;
					break;

				case 3:     // v1.4334 ????????? ????
					if ((iResult >= 1) && (iResult < 20)) {
						switch (iDice(1,2)) {
				case 1: iResult = 3;  break;
				case 2: iResult = 4;  break;
						}
					}
					else if ((iResult >= 20) && (iResult < 25)) {
						iResult = 30;
					}
					else if ((iResult >= 25) && (iResult < 50)) {
						switch (iDice(1,3)) {	
				case 1: iResult = 5;  break;
				case 2: iResult = 6;  break;
				case 3:	iResult = 7;  break;
						}
					}
					else if ((iResult >= 50) && (iResult < 75)) {
						switch (iDice(1,7)) {
				case 1:
				case 2:	iResult = 8;  break;
				case 3:	iResult = 11; break;
				case 4: iResult = 12; break;
				case 5:	iResult = 18; break;
				case 6:	iResult = 26; break;
				case 7: iResult = 28; break;
						}
					}
					else if ((iResult >= 75) && (iResult <= 100)) {
						switch (iDice(1,5)) {	
				case 1:
				case 2: iResult = 9;  break;
				case 3:	iResult = 13; break;
				case 4: iResult = 14; break;
				case 5:	iResult = 27; break;
						}
					}
					iMapLevel = 3;
					break;

				case 4:
					if ((iResult >= 1) && (iResult < 50)) {
						switch (iDice(1,2)) {
				case 1:	iResult = 2;  break;
				case 2: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						switch (iDice(1,2)) {
				case 1: iResult = 8;  break;
				case 2: iResult = 11; break;
						}
					}
					else if ((iResult >= 80) && (iResult <= 100)) {
						switch (iDice(1,2)) {
				case 1: iResult = 14; break;
				case 2:	iResult = 9;  break;
						}
					}
					iMapLevel = 2;
					break;

				case 5:
					if ((iResult >= 1) && (iResult < 30)) {
						switch (iDice(1,5)) {
				case 1:
				case 2: 
				case 3:
				case 4: 
				case 5: iResult = 2;  break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch (iDice(1,2)) {
				case 1: iResult = 3;  break;
				case 2: iResult = 4;  break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch (iDice(1,2)) {
				case 1: iResult = 5;  break;
				case 2: iResult = 7;  break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1:
				case 2: iResult = 8;  break;
				case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1: iResult = 11; break;
				case 2: iResult = 14; break;
				case 3: iResult = 9;  break;
						}
					}
					iMapLevel = 3;
					break;

				case 6: // huntzone3, huntzone4
					if ((iResult >= 1) && (iResult < 60)) {
						switch (iDice(1,4)) {
				case 1: iResult = 5;  break; // Skeleton
				case 2:	iResult = 6;  break; // Orc-Mage
				case 3: iResult = 12; break; // Cyclops
				case 4: iResult = 11; break; // Troll
						}
					}
					else if ((iResult >= 60) && (iResult < 90)) {
						switch (iDice(1,5)) {
				case 1:
				case 2: iResult = 8;  break; // Stone-Golem
				case 3:	iResult = 11; break; // Troll
				case 4:	iResult = 12; break; // Cyclops 
				case 5:	iResult = 43; break; // Tentocle
						}
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						switch (iDice(1,9)) {
				case 1:	iResult = 26; break;
				case 2:	iResult = 9;  break;
				case 3: iResult = 13; break;
				case 4: iResult = 14; break;
				case 5:	iResult = 18; break;
				case 6:	iResult = 28; break;
				case 7: iResult = 27; break;
				case 8: iResult = 29; break;
						}
					}
					iMapLevel = 4;
					break;

				case 7: // areuni, elvuni
					if ((iResult >= 1) && (iResult < 50)) {
						switch (iDice(1,5)) {
						case 1: iResult = 3;  break; // Orc
						case 2: iResult = 6;  break; // Orc-Mage
						case 3: iResult = 10; break; // Amphis
						case 4: iResult = 3;  break; // Orc
						case 5: iResult = 50; break; // Giant-Tree
						}
					}
					//else if ((iResult >= 50) && (iResult < 60)) { 
					//	iResult = 29; // Rudolph
					//}
					else if ((iResult >= 50) && (iResult < 85)) { 
						switch (iDice(1,4)) {
						case 1: iResult = 50; break; // Giant-Tree
						case 2: 
						case 3: iResult = 6;  break; // Orc-Mage
						case 4: iResult = 12; break; // Troll
						}
					}
					else if ((iResult >= 85) && (iResult <= 100)) {
						switch (iDice(1,4)) {
				case 1: iResult = 12;  break; // Troll
				case 2:
				case 3:
					if (iDice(1,100) < 3) 
						iResult = 17; // Unicorn
					else iResult = 12; // Troll
					break;
				case 4: iResult = 29;  break; // Cannibal-Plant
						}
					}
					iMapLevel = 4;
					break;

				case 8:
					if ((iResult >= 1) && (iResult < 70)) {
						switch (iDice(1,2)) {
						case 1:	iResult = 4;  break;
						case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch (iDice(1,2)) {
						case 1: iResult = 8;  break;
						case 2: iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 14; break;
					}
					iMapLevel = 4;
					break;

				case 9:
					if ((iResult >= 1) && (iResult < 70)) {
						switch (iDice(1,2)) {
				case 1:	iResult = 4;  break;
				case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1: iResult = 8;  break;
				case 2: iResult = 9;  break;
				case 3: iResult = 13; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,6)) {
				case 1: 
				case 2: 
				case 3: iResult = 9;  break;
				case 4: 
				case 5: iResult = 14; break;
				case 6: iResult = 15; break;
						}
					}

					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = true;
					iMapLevel = 5;
					break;

				case 10:
					if ((iResult >= 1) && (iResult < 70)) {
						switch (iDice(1,3)) {
				case 1:	iResult = 9; break;
				case 2: iResult = 5; break;
				case 3: iResult = 8; break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1:
				case 2:	iResult = 13; break;
				case 3: iResult = 14; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1:
				case 2: iResult = 14; break;
				case 3: iResult = 15; break;
						}
					}
					// Demon?? Berserk ????? ??? ?????
					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = true;
					iMapLevel = 5;
					break;

				case 11:
					if ((iResult >= 1) && (iResult < 30)) {
						switch (iDice(1,5)) {
				case 1:
				case 2: 
				case 3:
				case 4: 
				case 5: iResult = 2; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch (iDice(1,2)) {
				case 1: iResult = 3; break;
				case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch (iDice(1,2)) {
				case 1: iResult = 5; break;
				case 2: iResult = 7; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1:
				case 2: iResult = 10;  break;
				case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1: iResult = 11; break;
				case 2: iResult = 7; break;
				case 3: iResult = 8; break;
						}
					}
					iMapLevel = 4;
					break;

				case 12:
					if ((iResult >= 1) && (iResult < 50)) {
						switch (iDice(1,3)) {
				case 1:	iResult = 1 ; break;
				case 2: iResult = 2 ; break;
				case 3: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch (iDice(1,2)) {
				case 1: iResult = 5; break;
				case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 85) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1: iResult = 8; break;
				case 2: iResult = 11; break;
				case 3: iResult = 26; break;
						}
					}
					iMapLevel = 4;
					break;

				case 13:
					if ((iResult >= 1) && (iResult < 15)) {
						iResult = 4;
						bFirmBerserk = true;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}
					else if ((iResult >= 15) && (iResult < 40)) {
						iResult = 14;
						bFirmBerserk = true;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}
					else if ((iResult >= 40) && (iResult < 60)) {
						iResult = 9;
						bFirmBerserk = true;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}						
					else if ((iResult >= 60) && (iResult < 75)) {
						iResult = 13;
						bFirmBerserk = true;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}
					else if ((iResult >= 75) && (iResult < 95)) {
						iResult = 23;
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 22;
					}
					iMapLevel = 5;
					break;

				case 14: // icebound
					if ((iResult >= 1) && (iResult < 30)) {
						iResult = 23; // Dark-Elf
					}
					else if ((iResult >= 30) && (iResult < 50)) {
						iResult = 31; // Ice-Golem
					}
					else if ((iResult >= 50) && (iResult < 70)) {
						iResult = 22; // Beholder
						bFirmBerserk = true;
						iTotalMob = 4 - (iDice(1,2) - 1);
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						iResult = 32; // DireBoar
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 33; // Frost
					}
					iMapLevel = 5;
					break;

				case 15:
					if ((iResult >= 1) && (iResult < 35)) {
						iResult = 23; 
						bFirmBerserk = true;
					}
					else if ((iResult >= 35) && (iResult < 50)) {
						iResult = 22;
						bFirmBerserk = true;
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						iResult = 15;
					}
					else if ((iResult >= 80) && (iResult <= 100)) {
						iResult = 21;
					}
					iMapLevel = 4;
					break;

				case 16: // 2ndmiddle, huntzone1, huntzone2, 
					if ((iResult >= 1) && (iResult < 40)) {
						switch (iDice(1,3)) {
						case 1:	iResult = 7;  break; // Scorpion
						case 2: iResult = 2;  break; // Giant-Ant
						case 3: iResult = 10; break; // Amphis
						}
					}
					else if ((iResult >= 40) && (iResult < 50)) {
						iResult = 30; // Rudolph
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch (iDice(1,2)) {
						case 1: iResult = 5;  break; // Skeleton
						case 2: iResult = 4;  break; // Zombie
						}
					}
					else if ((iResult >= 85) && (iResult <= 100)) {
						switch (iDice(1,3)) {
						case 1: iResult = 8;  break; // Stone-Golem
						case 2: iResult = 11; break; // Clay-Golem
						case 3: iResult = 7;  break; // Scorpion
						}
					}
					iMapLevel = 1;
					break;

				case 17:
					if ((iResult >= 1) && (iResult < 30)) {
						switch (iDice(1,4)) {
						case 1:	iResult = 22;  break; // Giant-Frog
						case 2: iResult = 8;   break; // Stone-Golem
						case 3: iResult = 24;  break; // Rabbit
						case 4: iResult = 5;   break;
						}
					}
					else if ((iResult >= 30) && (iResult < 40)) {
						iResult = 30;
					}
					else if ((iResult >= 40) && (iResult < 70)) {
						iResult = 32;
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						iResult = 31;
						if (iDice(1,5) == 1) {
							bFirmBerserk = true;
						}
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 33;
					}
					iMapLevel = 1;
					break;

				case 18: // druncncity
					if ((iResult >= 1) && (iResult < 2)) {
						iResult = 39; // Tentocle
					}
					else if ((iResult >= 2) && (iResult < 12)) {
						iResult = 44; // ClawTurtle
					}
					else if ((iResult >= 12) && (iResult < 50)) {
						iResult = 48; // Nizie
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						iResult = 45; // Giant-Crayfish
					}
					else if ((iResult >= 80) && (iResult < 90)) {
						iResult = 34; // Stalker
					}			
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 26; // Giant-Frog
					}					
					iMapLevel = 4;
					break;

				case 19:
					if ((iResult >= 1) && (iResult < 15)) {
						iResult = 44;
					}
					else if ((iResult >= 15) && (iResult < 25)) {
						iResult = 46;
					}
					else if ((iResult >= 25) && (iResult < 35)) {
						iResult = 21;
					}
					else if ((iResult >= 35) && (iResult < 60)) {
						iResult = 43;
					}				
					else if ((iResult >= 60) && (iResult < 85)) {
						iResult = 23;
					}		
					else if ((iResult >= 85) && (iResult <= 100)) {
						iResult = 22;
					}
					iMapLevel = 4;
					break;

				case 20:
					if ((iResult >= 1) && (iResult < 2)) {
						iResult = 41;
					}
					else if ((iResult >= 2) && (iResult < 3)) {
						iResult = 40;
					}
					else if ((iResult >= 3) && (iResult < 8)) {
						iResult = 53;
					}
					else if ((iResult >= 8) && (iResult < 9)) {
						iResult = 39;
					}
					else if ((iResult >= 9) && (iResult < 20)) {
						iResult = 21;
					}
					else if ((iResult >= 20) && (iResult < 35)) {
						iResult = 16;
					}
					else if ((iResult >= 35) && (iResult < 45)) {
						iResult = 44;
					}
					else if ((iResult >= 45) && (iResult < 55)) {
						iResult = 45;
					}
					else if ((iResult >= 55) && (iResult < 75)) {
						iResult = 28;
					}
					else if ((iResult >= 75) && (iResult < 95)) {
						iResult = 43;
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						iResult = 22;
					}
					iMapLevel = 4;
					break;

				case 21:
					if ((iResult >= 1) && (iResult < 94)) {
						iResult = 17; // Unicorn
						bFirmBerserk = true;
					}
					else if ((iResult >= 94) && (iResult < 95)) {
						iResult = 36; // Wyvern
					}
					else if ((iResult >= 95) && (iResult < 96)) {
						iResult = 37; // Fire-Wyvern
					}
					else if ((iResult >= 96) && (iResult < 97)) {
						iResult = 47; // MasterMage-Orc
					}
					else if ((iResult >= 97) && (iResult < 98)) {
						iResult = 35; // Hellclaw
					}				
					else if ((iResult >= 98) && (iResult < 99)) {
						iResult = 49; // Tigerworm
					}		
					else if ((iResult >= 99) && (iResult <= 100)) {
						iResult = 51; // Abaddon
					}
					iMapLevel = 4;
					break;
	
				}			

				pX = 0;
				pY = 0;

//				bIsSpecialEvent = true;
				if ((m_bIsSpecialEventTime ) && (iDice(1,10) == 3)) bIsSpecialEvent = true;

				if (bIsSpecialEvent ) {
					switch (m_cSpecialEventType) {
					case 1:
						if (m_pMapList[i]->m_iMaxPx != 0) {
							pX = m_pMapList[i]->m_iMaxPx*20 +10;
							pY = m_pMapList[i]->m_iMaxPy*20 +10;

							if (pX < 0) pX = 0;
							if (pY < 0) pY = 0;

							if (m_bIsCrusadeMode ) {
								if (strcmp(m_pMapList[i]->m_cName, "aresden") == 0)
									switch(iDice(1,6)) {
									case 1: iResult = 20; break;
									case 2: iResult = 53; break;
									case 3: iResult = 55; break;
									case 4: iResult = 57; break;
									case 5: iResult = 59; break;
									case 6: iResult = 61; break;
								}
								else if (strcmp(m_pMapList[i]->m_cName, "elvine") == 0)
									switch(iDice(1,6)) {
									case 1: iResult = 19; break;
									case 2: iResult = 52; break;
									case 3: iResult = 54; break;
									case 4: iResult = 56; break;
									case 5: iResult = 58; break;
									case 6: iResult = 60; break;
								}
							}
							wsprintf(G_cTxt, "(!) Mob-Event Map(%s)[%d (%d,%d)]", m_pMapList[i]->m_cName, iResult, pX, pY);
						}
						break;

					case 2:
						if (iDice(1,3) == 2) {
							if ((memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7)   == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "middled1n", 9) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "arefarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "elvfarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "elvine", 6)    == 0)) {
									if (iDice(1,30) == 5) 
										iResult = 16;
									else iResult = 5;
								}
							else iResult = 16;
						}
						else iResult = 17;

						m_bIsSpecialEventTime = false;
						break;
					}
				}

				ZeroMemory(cNpcName, sizeof(cNpcName));
				//Random Monster Spawns
				switch (iResult) {
				case 1:  strcpy(cNpcName, "Slime");				iNpcID = 10; iProbSA = 5;  iKindSA = 1; break;
				case 2:  strcpy(cNpcName, "Giant-Ant");			iNpcID = 16; iProbSA = 10; iKindSA = 2; break;
				case 3:  strcpy(cNpcName, "Orc");				iNpcID = 14; iProbSA = 15; iKindSA = 1; break;
				case 4:  strcpy(cNpcName, "Zombie");			iNpcID = 18; iProbSA = 15; iKindSA = 3; break;
				case 5:  strcpy(cNpcName, "Skeleton");			iNpcID = 11; iProbSA = 35; iKindSA = 8; break;
				case 6:  strcpy(cNpcName, "Orc-Mage");			iNpcID = 14; iProbSA = 30; iKindSA = 7; break;
				case 7:  strcpy(cNpcName, "Scorpion");			iNpcID = 17; iProbSA = 15; iKindSA = 3; break;
				case 8:  strcpy(cNpcName, "Stone-Golem");		iNpcID = 12; iProbSA = 25; iKindSA = 5; break;
				case 9:  strcpy(cNpcName, "Cyclops");			iNpcID = 13; iProbSA = 35; iKindSA = 8; break;
				case 10: strcpy(cNpcName, "Amphis");			iNpcID = 22; iProbSA = 20; iKindSA = 3; break;
				case 11: strcpy(cNpcName, "Clay-Golem");		iNpcID = 23; iProbSA = 20; iKindSA = 5; break;
				case 12: strcpy(cNpcName, "Troll");				iNpcID = 28; iProbSA = 25; iKindSA = 3; break; 
				case 13: strcpy(cNpcName, "Orge");				iNpcID = 29; iProbSA = 25; iKindSA = 1; break;
				case 14: strcpy(cNpcName, "Hellbound");			iNpcID = 27; iProbSA = 25; iKindSA = 8; break;
				case 15: strcpy(cNpcName, "Liche");				iNpcID = 30; iProbSA = 30; iKindSA = 8; break;
				case 16: strcpy(cNpcName, "Demon");				iNpcID = 31; iProbSA = 20; iKindSA = 8; break;
				case 17: strcpy(cNpcName, "Unicorn");			iNpcID = 32; iProbSA = 35; iKindSA = 7; break;
				case 18: strcpy(cNpcName, "WereWolf");			iNpcID = 33; iProbSA = 25; iKindSA = 1; break;
				case 19: strcpy(cNpcName, "YB-Aresden");		iNpcID = -1;  iProbSA = 15; iKindSA = 1; break;
				case 20: strcpy(cNpcName, "YB-Elvine");			iNpcID = -1;  iProbSA = 15; iKindSA = 1; break;
				case 21: strcpy(cNpcName, "Gagoyle");			iNpcID = 52; iProbSA = 20; iKindSA = 8; break;
				case 22: strcpy(cNpcName, "Beholder");			iNpcID = 53; iProbSA = 20; iKindSA = 5; break;
				case 23: strcpy(cNpcName, "Dark-Elf");			iNpcID = 54; iProbSA = 20; iKindSA = 3; break;
				case 24: strcpy(cNpcName, "Rabbit");			iNpcID = -1; iProbSA = 5;  iKindSA = 1; break;
				case 25: strcpy(cNpcName, "Cat");				iNpcID = -1; iProbSA = 10; iKindSA = 2; break;
				case 26: strcpy(cNpcName, "Giant-Frog");		iNpcID = 57; iProbSA = 10; iKindSA = 2; break;
				case 27: strcpy(cNpcName, "Mountain-Giant");	iNpcID = 58; iProbSA = 25; iKindSA = 1; break;
				case 28: strcpy(cNpcName, "Ettin");				iNpcID = 59; iProbSA = 20; iKindSA = 8; break;
				case 29: strcpy(cNpcName, "Cannibal-Plant");	iNpcID = 60; iProbSA = 20; iKindSA = 5; break;
				case 30: strcpy(cNpcName, "Rudolph");			iNpcID = -1; iProbSA = 20; iKindSA = 5; break;
				case 31: strcpy(cNpcName, "Ice-Golem");			iNpcID = 65; iProbSA = 35; iKindSA = 8; break;
				case 32: strcpy(cNpcName, "DireBoar");			iNpcID = 62; iProbSA = 20; iKindSA = 5; break;
				case 33: strcpy(cNpcName, "Frost");				iNpcID = 63; iProbSA = 30; iKindSA = 8; break;
				case 34: strcpy(cNpcName, "Stalker");           iNpcID = 48; iProbSA = 20; iKindSA = 1; break;
				case 35: strcpy(cNpcName, "Hellclaw");			iNpcID = 49; iProbSA = 20; iKindSA = 1; break;
				case 36: strcpy(cNpcName, "Wyvern");			iNpcID = 66; iProbSA = 20; iKindSA = 1; break;
				case 37: strcpy(cNpcName, "Fire-Wyvern");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break; 
				case 38: strcpy(cNpcName, "Barlog");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 39: strcpy(cNpcName, "Tentocle");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 40: strcpy(cNpcName, "Centaurus");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 41: strcpy(cNpcName, "Giant-Lizard");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 42: strcpy(cNpcName, "Minotaurs");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 43: strcpy(cNpcName, "Tentocle");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 44: strcpy(cNpcName, "Claw-Turtle");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 45: strcpy(cNpcName, "Giant-Crayfish");	iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 46: strcpy(cNpcName, "Giant-Plant");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 47: strcpy(cNpcName, "MasterMage-Orc");	iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 48: strcpy(cNpcName, "Nizie");				iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 49: strcpy(cNpcName, "Tigerworm");			iNpcID = 50; iProbSA = 20; iKindSA = 1; break;
				case 50: strcpy(cNpcName, "Giant-Plant");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 51: strcpy(cNpcName, "Abaddon");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 52: strcpy(cNpcName, "YW-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 53: strcpy(cNpcName, "YW-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 54: strcpy(cNpcName, "YY-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 55: strcpy(cNpcName, "YY-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 56: strcpy(cNpcName, "XB-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 57: strcpy(cNpcName, "XB-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 58: strcpy(cNpcName, "XW-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 59: strcpy(cNpcName, "XW-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 60: strcpy(cNpcName, "XY-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 61: strcpy(cNpcName, "XY-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				default: strcpy(cNpcName, "Orc");				iNpcID = 14; iProbSA = 15; iKindSA = 1; break;
				}

				cSA = 0;
				if (iDice(1,100) <= iProbSA) {
					cSA = _cGetSpecialAbility(iKindSA);
				}

				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, bFirmBerserk, true)) == false) {
					m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
				}
				else {

				}
			}	

			switch (iResult) {
			case 1:	 iTotalMob = iDice(1,5)-1; break;
			case 2:	 iTotalMob = iDice(1,5)-1; break;
			case 3:	 iTotalMob = iDice(1,5)-1; break;
			case 4:	 iTotalMob = iDice(1,3)-1; break;
			case 5:	 iTotalMob = iDice(1,3)-1; break;

			case 6:  iTotalMob = iDice(1,3)-1; break;
			case 7:  iTotalMob = iDice(1,3)-1; break;
			case 8:  iTotalMob = iDice(1,2)-1; break;
			case 9:  iTotalMob = iDice(1,2)-1; break;
			case 10: iTotalMob = iDice(1,5)-1; break;
			case 11: iTotalMob = iDice(1,3)-1; break;
			case 12: iTotalMob = iDice(1,5)-1; break;
			case 13: iTotalMob = iDice(1,3)-1; break;
			case 14: iTotalMob = iDice(1,2)-1; break;
			case 15: iTotalMob = iDice(1,3)-1; break;
			case 16: iTotalMob = iDice(1,2)-1; break;
			case 17: iTotalMob = iDice(1,2)-1; break;

			case 18: iTotalMob = iDice(1,5)-1; break;
			case 19: iTotalMob = iDice(1,2)-1; break;
			case 20: iTotalMob = iDice(1,2)-1; break;
			case 21: iTotalMob = iDice(1,5)-1; break;
			case 22: iTotalMob = iDice(1,2)-1; break;
			case 23: iTotalMob = iDice(1,2)-1; break;

			case 24: iTotalMob = iDice(1,4)-1; break;
			case 25: iTotalMob = iDice(1,2)-1; break;
			case 26: iTotalMob = iDice(1,3)-1; break;
			case 27: iTotalMob = iDice(1,3)-1; break;

			case 28: iTotalMob = iDice(1,3)-1; break;
			case 29: iTotalMob = iDice(1,5)-1; break;
			case 30: iTotalMob = iDice(1,3)-1; break;
			case 31: iTotalMob = iDice(1,3)-1; break;

			case 32: iTotalMob = 1; break;
			case 33: iTotalMob = 1; break;
			case 34: iTotalMob = 1; break;
			case 35: iTotalMob = 1; break;
			case 36: iTotalMob = 1; break;

			case 37: iTotalMob = 1; break;
			case 38: iTotalMob = 1; break;
			case 39: iTotalMob = 1; break;
			case 40: iTotalMob = 1; break;
			case 41: iTotalMob = 1; break;

			case 42: iTotalMob = iDice(1,3)-1; break;
			case 43: iTotalMob = 1; break;
			case 44: iTotalMob = iDice(1,3)-1; break; 
			case 45: iTotalMob = 1; break;
			default: iTotalMob = 0; break;
			}

			if (bMaster == false) iTotalMob = 0;

			if (iTotalMob > 2) {
				switch (iResult) {
				case 1:  // Slime 
				case 2:  // Giant-Ant
				case 3:  // Orc
				case 4:  // Zombie
				case 5:  // Skeleton
				case 6:  // Orc-Mage
				case 7:  // Scorpion
				case 8:  // Stone-Golem
				case 9:  // Cyclops
				case 10: // Amphis
				case 11: // Clay-Golem
				case 12: // Troll
				case 13: // Orge
				case 14: // Hellbound
				case 15: // Liche
				case 16: // Demon
				case 17: // Unicorn
				case 18: // WereWolf
				case 19:
				case 20:
				case 21:
				case 22:
				case 23:
				case 24:
				case 25:
				case 26:
				case 27:
				case 28:
				case 29:
				case 30:
				case 31:
				case 32:
					if (iDice(1,5) == 1) iTotalMob = 0;  // 75% ???????? ???.
					break;

				case 33:
				case 34:
				case 35:
				case 36:
				case 37:
				case 38:
				case 39:
				case 40:
				case 41:
				case 42:
				case 44:
				case 45:
				case 46:
				case 47:
				case 48:
				case 49:
					if (iDice(1,5) != 1) iTotalMob = 0;  // 75% ???????????????
					break;
				}
			}

			if (bIsSpecialEvent ) {
				switch (m_cSpecialEventType) {
				case 1:
					if ((iResult != 35) && (iResult != 36) && (iResult != 37) && (iResult != 49) 
						&& (iResult != 51) && (iResult != 15) && (iResult != 16) && (iResult != 21)) iTotalMob = 12;
					for (x = 1; x < DEF_MAXCLIENTS; x++)
					if ((iNpcID != -1) && (m_pClientList[x] != 0) && (m_pClientList[x]->m_bIsInitComplete )) {
						SendNotifyMsg(0, x, DEF_NOTIFY_SPAWNEVENT, pX, pY, iNpcID, 0, 0, 0);
					}
					break;

				case 2:
					if ((memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "elvine",  6) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "elvfarm",  7) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "arefarm",  7) == 0) ) {
							iTotalMob = 0;
						}
						break;
				}
				m_bIsSpecialEventTime = false;
			}

			for (j = 0; j < iTotalMob; j++) {
				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					ZeroMemory(cName_Slave, sizeof(cName_Slave));
					wsprintf(cName_Slave, "XX%d", iNamingValue);
					cName_Slave[0] = 95; // original '_';
					cName_Slave[1] = i + 65;

					cSA = 0;

					if (iDice(1,100) <= iProbSA) {
						cSA = _cGetSpecialAbility(iKindSA);
					}

					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, bFirmBerserk) == false) {
						m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
					}
				}
			}
		}

		if ( (m_pMapList[i] != 0) && ((m_pMapList[i]->m_iMaximumObject) > m_pMapList[i]->m_iTotalActiveObject) ) {
			for (j = 1; j < DEF_MAXSPOTMOBGENERATOR; j++)
				if ( (iDice(1,3) == 2) && (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined ) &&
					(m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs > m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs) ) {
						iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {

							ZeroMemory(cNpcName, sizeof(cNpcName));
							switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) {
								// spot-mob-generator
									case 10:  strcpy(cNpcName,"Slime");				iProbSA = 5;  iKindSA = 1;  break;
									case 16:  strcpy(cNpcName,"Giant-Ant");			iProbSA = 10; iKindSA = 2;  break;
									case 14:  strcpy(cNpcName,"Orc");				iProbSA = 15; iKindSA = 1;  break;
									case 18:  strcpy(cNpcName,"Zombie");			iProbSA = 15; iKindSA = 3;  break;
									case 11:  strcpy(cNpcName,"Skeleton");			iProbSA = 35; iKindSA = 8;  break;
									case 6:   strcpy(cNpcName,"Orc-Mage");			iProbSA = 30; iKindSA = 7;  break;
									case 17:  strcpy(cNpcName,"Scorpion");			iProbSA = 15; iKindSA = 3;  break;
									case 12:  strcpy(cNpcName,"Stone-Golem");		iProbSA = 25; iKindSA = 5;  break;
									case 13:  strcpy(cNpcName,"Cyclops");			iProbSA = 35; iKindSA = 8;  break;
									case 22:  strcpy(cNpcName,"Amphis");			iProbSA = 20; iKindSA = 3;  break;
									case 23:  strcpy(cNpcName,"Clay-Golem");		iProbSA = 20; iKindSA = 5;  break;
									case 24:  strcpy(cNpcName,"Guard-Aresden");		iProbSA = 20; iKindSA = 1;  break;
									case 25:  strcpy(cNpcName,"Guard-Elvine");		iProbSA = 20; iKindSA = 1;  break;
									case 26:  strcpy(cNpcName,"Guard-Neutral");		iProbSA = 20; iKindSA = 1;  break;
									case 27:  strcpy(cNpcName,"Hellbound");			iProbSA = 20; iKindSA = 1;  break;
									case 29:  strcpy(cNpcName,"Orge");              iProbSA = 20; iKindSA = 1;  break;
									case 30:  strcpy(cNpcName,"Liche");				iProbSA = 30; iKindSA = 8;  break;
									case 31:  strcpy(cNpcName,"Demon");				iProbSA = 20; iKindSA = 8;  break;
									case 32:  strcpy(cNpcName,"Unicorn");			iProbSA = 35; iKindSA = 7;  break;
									case 33:  strcpy(cNpcName,"WereWolf");			iProbSA = 25; iKindSA = 1;  break;
									case 34:  strcpy(cNpcName,"Dummy");				iProbSA = 5;  iKindSA = 1;  break;
									case 35:  strcpy(cNpcName,"Attack-Dummy");		iProbSA = 5;  iKindSA = 1;  break;
									case 48:  strcpy(cNpcName,"Stalker");			iProbSA = 20; iKindSA = 3;  break;
									case 49:  strcpy(cNpcName,"Hellclaw");			iProbSA = 20; iKindSA = 8;  break;
									case 50:  strcpy(cNpcName,"Tigerworm");			iProbSA = 20; iKindSA = 8;  break;
									case 54:  strcpy(cNpcName,"Dark-Elf");			iProbSA = 20; iKindSA = 8;  break;
									case 53:  strcpy(cNpcName,"Beholder");			iProbSA = 20; iKindSA = 8;  break;
									case 52:  strcpy(cNpcName,"Gagoyle");			iProbSA = 20; iKindSA = 8;  break;
									case 57:  strcpy(cNpcName,"Giant-Frog");		iProbSA = 10; iKindSA = 2;  break;
									case 58:  strcpy(cNpcName,"Mountain-Giant");	iProbSA = 25; iKindSA = 1;  break;
									case 59:  strcpy(cNpcName,"Ettin");				iProbSA = 20; iKindSA = 8;  break;
									case 60:  strcpy(cNpcName,"Cannibal-Plant");	iProbSA = 20; iKindSA = 5;  break;
									case 61:  strcpy(cNpcName,"Rudolph");			iProbSA = 20; iKindSA = 1;  break;
									case 62:  strcpy(cNpcName,"DireBoar");			iProbSA = 20; iKindSA = 1;  break;
									case 63:  strcpy(cNpcName,"Frost");				iProbSA = 20; iKindSA = 8;  break;
									case 65:  strcpy(cNpcName,"Ice-Golem");			iProbSA = 20; iKindSA = 8;  break;
									case 66:  strcpy(cNpcName,"Wyvern");			iProbSA = 20; iKindSA = 1;  break;
									case 55:  strcpy(cNpcName,"Rabbit");			iProbSA = 20; iKindSA = 1;  break;
									case 67:  strcpy(cNpcName,"McGaffin");			iProbSA = 20; iKindSA = 1;  break;
									case 68:  strcpy(cNpcName,"Perry");				iProbSA = 20; iKindSA = 1;  break;
									case 69:  strcpy(cNpcName,"Devlin");			iProbSA = 20; iKindSA = 1;  break;
									case 73:  strcpy(cNpcName,"Fire-Wyvern");		iProbSA = 20; iKindSA = 1;  break;
									case 70:  strcpy(cNpcName,"Barlog");			iProbSA = 20; iKindSA = 1;  break;
									case 80:  strcpy(cNpcName,"Tentocle");			iProbSA = 20; iKindSA = 1;  break;
									case 71:  strcpy(cNpcName,"Centaurus");			iProbSA = 20; iKindSA = 1;  break;
									case 75:  strcpy(cNpcName,"Giant-Lizard");		iProbSA = 20; iKindSA = 1;  break;
									case 78:  strcpy(cNpcName,"Minotaurs");			iProbSA = 20; iKindSA = 1;  break;
									case 81:  strcpy(cNpcName,"Abaddon");			iProbSA = 20; iKindSA = 1;  break;
									case 72:  strcpy(cNpcName,"Claw-Turtle");		iProbSA = 20; iKindSA = 1;  break;
									case 74:  strcpy(cNpcName,"Giant-Crayfish");	iProbSA = 20; iKindSA = 1;  break;
									case 76:  strcpy(cNpcName,"Giant-Plant");		iProbSA = 20; iKindSA = 1;  break;
									case 77:  strcpy(cNpcName,"MasterMage-Orc");	iProbSA = 20; iKindSA = 1;  break;
									case 79:  strcpy(cNpcName,"Nizie");				iProbSA = 20; iKindSA = 1; break;
									default: 
										strcpy(cNpcName, "Orc");
										iProbSA = 15; 
										iKindSA = 1; 
										break;
							}						
							/* NPCs not spawning in pits: 
							case 56:  strcpy(cNpcName,"Cat");				iProbSA = 15; iKindSA = 6;  break;
							case 28:  strcpy(cNpcName, "Troll");			iProbSA = 25; iKindSA = 3; break; 

							// 15 ShopKeeper-W
							// 19 Gandlf          
							// 20 Howard
							// 36 Arrow Gaurd Tower Kit - Aresden, Elvine
							// 37 Cannon Gaurd Tower Kit - Aresden, Elvine
							// 38 Mana Collector Kit - Aresden, Elvine
							// 39 Detector Constructor Kit - Aresden, Elvine
							// 40 Energy Shield Generator - Aresden, Elvine
							// 41 Grand Master Generator - Aresden Elvine
							// 43 Light War Beetle - Aresden, Elvine
							// 44 God's Hand Knight
							// 45 Mounted God's Hand Knight
							// 46 Temple Knight
							// 47 Battle Golem
							// 51 Catapult
							// 64 Crops
							*/
							bFirmBerserk = false;
							if ((iMapLevel == 5) && (iDice(1,3) == 1)) bFirmBerserk = true;

							ZeroMemory(cName_Master, sizeof(cName_Master));
							wsprintf(cName_Master, "XX%d", iNamingValue);
							cName_Master[0] = 95; // original '_';
							cName_Master[1] = i + 65;

							cSA = 0;
							if ((m_pMapList[i]->m_stSpotMobGenerator[j].iMobType != 34) && (iDice(1,100) <= iProbSA)) {
								cSA = _cGetSpecialAbility(iKindSA);
							}

							switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType) {
								case 1:
									if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMAREA, &pX, &pY, cWaypoint, &m_pMapList[i]->m_stSpotMobGenerator[j].rcRect, j, -1, false, false, bFirmBerserk) == false) {
										m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
									}
									else {
										m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
									}
									break;

								case 2:
									if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMWAYPOINT, 0, 0, m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, 0, j, -1, false, false, bFirmBerserk) == false) {
										m_pMapList[i]->SetNamingValueEmpty(iNamingValue);	
									}
									else {
										m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
									}
									break;
							}
						}
					}
		}
	}
}

void CGame::CalcNextWayPointDestination(int iNpcH)
{
 short sRange, sX, sY;
 int i, j, iMapIndex;
 bool bFlag;

	switch (m_pNpcList[iNpcH]->m_cMoveType) {
	case DEF_MOVETYPE_GUARD:
		// ÁöÁ¤µÈ À§Ä¡¸¦ ¹þ¾î³ªÁö ¾ÊÀ¸¸ç Ãß°ÝÀÌ ³¡³­ ÈÄ¿¡ µ¹¾Æ¿Â´Ù.
		break;
	
	case DEF_MOVETYPE_SEQWAYPOINT: 

		m_pNpcList[iNpcH]->m_cCurWaypoint++;
		if (m_pNpcList[iNpcH]->m_cCurWaypoint >= m_pNpcList[iNpcH]->m_cTotalWaypoint)
			m_pNpcList[iNpcH]->m_cCurWaypoint = 1;
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMWAYPOINT:
	
		m_pNpcList[iNpcH]->m_cCurWaypoint = (short)((rand() % (m_pNpcList[iNpcH]->m_cTotalWaypoint - 1)) + 1);
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMAREA:
				
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.right - m_pNpcList[iNpcH]->m_rcRandomArea.left);
		m_pNpcList[iNpcH]->m_dX = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.left);
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.bottom - m_pNpcList[iNpcH]->m_rcRandomArea.top);
		m_pNpcList[iNpcH]->m_dY = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.top);
		break;

	case DEF_MOVETYPE_RANDOM:
		// ¿ÏÀü ·£´ý 
		//m_pNpcList[iNpcH]->m_dX = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX - 50)) + 15;
		//m_pNpcList[iNpcH]->m_dY = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY - 50)) + 15;
		iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

		for ( i = 0; i <= 30; i++) {
		// °¥ ¼ö ÀÖ´Â ÁÂÇ¥°¡ ³ª¿Ã¶§ ±îÁö 30¹ø ¹Ýº¹ 
			sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
			sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

			bFlag = true;
			for (j = 0; j < DEF_MAXMGAR; j++)
			if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left != -1) {
				// ÇÇÇØ¾ß ÇÒ ÁÂÇ¥°¡ ÀÖ´Ù. 
				if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left) &&
					(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].right) &&
					(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].top) &&
					(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].bottom)) {
					// Avoid Rect¾ÈÀÌ¹Ç·Î ÀÌ À§Ä¡¿¡´Â »ý¼º½ÃÅ³ ¼ö ¾ø´Ù.	
					bFlag = false;
				}
			}
			if (bFlag ) goto CNW_GET_VALIDLOC_SUCCESS;
		}
		// Fail! 
		m_pNpcList[iNpcH]->m_tmp_iError  = 0; 
		return;

CNW_GET_VALIDLOC_SUCCESS:
		m_pNpcList[iNpcH]->m_dX = sX;
		m_pNpcList[iNpcH]->m_dY = sY;
		break;
	}

	m_pNpcList[iNpcH]->m_tmp_iError  = 0; // @@@ !!! @@@
}

void CGame::DeleteNpc(int iNpcH)
{
	int  i, iNamingValue, iNumItem, iItemID, iItemIDs[MAX_NPCITEMDROP], iSlateID;
	char cTmp[21], cItemName[21];
	class CItem * pItem, * pItem2;
	DWORD dwCount, dwTime;
    POINT ItemPositions[MAX_NPCITEMDROP];
	char cTemp[256];
	SYSTEMTIME SysTime;
	if (m_pNpcList[iNpcH] == 0) return;

	dwTime = timeGetTime();

	//Init number of items to 1 unless its a multidrop;
	iNumItem = 0;
	iItemID = 0; // No current item

	//ì£½ì–´ìžˆë˜ ìœ„ì¹˜ì—ì„œ ì‚­ì œ 
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, 0, 0, 0);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);

	ZeroMemory(cTmp, sizeof(cTmp));
	strcpy(cTmp, (char *)(m_pNpcList[iNpcH]->m_cName + 2));
	// NPCì˜ NamigValueë¥¼ ì–»ì–´ì™€ ì‚¬ìš©ì¤‘ì¸ í‘œì‹œë¥¼ í•´ì§€í•œë‹¤.
	iNamingValue = atoi(cTmp);

	// NamingValueë¥¼ ë¹„ìš°ê³  ë™ìž‘ì¤‘ì¸ ê°œì²´ ìˆ˜ë¥¼ ê°ì†Œì‹œí‚¨ë‹¤.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalActiveObject--;

	// Spot-mob-generatorì •ë³´ 
	if ( m_pNpcList[iNpcH]->m_iSpotMobIndex != 0 )
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stSpotMobGenerator[m_pNpcList[iNpcH]->m_iSpotMobIndex].iCurMobs--;

	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);

	// í¬ë£¨ì„¸ì´ë“œìš© ê±´ì¶•ë¬¼ì´ë¼ë©´ ì§€íœ˜ê´€ í†µë³´ìš© ê±´ì¶•ë¬¼ ë¦¬ìŠ¤íŠ¸ë¥¼ í•´ì œ
	switch (m_pNpcList[iNpcH]->m_sType) {
	case 36:
	case 37:
	case 38:
	case 39:
	case 42:
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCrusadeStructureInfo(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		// ê¸¸ë“œ ê±´ì¶•ë¬¼ ê°œìˆ˜ë„ ê°ì†Œì‹œí‚´ 
		for (i = 0; i < DEF_MAXGUILDS; i++) 
			if (m_pGuildTeleportLoc[i].m_iV1 == m_pNpcList[iNpcH]->m_iGuildGUID) {
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				m_pGuildTeleportLoc[i].m_iV2--;
				if (m_pGuildTeleportLoc[i].m_iV2 < 0) m_pGuildTeleportLoc[i].m_iV2 = 0;
				break;	
			}
			break;
	case 64: m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum(); break;

	}

	// DelayEventë¥¼ ì‚­ì œ 
	bRemoveFromDelayEventList(iNpcH, DEF_OWNERTYPE_NPC, 0);
	if ((m_pNpcList[iNpcH]->m_bIsSummoned == false) && (m_pNpcList[iNpcH]->m_bIsUnsummoned == false)) {
		// ì†Œí™˜ëª¹ì´ ì•„ë‹ˆë¼ë©´ ì—°ê¸ˆ ìž¬ë£Œê°€ ë‚˜ì˜¨ë‹¤.
		pItem = new class CItem;
		ZeroMemory(cItemName, sizeof(cItemName));
		switch (m_pNpcList[iNpcH]->m_sType) {

		case 10: // Slime
			if (iDice(1,25) == 1) iItemID = 220; break; // SlimeJelly 
			break;

		case 11: // Skeleton
			switch(iDice(1,2))	{
			case 1:if (iDice(1,20) == 1) iItemID = 219; break; // SkeletonBones
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;
			
		case 12: // Stone-Golem
		switch(iDice(1,2)){
			case 1:	if (iDice(1,30) == 1) iItemID = 221; break; // StoneGolemPiece
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}	
			break;

		case 13: // Cyclops
			switch(iDice(1,6)){
			case 1:	if (iDice(1,36) == 1) iItemID = 194; break; // CyclopsEye
			case 2:	if (iDice(1,40) == 1) iItemID = 195; break; // CyclopsHandEdge
			case 3:	if (iDice(1,30) == 1) iItemID = 196; break; // CyclopsHeart
			case 4:	if (iDice(1,22) == 1) iItemID = 197; break; // CyclopsMeat
			case 5:	if (iDice(1,40) == 1) iItemID = 198; break; // CyclopsLeather
			case 6:	bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 14: // Orc, Orc-Mage
			switch(iDice(1,4)){
			case 1:	if (iDice(1,11) == 1) iItemID = 206; break; // OrcMeat
			case 2:	if (iDice(1,20) == 1) iItemID = 207; break; // OrcLeather
			case 3:	if (iDice(1,21) == 1) iItemID = 208; break; // OrcTeeth
			case 4: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;
			
		case 16: //Giant-Ant
			switch(iDice(1,3)){
			case 1:	if (iDice(1,9) == 1) iItemID = 192; break; // AntLeg
			case 2:	if (iDice(1,10) == 1) iItemID = 193; break; // AntFeeler
			case 3:	bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 17: //Scorpion
			switch(iDice(1,5)){
			case 1:	if (iDice(1,50) == 1) iItemID = 215; break; // ScorpionPincers
			case 2:	if (iDice(1,20) == 1) iItemID = 216; break; // ScorpionMeat
			case 3: if (iDice(1,50) == 1) iItemID = 217; break; // ScorpionSting
			case 4: if (iDice(1,40) == 1) iItemID = 218; break; // ScorpionSkin
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 18: //Zombie
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			break;

		case 22: //Amphis
			switch(iDice(1,5)){
			case 1: if (iDice(1,15) == 1) iItemID = 188; break; // SnakeMeat
			case 2:	if (iDice(1,16) == 1) iItemID = 189; break; // SnakeSkin
			case 3:	if (iDice(1,16) == 1) iItemID = 190; break; // SnakeTeeth
			case 4:	if (iDice(1,17) == 1) iItemID = 191; break; // SnakeTongue
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 23: //Clay-Golem
			switch(iDice(1,2)){
			case 1: if (iDice(1,30) == 1) iItemID = 205; break; // LumpofClay
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;


		case 27: //Hellbound
			switch(iDice(1,7)){
			case 1:	if (iDice(1,40) == 1) iItemID = 199; break; // HelboundHeart
			case 2:	if (iDice(1,38) == 1) iItemID = 200; break; // HelboundLeather
			case 3:	if (iDice(1,38) == 1) iItemID = 201; break; // HelboundTail
			case 4:	if (iDice(1,36) == 1) iItemID = 202; break; // HelboundTeeth
			case 5:	if (iDice(1,36) == 1) iItemID = 203; break; // HelboundClaw
			case 6:	if (iDice(1,50) == 1) iItemID = 204; break; // HelboundTongue
			case 7: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 28: //Troll
			switch(iDice(1,5)){
			case 1:	if (iDice(1,35) == 1) iItemID = 222; break; // TrollHeart
			case 2:	if (iDice(1,23) == 1) iItemID = 223; break; // TrollMeat
			case 3:	if (iDice(1,25) == 1) iItemID = 224; break; // TrollLeather
			case 4:	if (iDice(1,27) == 1) iItemID = 225; break; // TrollClaw
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 29: //Orge
			switch(iDice(1,7)){
			case 1:	if (iDice(1,20) == 1) iItemID = 209; break; // OgreHair
			case 2:	if (iDice(1,22) == 1) iItemID = 210; break; // OgreHeart
			case 3:	if (iDice(1,25) == 1) iItemID = 211; break; // OgreMeat
			case 4:	if (iDice(1,25) == 1) iItemID = 212; break; // OgreLeather
			case 5:	if (iDice(1,28) == 1) iItemID = 213; break; // OgreTeeth
			case 6:	if (iDice(1,28) == 1) iItemID = 214; break; // OgreClaw
			case 7: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 30: //Liche
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			break;

		case 31: //Demon
			switch(iDice(1,5)){
			case 1:	if (iDice(1,400) == 123) iItemID = 541; break; // DemonHeart
			case 2:	if (iDice(1,1000) == 123) iItemID = 542; break; // DemonMeat
			case 3:	if (iDice(1,200) == 123) iItemID = 543; break; // DemonLeather
			case 4:	if (iDice(1,300) == 123) iItemID = 540; break; // DemonEye
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 32: //Unicorn
			switch(iDice(1,5)){
			case 1:	if (iDice(1,3000) == 396) iItemID = 544; break; // UnicornHeart
			case 2:	if (iDice(1,500) == 3) iItemID = 545; break; // UnicornHorn
			case 3:	if (iDice(1,100) == 3) iItemID = 546; break; // UnicornMeat
			case 4:	if (iDice(1,200) == 3) iItemID = 547; break; // UnicornLeather
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 33: //WereWolf
			switch(iDice(1,8)){
			case 1: if (iDice(1,30) == 3) iItemID = 551; break; // WerewolfTail
			case 2:	if (iDice(1,28) == 3) iItemID = 548; break; // WerewolfHeart
			case 3:	if (iDice(1,25) == 3) iItemID = 550; break; // WerewolfMeat
			case 4:	if (iDice(1,35) == 3) iItemID = 553; break; // WerewolfLeather
			case 5:	if (iDice(1,28) == 3) iItemID = 552; break; // WerewolfTeeth
			case 6:	if (iDice(1,28) == 3) iItemID = 554; break; // WerewolfClaw
			case 7:	if (iDice(1,38) == 3) iItemID = 549; break; // WerewolfNail
			case 8: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 48: //Stalker
		case 49: //Hellclaw
		case 50: //Tigerworm
		case 52: //Gagoyle
		case 53: //Beholder
		case 54: //Dark-Elf
		case 55: //Rabbit
		case 56: //Cat
		case 57: //Giant-Frog
		case 58: //Mountain-Giant
		case 59: //Ettin
		case 60: //Cannibal-Plant
		case 61: //Rudolph
		case 62: //DireBoar
		case 63: //Frost
		case 65: //Ice
		case 70: //Barlog
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); 
			break;

		// new 05/10/2004
		case 66: // Wyvern
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sType,	// NPC Type
												50,				// È®·ü( ÃÖ¼Ò ~ ÃÖ´ë »çÀÌÀÇ ¾ÆÀÌÅÛÀÌ ³ª¿Ã È®·ü , 100 ÀÌ¸é ÃÖ´ë °¹¼ö ¸¸Å­ ³ª¿Â´Ù.)
												5,				// ³ª¿Í¾ß ÇÏ´Â Item ÃÖ¼Ò °³¼ö
												15,				// ³ª¿Ã¼ö ÀÖ´Â Item ÃÖ´ë °³¼ö
												m_pNpcList[iNpcH]->m_sX,	// ±âÁØ ÁÂÇ¥ X
												m_pNpcList[iNpcH]->m_sY,	// ±âÁØ ÁÂÇ¥ Y
												DEF_ITEMSPREAD_FIXED,		// ¾ÆÀÌÅÛ »Ñ¸®´Â ¹æ¹ý (RANDOM, FIXED)
												4,				// ¾ÆÀÌÅÛ »Ñ¸± ¹üÀ§, DEF_ITEMSPREAD_RANDOM ÀÏ¶§¸¸ »ç¿ë
												iItemIDs,			// ¹Þ¾Æ¿Ã ¾ÆÀÌÅÛ Idµé
												ItemPositions,			// ¾ÆÀÌÅÛµéÀÇ À§Ä¡
												&iNumItem);			// ¾ÆÀÌÅÛÀÇ ÃÑ °¹¼ö
			break;

		case 73: // Fire-Wyvern
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sType,	// NPC Type
												50,				// È®·ü( ÃÖ¼Ò ~ ÃÖ´ë »çÀÌÀÇ ¾ÆÀÌÅÛÀÌ ³ª¿Ã È®·ü , 100 ÀÌ¸é ÃÖ´ë °¹¼ö ¸¸Å­ ³ª¿Â´Ù.)
												5,				// ³ª¿Í¾ß ÇÏ´Â Item ÃÖ¼Ò °³¼ö
												15,				// ³ª¿Ã¼ö ÀÖ´Â Item ÃÖ´ë °³¼ö
												m_pNpcList[iNpcH]->m_sX,	// ±âÁØ ÁÂÇ¥ X
												m_pNpcList[iNpcH]->m_sY,	// ±âÁØ ÁÂÇ¥ Y
												2,				// ¾ÆÀÌÅÛ »Ñ¸®´Â ¹æ¹ý (RANDOM, FIXED)
												4,				// ¾ÆÀÌÅÛ »Ñ¸± ¹üÀ§, DEF_ITEMSPREAD_RANDOM ÀÏ¶§¸¸ »ç¿ë
												iItemIDs,			// ¹Þ¾Æ¿Ã ¾ÆÀÌÅÛ Idµé
												ItemPositions,			// ¾ÆÀÌÅÛµéÀÇ À§Ä¡
												&iNumItem);			// ¾ÆÀÌÅÛÀÇ ÃÑ °¹¼ö
			break;
		case 81:
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sType,	// NPC Type
												50,				// È®·ü( ÃÖ¼Ò ~ ÃÖ´ë »çÀÌÀÇ ¾ÆÀÌÅÛÀÌ ³ª¿Ã È®·ü , 100 ÀÌ¸é ÃÖ´ë °¹¼ö ¸¸Å­ ³ª¿Â´Ù.)
												12,				// ³ª¿Í¾ß ÇÏ´Â Item ÃÖ¼Ò °³¼ö
												20,				// ³ª¿Ã¼ö ÀÖ´Â Item ÃÖ´ë °³¼ö
												m_pNpcList[iNpcH]->m_sX,	// ±âÁØ ÁÂÇ¥ X
												m_pNpcList[iNpcH]->m_sY,	// ±âÁØ ÁÂÇ¥ Y
												DEF_ITEMSPREAD_FIXED,		// ¾ÆÀÌÅÛ »Ñ¸®´Â ¹æ¹ý (RANDOM, FIXED)
												65,				// ¾ÆÀÌÅÛ »Ñ¸± ¹üÀ§, DEF_ITEMSPREAD_RANDOM ÀÏ¶§¸¸ »ç¿ë
												iItemIDs,			// ¹Þ¾Æ¿Ã ¾ÆÀÌÅÛ Idµé
												ItemPositions,			// ¾ÆÀÌÅÛµéÀÇ À§Ä¡
												&iNumItem);
			break;
		}

		dwCount = 1;
		if (iNumItem > 0) {
			GetLocalTime(&SysTime);
			wsprintf(cTemp, "%d%02d%", SysTime.wMonth, SysTime.wDay);
			for(int j = 0; j < iNumItem; j++){
				if (pItem == 0) {
					pItem = new class CItem;
				}
				if (_bInitItemAttr(pItem, iItemIDs[j]) == false ||
					m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bGetIsMoveAllowedTile(ItemPositions[j].x, ItemPositions[j].y) == false) {
					delete pItem;
					pItem = 0;
				}
				else {
					if (iItemIDs[j] == 90) // Gold
						pItem->m_dwCount = iDice(10, 15000);
					else
						pItem->m_dwCount = dwCount;

					pItem->m_sTouchEffectType   = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1,100000);
					pItem->m_sTouchEffectValue2 = iDice(1,100000);
					pItem->m_sTouchEffectValue3 = (short)timeGetTime();
					m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(ItemPositions[j].x, ItemPositions[j].y, pItem);
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
												ItemPositions[j].x, ItemPositions[j].y,	pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute);
					_bItemLog(DEF_ITEMLOG_NEWGENDROP, 0, m_pNpcList[iNpcH]->m_cNpcName, pItem);
					pItem = 0;
				}
			}
		}
		else{
			if (_bInitItemAttr(pItem, iItemID) == false) {
					delete pItem;
					pItem = 0;
				}
			else {
					pItem->m_dwCount = dwCount;

				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				pItem->m_sTouchEffectValue3 = (short)timeGetTime();
				m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
					m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute);
				_bItemLog(DEF_ITEMLOG_NEWGENDROP, 0, m_pNpcList[iNpcH]->m_cNpcName, pItem);
			}
		}

		if (iDice(1, 100000) < 10) {
			pItem2 = new class CItem;
			switch(iDice(1,4)){
				case 1:	iSlateID = 868; break;
				case 2: iSlateID = 869; break;
				case 3: iSlateID = 870; break;
				case 4: iSlateID = 871; break;
			}
			if (_bInitItemAttr(pItem2, iSlateID) == false) {
					delete pItem2;
					pItem2 = 0;
				}
			else {
				pItem2->m_dwCount = 1;

				pItem2->m_sTouchEffectType   = DEF_ITET_ID;
				pItem2->m_sTouchEffectValue1 = iDice(1,100000);
				pItem2->m_sTouchEffectValue2 = iDice(1,100000);
				pItem2->m_sTouchEffectValue3 = (short)timeGetTime();

				m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem2);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
					m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem2->m_sIDnum, 0, pItem2->m_cItemColor, pItem2->m_dwAttribute);
				_bItemLog(DEF_ITEMLOG_NEWGENDROP, 0, m_pNpcList[iNpcH]->m_cNpcName, pItem2);
			}
		}
	}

    delete m_pNpcList[iNpcH];
	m_pNpcList[iNpcH] = 0;
}

void CGame::RequestFullObjectData(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp, wObjectID;
 char  * cp, cData[100];
 short * sp, sX, sY;
 int     sTemp, sTemp2;
 int   * ip, iRet;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wObjectID = *wp;
	
	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTSTOP;
	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	if (wObjectID < 10000) {
		// Ä³¸¯ÅÍÀÇ Á¤º¸¸¦ ¿øÇÑ´Ù. 
		// Àß¸øµÈ ÀÎµ¦½º°ªÀÌ°Å³ª Á¸ÀçÇÏÁö ¾Ê´Â ÇÃ·¹ÀÌ¾î¶ó¸é ¹«½Ã.
		if ( (wObjectID == 0) || (wObjectID >= DEF_MAXCLIENTS) ) return;
		if (m_pClientList[wObjectID] == 0) return;
		
		wp  = (WORD *)cp;
		*wp = wObjectID;			// ObjectID
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		//v1.4 ApprColor
		ip = (int *)cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp += 4;
		
		ip  = (int *)cp;
		
		// m_pClientList[i]¿Í m_pClientList[sOwnerH]ÀÇ °ü°è¸¦ ÀÔ·ÂÇÑ´Ù.
		// sStatusÀÇ »óÀ§ 4ºñÆ®°¡ FOE °ü°è¸¦ ³ªÅ¸³½´Ù. 
		sTemp = m_pClientList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
		sTemp2 = iGetPlayerABSStatus(wObjectID, iClientH); //(short)iGetPlayerRelationship(iClientH, wObjectID);
		sTemp  = (sTemp | (sTemp2 << 28));//Original : 12
		
		*ip = sTemp;
		//*sp = DEF_TEST;
		cp += 4;//Original 2
		
		if (m_pClientList[wObjectID]->m_bIsKilled ) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 41); // v1.4
	}
	else {
		// NPCÀÇ Á¤º¸¸¦ ¿øÇÑ´Ù.
		// Àß¸øµÈ ÀÎµ¦½º °ªÀÌ°Å³ª »ý¼ºµÇÁö ¾ÊÀº NPC¶ó¸é ¹«½Ã 
		if ( ((wObjectID - 10000) == 0) || ((wObjectID - 10000) >= DEF_MAXNPCS) ) return;
		if (m_pNpcList[wObjectID - 10000] == 0) return;
		
		wp  = (WORD *)cp;
		*wp = wObjectID;			
		cp += 2;

		wObjectID -= 10000;

		sp  = (short *)cp;
		sX  = m_pNpcList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pNpcList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pNpcList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pNpcList[wObjectID]->m_cName, 5);
		cp += 5;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sAppr2;
		cp += 2;
		
		ip  = (int *)cp;
	
		sTemp = m_pNpcList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
		
		sTemp2 = iGetNpcRelationship(wObjectID, iClientH);
		sTemp  = (sTemp | (sTemp2 << 28));//Original : 12	
		*ip = sTemp;
		//*sp = DEF_TEST;
		cp += 4;//Original 2

		if (m_pNpcList[wObjectID]->m_bIsKilled ) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 27); // v1.4 //Original : 25
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, true, true);
		return;
	}
}

int CGame::_iGetArrowItemIndex(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == 0) return -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != 0) {

		// Arrow ¾ÆÀÌÅÛÀÌ 1°³ ÀÌ»ó ÀÖÀ¸¸é ÀÎµ¦½º °ªÀ» ¹ÝÈ¯ÇÑ´Ù.
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW) &&
			 (m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0) )
			return i;	
	}

	return -1;
}

void CGame::ItemDepleteHandler(int iClientH, short sItemIndex, bool bIsUseItemResult)
{
	// ¼Ò¸ð¼º ¾ÆÀÌÅÛÀÇ Ä«¿îÆ®°¡ 0ÀÌ¸é »èÁ¦ÇÑ´Ù. È¤Àº Áß°í ¾ÆÀÌÅÛÀ» ÆÈ¾Æ¹ö¸° °Ï¿ì  
 
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	
	// v1.411 ·Î±×¸¦ ³²±ä´Ù. 
	_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

	// ¸ÕÀú ÀåÂøµÇ¾î ÀÖ´Ù¸é ÇØÁ¦½ÃÅ²´Ù. ÀÌ·± °æ¿ì´Â °ÅÀÇ ¾øÀ» µí 
	ReleaseItemHandler(iClientH, sItemIndex, true);
	
	// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int)bIsUseItemResult, 0, 0);

	// ¾ÆÀÌÅÛÀ» ¸Þ¸ð¸®¿¡¼­ »èÁ¦ 
	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;
	
	// !!! BUG POINT
	// ¾ÆÀÌÅÛÀÇ ÀÎµ¦½º°¡ ¹Ù²ï »óÈ²ÀÌ´Ù. ArrowIndex¿Í °°Àº °ÍÀº ´Ù½Ã ÇÒ´çÇØ¾ß ÇÑ´Ù. 
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

	// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
	iCalcTotalWeight(iClientH);
}

void CGame::NpcBehavior_Stop(int iNpcH)
{
 char  cTargetType;
 short sTarget = 0;
 bool  bFlag;

	if (m_pNpcList[iNpcH] == 0) return; 

	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 5:		
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 38:
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_ManaCollector(iNpcH);
				if (bFlag ) {
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;

		case 39: // Detector
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_Detector(iNpcH);
				
				if (bFlag ) {
					//  ߰ߴ.   ˷ Ѵ.	
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;

		case 40: // Energy Shield Generator
			break;

		case 41: // Grand Magic Generator
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				_NpcBehavior_GrandMagicGenerator(iNpcH);
			}
			break;

		case 42: // ManaStone: v2.05    5 Ѵ.
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_iV1 += 5;
			if (m_pNpcList[iNpcH]->m_iV1 >= 5) m_pNpcList[iNpcH]->m_iV1 = 5;
			break;

		default: 
			TargetSearch(iNpcH, &sTarget, &cTargetType);				
			break;
		}
		break;
	}
	
	if ((sTarget != 0)) {

		// ݸǥ ߰. 
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
		// ⼭ ǥȿ ۰  ޽ ߼. 
		return;
	}
}


void CGame::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID)
{
 int iTemp, iMax, iV1, iV2, iV3, iSEV1, iEffectResult = 0;
 DWORD dwTime;
 short sTemp, sTmpType, sTmpAppr1;
 char cSlateType[20];

	dwTime = timeGetTime();
	ZeroMemory(cSlateType,sizeof(cSlateType));

	//testcode
	//wsprintf(G_cTxt, "%d", sDestItemID);
	//PutLogList(G_cTxt);

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled ) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;

	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) || 
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) ) {
	}
	else return;
 	
	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ) {
				
		// ¾ÆÀÌÅÛÀÇ È¿°ú¿¡ ¸Â´Â Ã³¸®¸¦ ÇÑ´Ù. 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_WARM: // v2.172 2002-7-5 ص þ. 

			// õ   ص Ǿٴ ޼ ش. 
			if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 1) {
			//	SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);

				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);

				// ȿ   ߻  ̺Ʈ Ѵ.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (1*1000), 
							                iClientH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);

								
//				SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_ICE, 0, 0, 0);
			}

			m_pClientList[iClientH]->m_dwWarmEffectTime = dwTime;
			break;

		case DEF_ITEMEFFECTTYPE_LOTTERY:
			// º¹±Ç ¾ÆÀÌÅÛ EV1(È®·ü: ÃÖÀú 100) EV2(»óÇ° Á¾·ù) EV3(»óÇ° ¼ö·®)
			iTemp = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1);
			if (iTemp == iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1)) {
				// ´çÃ·!

			}
			else {
				// ²Î!
				
			}
			break;
		
		case DEF_ITEMEFFECTTYPE_SLATES:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
				// Full Ancient Slate ??
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 867) {
					// Slates dont work on Heldenian Map
					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2){
						case 2: // Bezerk slate
							m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = true;
							SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (1000 * 600),
								iClientH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, 1, 0, 0);
							strcpy(cSlateType, "Berserk");
							break;

						case 1: // Invincible slate
							if (strlen(cSlateType) == 0) {
								strcpy(cSlateType, "Invincible");
							}
						case 3: // Mana slate
							if (strlen(cSlateType) == 0) {
								strcpy(cSlateType, "Mana");
							}
						case 4: // Exp slate
							if (strlen(cSlateType) == 0) {
								strcpy(cSlateType, "Exp");
							}
							SetSlateFlag(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, true);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_ANCIENT_TABLET, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, 
												dwTime + (1000 * 600), iClientH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
							switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2) {
							case 1:
								iEffectResult = 4;
								break;
							case 3:
								iEffectResult = 5;
								break;
							case 4:
								iEffectResult = 6;
								break;
							}
					}
					if(strlen(cSlateType) > 0)
						_bItemLog(DEF_ITEMLOG_USE, iClientH, strlen(cSlateType), m_pClientList[iClientH]->m_pItemList[sItemIndex]);
				}
			}
			break;
		case DEF_ITEMEFFECTTYPE_HP:
			iMax = iGetMaxHP(iClientH);
			if (m_pClientList[iClientH]->m_iHP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iHP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
				if (m_pClientList[iClientH]->m_iHP <= 0)   m_pClientList[iClientH]->m_iHP = 1;

				iEffectResult = 1;
			}
			break;

		case DEF_ITEMEFFECTTYPE_MP:
			iMax = iGetMaxMP(iClientH);
		
			if (m_pClientList[iClientH]->m_iMP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else 
				{
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iMP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iMP > iMax) 
					m_pClientList[iClientH]->m_iMP = iMax;

				iEffectResult = 2;
			}
			break;
		case DEF_ITEMEFFECTTYPE_CRITKOMM:
			//CritInc(iClientH);
			break;
		case DEF_ITEMEFFECTTYPE_SP:
			iMax = iGetMaxSP(iClientH);
		
			if (m_pClientList[iClientH]->m_iSP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iSP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iSP > iMax) 
					m_pClientList[iClientH]->m_iSP = iMax;

				iEffectResult = 3;
			}

			if (m_pClientList[iClientH]->m_bIsPoisoned ) {
				// Áßµ¶µÈ »óÅÂ¿´´Ù¸é Áßµ¶À» Ç¬´Ù.
				m_pClientList[iClientH]->m_bIsPoisoned = false;
				// Áßµ¶ÀÌ Ç®·ÈÀ½À» ¾Ë¸°´Ù. 
				SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, false); // removes poison aura when using a revitalizing potion
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, 0, 0, 0);
			}
			break;

		case DEF_ITEMEFFECTTYPE_HPSTOCK:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
		
			m_pClientList[iClientH]->m_iHPstock += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHPstock < 0)   m_pClientList[iClientH]->m_iHPstock = 0;
			if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

			// ¹è°íÇÄÀ» ÇØ°áÇÑ´Ù. 
			m_pClientList[iClientH]->m_iHungerStatus += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
			if (m_pClientList[iClientH]->m_iHungerStatus < 0)   m_pClientList[iClientH]->m_iHungerStatus = 0;
			break;

		case DEF_ITEMEFFECTTYPE_STUDYSKILL:
			// ±â¼úÀ» ¹è¿î´Ù.	
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iSEV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
			// iV1Àº ¹è¿ï Skill ¹øÈ£. iV2´Â ±â¼ú ¼öÁØ, iSEV1Àº »ç¿ëÀÚ Á¤ÀÇ ±â¼ú ¼öÁØ(¿ì¼±¼øÀ§) 
			if (iSEV1 == 0) {
				// »ç¿ëÀÚ Á¤ÀÇ ±â¼ú¼öÁØÀÌ 0ÀÌ¶ó¸é Ç¥ÁØ ±â¼ú¼öÁØ¿¡ µû¶ó ±â¼úÀ» ¹è¿ì°Ô µÈ´Ù. 
				TrainSkillResponse(true, iClientH, iV1, iV2);
			}
			else {
		   		TrainSkillResponse(true, iClientH, iV1, iSEV1);
			}
			break;

		case DEF_ITEMEFFECTTYPE_STUDYMAGIC:
			// iV1Àº ¹è¿ï ¸¶¹ý ¹øÈ£.
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pMagicConfigList[iV1] != 0) 
				RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, false);
			break;

		/*case DEF_ITEMEFFECTTYPE_LOTTERY:
			iLottery = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->
			break;*/

		// New 15/05/2004 Changed
		case DEF_ITEMEFFECTTYPE_MAGIC:
			// Åõ¸í ¸ðµå¿´´Ù¸é ¸¶¹ý È¿°ú ¾ÆÀÌÅÛ »ç¿ë½Ã¿¡ ÇØÁ¦µÈ´Ù.
			if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 ) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
				
					bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = 0;
				}
			}

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// Recall ¸¶¹ý È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ. 
				// testcode
				RequestTeleportHandler(iClientH, "1   ");
				break;

			case 2:
				// Åõ¸í ¸¶¹ýÈ¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ. 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, true);
				break;

			case 3:
				// Åõ¸í ¸¶¹ý Ã£±â. »çÅõÀå ³»ºÎ¸é ¼Ò¿ë¾ø´Ù. 
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)
					PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, true);
				break;

			case 4:
				// fixed location teleportation: ÀÔÀå±Ç µîµî
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
				case 1:
					// ºí¸®µù ¾ÆÀÏ·Î °£´Ù 
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
						//v1.42
						ItemDepleteHandler(iClientH, sItemIndex, true);
						RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
					}
					break;
				case 2: //lotery
						ItemDepleteHandler(iClientH, sItemIndex, true);
						LoteryHandler(iClientH);
					break;
				
				case 11:	
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
				case 19:
					// °áÅõÀåÀ¸·Î °£´Ù. 
					SYSTEMTIME SysTime;

					GetLocalTime(&SysTime);
					// v1.4311-3 º¯°æ ÀÔÀå±Ç Ã¼Å© ´Þ/³¯Â¥/½Ã°£À¸·Î Ã¼Å©ÇÑ´Ù. 
					// ÀÔÀå °¡´ÉÇÑ ½Ã°£º¸´Ù ÀÛ°Å³ª °°À¸¸é ÀÔÀå±ÇÀÌ »ç¶óÁø´Ù.
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != SysTime.wMonth) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != SysTime.wDay) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 <= SysTime.wHour) ) {
						// ³¯Â¥°¡ Á¤È®ÇÏÁö ¾Ê´Ù. ¾Æ¹«·± È¿°ú°¡ ¾ø°í ÀÔÀå±ÇÀº »ç¶óÁø´Ù.
					}
					else {
						char cDestMapName[11];
						ZeroMemory(cDestMapName, sizeof(cDestMapName));
						wsprintf(cDestMapName, "fightzone%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 - 10);
						if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
							//v1.42
							ItemDepleteHandler(iClientH, sItemIndex, true);
							RequestTeleportHandler(iClientH, "2   ", cDestMapName, -1, -1);
						}
					}
					break;
				}
				break;

			case 5:
				// ¼ÒÈ¯È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, true,
					               m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); 	         
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_FIRMSTAMINAR:
			m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar > 20*30) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = 20*30; // ÃÖ´ë 30ºÐ°£ 
			break;

		case DEF_ITEMEFFECTTYPE_CHANGEATTR:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// ¸Ó¸® »öÀ» ¹Ù²Û´Ù. 
				m_pClientList[iClientH]->m_cHairColor++;
				if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 2:
				// ¸Ó¸® ½ºÅ¸ÀÏÀ» ¹Ù²Û´Ù.
				m_pClientList[iClientH]->m_cHairStyle++;
				if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 3:
				// ÇÇºÎ»öÀ» ¹Ù²Û´Ù.
				// ³»¿ëÀ» ¹ÙÅÁÀ¸·Î Appearance¸¦ °è»ê, ÇÒ´çÇÑ´Ù.
				m_pClientList[iClientH]->m_cSkin++;
				if (m_pClientList[iClientH]->m_cSkin > 3)
					m_pClientList[iClientH]->m_cSkin = 1;
				
				if (m_pClientList[iClientH]->m_cSex == 1)      sTemp = 1;
				else if (m_pClientList[iClientH]->m_cSex == 2) sTemp = 4; 
				
				switch (m_pClientList[iClientH]->m_cSkin) {
				case 2:	sTemp += 1; break;
				case 3:	sTemp += 2; break;
				}
				m_pClientList[iClientH]->m_sType  = sTemp;
				break;

			case 4:
				// ¼ºÀüÈ¯ - ¸¸¾à ¿ÊÀ» ÀÔ°í ÀÖ´Ù¸é ½ÇÆÐÇÑ´Ù. 
				sTemp = m_pClientList[iClientH]->m_sAppr3 & 0xFF0F;
				if (sTemp == 0) {
					// sTemp°¡ 0ÀÌ ¾Æ´Ï¶ó¸é °Ñ¿Ê, ¼Ó¿Ê, ¹ÙÁöÁß ÇÑ°¡Áö¸¦ ÀÔ°í ÀÖ´Â °ÍÀÌ´Ù. ¼ºÀüÈ¯À» ÇÒ ¼ö ¾ø´Ù. 
					if (m_pClientList[iClientH]->m_cSex == 1) 
						 m_pClientList[iClientH]->m_cSex = 2;
					else m_pClientList[iClientH]->m_cSex = 1;

					// ³»¿ëÀ» ¹ÙÅÁÀ¸·Î Appearance¸¦ °è»ê, ÇÒ´çÇÑ´Ù.
					if (m_pClientList[iClientH]->m_cSex == 1) {
						// ³²ÀÚÀÌ´Ù. 
						sTmpType = 1;
					}
					else if (m_pClientList[iClientH]->m_cSex == 2) {
						// ¿©ÀÚÀÌ´Ù.
						sTmpType = 4; 
					}

					switch (m_pClientList[iClientH]->m_cSkin) {
					case 1:
						// ¹éÀÎÀÌ¸é ±×´ë·Î.
						break;
					case 2:
						sTmpType += 1;
						break;
					case 3:
						sTmpType += 2;
						break;
					}

					sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
					m_pClientList[iClientH]->m_sType  = sTmpType;
					m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1; 
					//
				}
				break;
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;
		}
		// *** Request Teleport Handler°¡ ÀÛµ¿µÇ¸é ÀÌ¹Ì µ¥ÀÌÅÍ ÀúÀåÀÌ ¿äÃ»µÈ »óÅÂÀÌ¹Ç·Î ÀÌÈÄ¿¡ ¾ÆÀÌÅÛÀ» ¾ø¾ÖºÁ¾ß ¼Ò¿ëÀÌ ¾ø´Ù. 
		// ¾ÆÀÌÅÛÀ» ¸ÕÀú ¾ø¾Ø´Ù.
		ItemDepleteHandler(iClientH, sItemIndex, true);
		
		switch (iEffectResult) {
		case 1:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);
			break;
		case 2:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);
			break;
		case 3:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			break;
		case 4: // Invincible
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_INVINCIBLE, 0, 0, 0, 0);
			break;
		case 5: // Mana
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_MANA, 0, 0, 0, 0);
			break;
		case 6: // EXP
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_EXP, 0, 0, 0, 0);
			break;
		default:
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) {
		// »ç¿ëÇÏ¸é¼­ ¸ñÇ¥ÁöÁ¡À» ÁöÁ¤ÇÏ´Â ¾ÆÀÌÅÛ.
		// dX, dYÀÇ ÁÂÇ¥°¡ À¯È¿ ¹üÀ§ ³»¿¡ ÀÖ´ÂÁö È®ÀÎÇØ¾ß ÇÑ´Ù.
		if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID) ) 
			ItemDepleteHandler(iClientH, sItemIndex, true); 
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) {
		// È­»ìÀ» ÇÒ´çÇÑ´Ù. 
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) {
		// ¿µ±¸È÷ ¾µ ¼ö ÀÖ´Â ¾ÆÀÌÅÛ. Áï ¾²°í³ªµµ ¾ø¾îÁöÁö ¾Ê´Â ¾ÆÀÌÅÛ. (ex: Áöµµ) 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_SHOWLOCATION:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			switch (iV1) {
			case 1:
				// ÇöÀç ÀÚ½ÅÀÇ À§Ä¡¸¦ º¸¿©ÁØ´Ù. 
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 1, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 2, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0)
					 SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 3, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0)
					 SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 4, 0, 0);	
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone2") == 0)
					 SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 5, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone1") == 0)
					 SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 6, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone4") == 0)
					 SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 7, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone3") == 0)
					 SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 8, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "arefarm") == 0)
					 SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 9, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvfarm") == 0)
					 SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 10, 0, 0);
				else SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 0, 0, 0);
				break;
			}
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) {
		// ±â¼ú°ú °ü·ÃµÈ ¾ÆÀÌÅÛÀ» »ç¿ëÇÑ´Ù. ¾ÆÀÌÅÛÀÇ ¼ö¸íÀ» ³·Ãß°í µô·¹ÀÌ ÀÌº¥Æ®¿¡ µî·ÏÇÑ´Ù. 
		
		if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) || 
			 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) ||
			 (m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] ) ) {
			// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´Ù Çß°Å³ª ¾ø°Å³ª °ü·Ã ½ºÅ³À» »ç¿ëÁßÀÌ¶ó¸é ¹«½Ã 
			return;
		}
		else {
			if ( m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan != 0 ) {
				// ÃÖ´ë ¼ö¸íÀÌ 0ÀÌ¸é »ç¿ëÇØµµ ¼ö¸íÀÌ ÁÙÁö ¾Ê´Â´Ù.
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan--;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CURLIFESPAN, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan, 0, 0);
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) {
					// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´Ù µÇ¾ú´Ù.
					// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMLIFESPANEND, DEF_EQUIPPOS_NONE, sItemIndex, 0, 0);
				}
				else {
					// ±â¼ú »ç¿ë ½Ã°£ ID°ªÀ» ±¸ÇÑ´Ù. v1.12
					int iSkillUsingTimeID = (int)timeGetTime();
					
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_USEITEM_SKILL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill, 
			                     dwTime + m_pSkillConfigList[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]->m_sValue2*1000, 
								 iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY, 
								 m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ], iSkillUsingTimeID, 0);
					
					// ±â¼ú »ç¿ëÁß 
					m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = true;
					m_pClientList[iClientH]->m_iSkillUsingTimeID[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = iSkillUsingTimeID; //v1.12
		 		}
			}
		}
	}
}

void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, bool bExp, int iAttr)
{
 int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack, iRepDamage;
 char cAttackerSide, cDamageMoveDir;
 DWORD dwTime, iExp;
 double dTmp1, dTmp2, dTmp3;
 short sAtkX, sAtkY, sTgtX, sTgtY, dX, dY, sItemIndex;

 	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == 0) return;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) && 
		(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1) && (m_bHeldenianInitiated )) return;
	
	dwTime = timeGetTime();
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:	
		if ((m_bAdminSecurity ) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return;
		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) iDamage += 4;
		if ((m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] == -1) || (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] == -1)) {
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 732 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 738) {
					iDamage *= (int)1.2;
				}
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) {
					if (m_pClientList[sAttackerH]->m_iRating > 0) {
						iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
						if (iRepDamage < 5) iRepDamage = 5;
						if (iRepDamage > 15) iRepDamage = 15;
						iDamage += iRepDamage;
					}
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != 0) {
							if (m_pClientList[sTargetH]->m_iRating < 0) {
								iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
								if (iRepDamage > 10) iRepDamage = 10;
								iDamage += iRepDamage;
							}
						}
					}
				}
			}
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
						if (iRepDamage > 5) iRepDamage = 5;
						iDamage += iRepDamage;
						}
					}
				}
			}
		}

		if ((m_bIsCrusadeMode == false) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil ) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

		dTmp1 = (double)iDamage;
		dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag+ m_pClientList[sAttackerH]->m_iAngelicMag);
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);

		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
		if (iDamage <= 0) iDamage = 0;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone ) 
			iDamage += iDamage/3;

		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage/3;
		}

		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode ) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
			if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
				iDamage += (iDamage*7)/10 ;
			} else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
				iDamage += iDamage/2;
			} else 
				iDamage += iDamage/3;
		}
		
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == false) return;
		if (m_pClientList[sTargetH]->m_bIsKilled ) return;

		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == false) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil )) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral ) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation )) return;
		
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		if ((m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == false) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral ) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
		if ((m_pClientList[sTargetH]->m_iPartyID != 0) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode ) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {

				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone ) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);
		
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, true);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iIndex, m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan, 0, 0);
			}
		}

		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect ) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled )) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				return;
			}
		}
		
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (iDice(1,100) <= (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
					}
				}
				
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != true) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], 0, 0);							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}

		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode ) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
			return;

		case 4:
			if (sTgtX == sAtkX) {
				if (sTgtY == sAtkY) return;
				else if (sTgtY > sAtkY) cDamageMoveDir = 5;
				else if (sTgtY < sAtkY) cDamageMoveDir = 1;
			}
			else if (sTgtX > sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 3;
				else if (sTgtY > sAtkY) cDamageMoveDir = 4;
				else if (sTgtY < sAtkY) cDamageMoveDir = 2;
			}
			else if (sTgtX < sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 7;
				else if (sTgtY > sAtkY) cDamageMoveDir = 6;
				else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
			}

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
				cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];			
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) return;
			}
						
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
				
			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
				cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) return;
			}
						
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);

			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) ) {
				DeleteNpc(sTargetH);
			}
			return;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}

		switch (m_pNpcList[sTargetH]->m_sType) {
				case 67: // McGaffin
				case 68: // Perry
				case 69: // Devlin
				return;
		}
		
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return ;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
						
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;

				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0) ) {
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						iExp = iDamage;
						if ((m_bIsCrusadeMode ) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (DWORD)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
											
						if (bExp ) 
							 GetExp(sAttackerH, iExp, true);
						else GetExp(sAttackerH, (iExp/2), true);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode ) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (DWORD)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
						
						if (bExp ) 
							 GetExp(sAttackerH, iExp, true);
						else GetExp(sAttackerH, (iExp/2), true);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_Damage_Spot_Type2(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, bool bExp, int iAttr)
{
 int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack, iRepDamage;
 char cAttackerSide, cDamageMoveDir, cDamageMinimum;
 DWORD dwTime, iExp;
 double dTmp1, dTmp2, dTmp3;
 short sTgtX, sTgtY, sItemIndex;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] == 0)) return;
	if ((cAttackerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sAttackerH] == 0)) return;
	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) && 
		(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1) && (m_bHeldenianInitiated )) return;
	
	dwTime = timeGetTime();
	sTgtX = 0;
	sTgtY = 0;
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		if ((m_bAdminSecurity ) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return;
		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) iDamage += 4;
		if ((m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] == -1) || (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] == -1)) {
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862) {
					iDamage *= (int)1.3f;
				}
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) {
					if (m_pClientList[sAttackerH]->m_iRating > 0) {
						iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
						if (iRepDamage < 5) iRepDamage = 5;
						if (iRepDamage > 15) iRepDamage = 15;
						iDamage += iRepDamage;
					}
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != 0) {
							if (m_pClientList[sTargetH]->m_iRating < 0) {
								iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
								if (iRepDamage > 10) iRepDamage = 10;
								iDamage += iRepDamage;
							}
						}
					}
				}
			}
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
						if (iRepDamage > 5) iRepDamage = 5;
						iDamage += iRepDamage;
						}
					}
				}
			}
		}

		if ((m_bIsCrusadeMode == false) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil ) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

		dTmp1 = (double)iDamage;
		dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag+ m_pClientList[sAttackerH]->m_iAngelicMag);
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		if (iDamage <= 0) iDamage = 0;
		// order switched with above
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone ) 
			iDamage += iDamage/3;

		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage/3;
		}

		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode ) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
			if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
				iDamage += (iDamage*7)/10 ;
			} else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
				iDamage += iDamage/2;
			} else 
				iDamage += iDamage/3;
		}
		
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == false) return;
		if (m_pClientList[sTargetH]->m_bIsKilled ) return;
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if ((m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == false) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral ) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == false) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil )) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral ) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation )) return;
		
		if ((m_pClientList[sTargetH]->m_iPartyID != 0) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode ) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {

				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone ) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);
		
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, true);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iIndex, m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan, 0, 0);
			}
		}

		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}
	
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;
		
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) break;

		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect ) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled )) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				return;
			}
		}
		
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (iDice(1,100) <= (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
					}
				}
				
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone )) {
					cDamageMinimum = 80;
				}
				else {
					cDamageMinimum = 50;
				}

				if (iDamage >= cDamageMinimum) {
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;
					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY) return;
							else if (sTgtY > sAtkY) cDamageMoveDir = 5;
							else if (sTgtY < sAtkY) cDamageMoveDir = 1;
						}
						else if (sTgtX > sAtkX) {
							if (sTgtY == sAtkY)     cDamageMoveDir = 3;
							else if (sTgtY > sAtkY) cDamageMoveDir = 4;
							else if (sTgtY < sAtkY) cDamageMoveDir = 2;
						}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}
					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, 0, 0);
				}

				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != true) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], 0, 0);							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode ) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
		case 6:
			return;

		case 3:
		case 5:
			if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 40:
				case 41:
					if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
					break;
				}
			}
		}
	
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return ;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);		
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						iExp = iDamage;
						if ((m_bIsCrusadeMode ) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (DWORD)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
											
						if (bExp ) 
							 GetExp(sAttackerH, iExp, true);
						else GetExp(sAttackerH, (iExp/2), true);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode ) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (DWORD)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
						
						if (bExp ) 
							 GetExp(sAttackerH, iExp, true);
						else GetExp(sAttackerH, (iExp/2), true);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, bool bExp, int iAttr)
{
 int iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack;
 DWORD dwTime, wWeaponType;
 char cAttackerSide, cDamageMoveDir;
 double dTmp1, dTmp2, dTmp3;
 int iPartyID, iMoveDamage;
 short sTgtX, sTgtY;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == 0) return;

	dwTime = timeGetTime();
	sTgtX = 0;
	sTgtY = 0;
	
	// ش ŸϿ  δ. 
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	iPartyID = 0;

	// ڰ ÷̾ Mag  ʽ   
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		if ((m_bAdminSecurity ) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return ;
		dTmp1 = (double)iDamage;
		dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag+ m_pClientList[sAttackerH]->m_iAngelicMag);
			
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		if (iDamage <= 0) iDamage = 0;

		// v1.432 2001 4 7 13 7
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		// v1.44 ̸  1.33 
		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone ) 
			iDamage += iDamage/3;

		// Crusade :  ϶  ݷ 1.33 
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode ) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
		{
 			// v2.15    Ѵ. 1.7  
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage* 7)/10 ;
			} // v2.15    Ѵ. 1.5  
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage/2;
			} else iDamage += iDamage/3;
		}

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) {
			iDamage += 4;
		}

		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 34) {
			iDamage += iDamage/3;
		}

		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage/3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		//      
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == false) return;
		// ̹ ׾ ִٸ ó .
		if (m_pClientList[sTargetH]->m_bIsKilled ) return;
		//   ȣ ޾ƾ Ѵٸ 
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		// ڰ ġ   Ұ ̶ 
		// v2.03  ٿǾ ħ 
		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if ((m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == false) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
		// v1.41 ڰ ߸̸   Ұϴ. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral ) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		// v2.172   ݴ ʴ´. ڿ NPC  ߸  ʵǰ 
		if ((m_bIsCrusadeMode == false) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsPlayerCivil )) return ;
		if ((m_bIsCrusadeMode == false) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil )) return ;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral ) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil )) return;

		// 01-12-17  Ƽ̸  Ұ 
		if ((m_pClientList[sTargetH]->m_iPartyID != 0) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		//  ڰ ÷̰̾ ڰ     ǹ̰ . 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode ) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
					// ƹ ȿ .  Һ پǷ 
				}
				else {
					//       ٸ  ó ؾѴ.
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone ) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
							//   ٸ .  ϴ. 
						}
						else return;
					}
					else return;
				}
			}

			//  ȣ Ȥ  ̶    
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}
		
		// ų ¸  ȿȭ Ѵ.
		ClearSkillUsingStatus(sTargetH);

		// v1.432 Ӽ   
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}
		
		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			//    ȿ  ̴.
			
			//     δ. 
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: // Ӷ  20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337: //   10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				//     μ. 
				ItemDepleteHandler(sTargetH, iIndex, true);
			}
			else {
				//      δ. 
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iIndex, m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan, 0, 0);
			}
		}

		// v1.42 ߰    
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		// v1.4 VIT    
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		//   ȣ̶  1/2 
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect ) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			// ȿ  Ѵ.
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		// v1.432 Ư ɷ     ȿ Ȱȭ     ʴ´.
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled )) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			// ÷̾ ߴ.
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				// v2.04 Ÿ ޾Ҵµ  ȯ Ưġ ־ٸ 
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					// ִ ġ 
					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				// v2.04 Ÿ ޾Ҵµ ʻ  Ưġ ־ٸ 
				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					// Ȯ 꿡  ʻⰡ ȴ.
					if (iDice(1,100) <= (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						// v1.12  Ŭ̾Ʈ  īƮ ġ ʴ 찡   Ƿ   .
						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
					}
				}

				// v1.44 ̸  80̻϶ и.
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone )) 
					 iMoveDamage = 80;
				else iMoveDamage = 50;

				if (iDamage >= iMoveDamage) {
					//  50̸̻ ƨ.
			///		char cDamageMoveDir;
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;

					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto EDSD_SKIPDAMAGEMOVE;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					// v1.44 з  ԷѴ.
					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					//   뺸Ѵ. <- HP ״ ˸.
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
					// ƨ  ޽ Է 	
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, 0, 0);
				}
				else {
EDSD_SKIPDAMAGEMOVE:
					//   뺸Ѵ. <- HP ״ ˸.
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
					//  ޾Ҵٸ ݵ  
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
				}

				// v1.4 ôϰ ִ  Owner ġ ű. 
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != true) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person Ǿ ־ ¶ Ǯ.  з  ͵ Ǯ.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], 0, 0);
							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode ) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
			return;
		}
		
		//   ׷  ׷,  ǵ ׷ʹ Ʊ̳ ߸ ݿ   ʴ´.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}

		switch (m_pNpcList[sTargetH]->m_sType) {
			case 67: // McGaffin
			case 68: // Perry
			case 69: // Devlin
				iDamage = 0;
			break;
		}
		
		// Ͱ    ִٸ(AbsDamage 0 ũ)    ҽŲ.
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		//   ȣ̶  1/2 
		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// NPC ߴ.
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			// ݴ ִ. ݰѴ.

			//   ݰ ʴ´.
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				// v2.15    ݰѴ.			
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			//  ޾Ҵٸ ݵ 
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
			
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {

				// ̰   ݰ ʴ´.
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				// ActionLimit 1̸ ݰ  ʴ´.  ϼ .
				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
				
				// ⼭ ǥȿ ۰  ޽ ߼.

				// Damage    ȿ.
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold Ǿ ־ ¶ Ǯ. 	
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				//Crusade
				DWORD iExp;

				// NPC   Ƿ ڰ ÷̾   ŭ ġ ڿ ش. 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0) ) {
					// ExpStock ø.  ȯ  ġ ø ʴ´.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						// Crusade
						iExp = iDamage;
						if ((m_bIsCrusadeMode ) && (iExp > 10)) iExp = 10;

						//v2.03 918 ġ  
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (DWORD)dTmp3;
						}
						
						// v2.17 2002-8-6   100 ̸̻ 䳢 ̸  ġ ö ʴ´.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}

						if (bExp ) 
							 GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
						else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						// Crusade
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode ) && (iExp > 10)) iExp = 10;

						//v2.03 918 ġ  
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (DWORD)dTmp3;
						}

						// v2.17 2002-8-6   100 ̸̻ 䳢 ̸  ġ ö ʴ´.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}


						if (bExp ) 
							 GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iHP, iMaxHP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	iHP = iDice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsKilled ) return;
		iMaxHP = (3*m_pClientList[sTargetH]->m_iVit) + (2*m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iStr+ m_pClientList[sTargetH]->m_iAngelicStr)/2);
		if (m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown != 0) 
			iMaxHP = iMaxHP - (iMaxHP/m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown);
		if (m_pClientList[sTargetH]->m_iHP < iMaxHP) {
			m_pClientList[sTargetH]->m_iHP += iHP;
			if (m_pClientList[sTargetH]->m_iHP > iMaxHP) m_pClientList[sTargetH]->m_iHP = iMaxHP;
			if (m_pClientList[sTargetH]->m_iHP <= 0)     m_pClientList[sTargetH]->m_iHP = 1;
			SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if (m_pNpcList[sTargetH]->m_bIsKilled ) return;
		iMaxHP = m_pNpcList[sTargetH]->m_iHitDice*4;
		if (m_pNpcList[sTargetH]->m_iHP < iMaxHP) {
			m_pNpcList[sTargetH]->m_iHP += iHP;
			if (m_pNpcList[sTargetH]->m_iHP > iMaxHP) m_pNpcList[sTargetH]->m_iHP = iMaxHP;
			if (m_pNpcList[sTargetH]->m_iHP <= 0)     m_pNpcList[sTargetH]->m_iHP = 1;
		}
		break;
	}
}

void CGame::Effect_SpDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iSP, iMaxSP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	// ÇØ´ç Å¸ÄÏÀÇ Sp¸¦ ³»¸°´Ù.
	iSP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsKilled ) return;
	
		// New 19/05/2004
		// Is the user having an invincibility slate
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

		iMaxSP = (2*(m_pClientList[sTargetH]->m_iStr+ m_pClientList[sTargetH]->m_iAngelicStr)) + (2*m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP > 0) {
			
			//v1.42 
			if (m_pClientList[sTargetH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[sTargetH]->m_iSP -= iSP;
				if (m_pClientList[sTargetH]->m_iSP < 0) m_pClientList[sTargetH]->m_iSP = 0;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC´Â ½ºÅÂ¹Ì³Ê °³³äÀÌ ¾ø´Ù.
		break;
	}
}


void CGame::Effect_SpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iSP, iMaxSP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	// ÇØ´ç Å¸ÄÏÀÇ Sp¸¦ ¿Ã¸°´Ù.
	iSP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsKilled ) return;
	
		iMaxSP = (2*(m_pClientList[sTargetH]->m_iStr+ m_pClientList[sTargetH]->m_iAngelicStr)) + (2*m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP < iMaxSP) {
			m_pClientList[sTargetH]->m_iSP += iSP;
			
			if (m_pClientList[sTargetH]->m_iSP > iMaxSP) 
				m_pClientList[sTargetH]->m_iSP = iMaxSP;

			SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SP, 0, 0, 0, 0);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC´Â ½ºÅÂ¹Ì³Ê °³³äÀÌ ¾ø´Ù.
		break;
	}
}

/*********************************************************************************************************************
**  int bool CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio) **
**  description			:: calculates if a player resists magic														**
**  last updated		:: November 20, 2004; 8:42 PM; Hypnotoad													**
**	return value		:: bool																						**
**  commentary			::	-	hero armor for target mages adds 50 magic resistance								**
**							-	10000 or more it ratio will deduct 10000 hit ratio									**
**							-	invincible tablet is 100% magic resistance											**
**********************************************************************************************************************/
bool CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 double dTmp1, dTmp2, dTmp3;
 int    iTargetMagicResistRatio, iDestHitRatio, iResult;
 char   cTargetDir, cProtect;								 

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return false;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == false) return false;
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return true;
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return true;
		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pClientList[sTargetH]->m_cSkillMastery[3] + m_pClientList[sTargetH]->m_iAddMR;
		if ((m_pClientList[sTargetH]->m_iMag+ m_pClientList[sTargetH]->m_iAngelicMag) > 50)
			iTargetMagicResistRatio += ((m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_iAngelicMag) - 50);
		iTargetMagicResistRatio += m_pClientList[sTargetH]->m_iAddResistMagic;
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]; 
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return false;
		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pNpcList[sTargetH]->m_cResistMagic;
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]; 
		break;
	}

	if (cProtect == 5) return true;

	if ((iHitRatio < 1000) && (cProtect == 2)) return true;
	if (iHitRatio >= 10000) iHitRatio -= 10000;
	if (iTargetMagicResistRatio < 1) iTargetMagicResistRatio = 1;
	if ((cAttackerDir != 0) && (m_pClientList[sTargetH] != 0) && (m_pClientList[sTargetH]->m_cHeroArmourBonus == 2)) {
		iHitRatio += 50;
	}
	
	dTmp1 = (double)(iHitRatio);
	dTmp2 = (double)(iTargetMagicResistRatio);
	dTmp3 = (dTmp1 / dTmp2)*50.0f;
	iDestHitRatio = (int)(dTmp3); 
	
	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;
	if (iDestHitRatio >= 100) return false;
	
	iResult = iDice(1, 100);
	if (iResult <= iDestHitRatio) return false;

	if (cTargetType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sTargetH, 3, 1);
	return true;
}

bool CGame::bCheckResistingIceSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 // õ ΰ Ȯ .
 int    iTargetIceResistRatio, iResult;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return false;
		// v1.4 ڿ  õ ǹ 
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return true;
		iTargetIceResistRatio = m_pClientList[sTargetH]->m_iAddAbsWater*2; 
		// v2.172 ص  ԰ 30ʰ  ʴ´.
		if (m_pClientList[sTargetH]->m_dwWarmEffectTime == 0) {
		}
		else if ((timeGetTime() - m_pClientList[sTargetH]->m_dwWarmEffectTime) < 1000*30) return true;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return false;
		iTargetIceResistRatio = (m_pNpcList[sTargetH]->m_cResistMagic) - (m_pNpcList[sTargetH]->m_cResistMagic/3); // ⿡   ġ Է. NPC    70%  
		break;
	}
	
	if (iTargetIceResistRatio < 1) iTargetIceResistRatio = 1;
	
	iResult = iDice(1, 100);
	if (iResult <= iTargetIceResistRatio) return true;

	return false;
}

bool CGame::bSetItemToBankItem(int iClientH, class CItem * pItem)
{
 int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];		   
	
	if (m_pClientList[iClientH] == 0) return false;
	if (pItem == 0) return false;
	//wh remove
	//if (m_pClientList[iClientH]->m_bIsInsideWarehouse == false) return false;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {
		
		m_pClientList[iClientH]->m_pItemInBankList[i] = pItem;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; // À§Ä¡ ÀúÀå 
		cp++;

		// 1°³.
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		// v1.432
		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù. v1.41 Á¦°ÅÇÏÁö ¾Ê´Â´Ù.
			// DeleteClient(iClientH, true, true);
			return true; // v1.41 FALSE¸¦ ¹ÝÈ¯ÇÏ¸é ¾ÆÀÌÅÛÀÌ ¹Ù´Ú¿¡ º¹»çµÈ´Ù.
		}

		return true;
	}

	// ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¿©À¯°ø°£ÀÌ ¾ø´Ù.
	return false;
}

bool CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 int i;
 int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
 short sDownSkillIndex;

	if (m_pClientList[iClientH] == 0) return false;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// ½ºÅ³ÀÇ Æ÷ÀÎÆ®°¡ ÃÊ°úµÇ¾ú´Ù. ÃÊ°úµÈ Æ÷ÀÎÆ® ¸¸Å­ ·çÇÁ¸¦ µ¹¸ç SSNÀÌ °¡Àå ³·Àº ½ºÅ³À» ³»¸°´Ù.	
		while (iRemainPoint > 0) {
			
			sDownSkillIndex = -1; // v1.4
			if (m_pClientList[iClientH]->m_iDownSkillIndex != -1) { 
				// ÁöÁ¤µÈ ½ºÅ³ÀÌ ÀÖ´Ù. 
				switch (m_pClientList[iClientH]->m_iDownSkillIndex) {
				case 3: // ¸¶¹ý ÀúÇ×

				default:
					// ½ºÅ³ÀÌ 20 ÀÌÇÏÀÇ »óÅÂ¶ó¸é ±×´ë·Î 0À¸·Î ¶³¾î ¶ß¸°´Ù.
					if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) {
						sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
					}
					else {
						// ´Ù¸¥ ½ºÅ³À» °Ë»öÇÑ´Ù.
						// ´Ù¸¥ ½ºÅ³À» °Ë»öÇÑ´Ù.
						iDownSkillSSN = 99999999;
						for (i = 0; i < DEF_MAXSKILLTYPE; i++)
						if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) && 
							(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
							// V1.22 ´Ù¿î ½ÃÅ³ ½ºÅ³Àº ÃÖ¼Ò 20 ÀÌÇÏ·Î´Â ¶³¾îÁú ¼ö ¾ø´Ù. 
							iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
							sDownSkillIndex = i;
						}
					}
					break;
				}
			}
			// ÇöÀç 1º¸´Ù Å« ½ºÅ³ Áß¿¡¼­ °¡Àå ÀÛÀº SSNÀ» °®´Â ½ºÅ³Àº sDownSkillIndex 
			
			if (sDownSkillIndex != -1) {
				
				if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
				 	 iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
				else iDownPoint = 1;

				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]+1] - 1;
				iRemainPoint -= iDownPoint; // v1.4
				
				// ¸¸¾à ³·¾ÆÁø ½ºÅ³ÀÌ ÇöÀç »ç¿ëÁßÀÎ ¹«±â¿Í °ü·ÃÀÌ ÀÖ´Ù¸é ¸íÁß·üÀ» ³·Ãß¾î¾ß ÇÑ´Ù. 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
					// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ ÇÏ¶ôÀÌ¾ú´Ù. ¸íÁß·üÀ» ³·Ãá´Ù. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], 0, 0);
			}
			else {
				return false;
			}
		}
		return true;
	}

	return false;
}


void CGame::OnKeyDown(WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
	case VK_F1:
		m_bF1pressed = true;
		break;
	case VK_F4:
		m_bF4pressed = true;
		break;
	case VK_F5:
		m_bF5pressed = true;
		break;
	case VK_F12:
		m_bF12pressed = true;
		break;
	}
}

void CGame::OnKeyUp(WPARAM wParam, LPARAM lParam)
{
 int i;
 
	switch (wParam) {
	case VK_F2:
		break;
	
	case VK_F1:
		m_bF1pressed = false;
		break;
	case VK_F4:
		m_bF4pressed = false;
		break;
	case VK_F5:
		m_bF5pressed = false;
		break;
	case VK_F12:
		m_bF12pressed = false;
		break;
	
	case VK_F6:
		if (m_bF1pressed ) {
			PutLogList("(!) Send server shutdown announcement1...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
				SendNotifyMsg(0, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, 0, 0, 0);
			}
		}
		break;

	case VK_F7:
		if (m_bF1pressed ) {
			PutLogList("(!) Send server shutdown announcement2...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
				SendNotifyMsg(0, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, 0, 0, 0);
			}
		}
		break;

	case VK_F9:
		if ((m_bF1pressed )) {
			PutLogList("(!!!) Resume Crusade Mode...");
			LocalStartCrusadeMode(0);
		}
		break;

	case VK_F11:
		if ((m_bF1pressed )) {
			PutLogList("(!!!) ManualEndCrusadeMode: side 0");
			ManualEndCrusadeMode(0);
		}
		break;

	#define VK_1 0x31
	case VK_1:
		if ((m_bF1pressed )) {
			GlobalUpdateConfigs(1);
		}
		break;

	#define VK_2 0x32
	case VK_2:
		if ((m_bF1pressed )) {
			GlobalUpdateConfigs(2);
		}
		break;

	#define VK_3 0x33
	case VK_3:
		if ((m_bF1pressed )) {
			GlobalUpdateConfigs(3);
		}
		break;

	#define VK_4 0x34
	case VK_4:
		if ((m_bF1pressed )) {
			GlobalUpdateConfigs(1);
		}
		break;

	/*#define VK_A 0x41 // a key 
	case VK_A:
		if ((m_bF1pressed )) {
			GlobalStartApocalypseMode();
		}
		break;*/
		
	/*#define VK_H 0x49 // H key 
	case VK_H:
		if ((m_bF1pressed )) {
			GlobalStartHeldenianMode();
		}
		break;*/

		//Crusade Testcode
	case VK_HOME:
		if ((m_bF1pressed )) {
			GlobalStartCrusadeMode();
		}
		break;

	case VK_INSERT:
		_GrandMagicLaunchMsgSend(1, 1);
		MeteorStrikeMsgHandler(1);
		break;

	case VK_DELETE:
		_GrandMagicLaunchMsgSend(1, 2);
		MeteorStrikeMsgHandler(2);
		break;
	}
}

int CGame::iGetFollowerNumber(short sOwnerH, char cOwnerType)
{
 int i, iTotal;

	iTotal = 0;

	for (i = 1; i < DEF_MAXNPCS; i++) 
	if ( (m_pNpcList[i] != 0) && (m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) ) {

		if ((m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) && (m_pNpcList[i]->m_cFollowOwnerType == cOwnerType))
			iTotal++;
	}

	return iTotal;
}

/*********************************************************************************************************************
**  bool CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH,				**
**									   char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3) **
**  description			:: initiates the delayed event process														**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: bool																						**
**********************************************************************************************************************/
bool CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH, char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
 int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if (m_pDelayEventList[i] == 0) {
		m_pDelayEventList[i] = new class CDelayEvent;
		m_pDelayEventList[i]->m_iDelayType	= iDelayType;
		m_pDelayEventList[i]->m_iEffectType = iEffectType;
		m_pDelayEventList[i]->m_cMapIndex	= cMapIndex;
		m_pDelayEventList[i]->m_dX			= dX;
		m_pDelayEventList[i]->m_dY			= dY;
		m_pDelayEventList[i]->m_iTargetH    = iTargetH;
		m_pDelayEventList[i]->m_cTargetType = cTargetType;
		m_pDelayEventList[i]->m_iV1         = iV1;
		m_pDelayEventList[i]->m_iV2         = iV2;
		m_pDelayEventList[i]->m_iV3         = iV3; 
		m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;
		return true;
	}
	return false;
}

void CGame::DelayEventProcessor()
{
 int i, iSkillNum, iResult;
 DWORD dwTime = timeGetTime();
 int iTemp;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if ((m_pDelayEventList[i] != 0) && (m_pDelayEventList[i]->m_dwTriggerTime < dwTime)) {

		// ÀÌº¥Æ®°¡ µ¿ÀÛÇÒ ½Ã°£ÀÌ µÆ´Ù. µ¿ÀÛÈÄ »èÁ¦µÈ´Ù.
		switch (m_pDelayEventList[i]->m_iDelayType) {

		case DEF_DELAYEVENTTYPE_ANCIENT_TABLET:
			if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x400000) != 0) {
				iTemp = 1;
			}
			else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x800000) != 0) {
				iTemp = 3;
			}
			else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x10000) != 0) {
				iTemp = 4;
			}

			SendNotifyMsg(0, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SLATE_STATUS, iTemp, 0, 0, 0);
			SetSlateFlag(m_pDelayEventList[i]->m_iTargetH, iTemp, false);
			break;

		case DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT:
			CalcMeteorStrikeEffectHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;

		case DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE:
			DoMeteorStrikeDamageHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_METEORSTRIKE:
			MeteorStrikeHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_USEITEM_SKILL:
			// ¾ÆÀÌÅÛ »ç¿ë¿¡ µû¸¥ °á°ú °è»ê, Åëº¸ 
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				iSkillNum = m_pDelayEventList[i]->m_iEffectType;
				
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH] == 0 ) break;
				// ±â¼ú »ç¿ëÀÌ ¹«È¿È­ µÇ¾ú´Ù¸é ¹«½Ã. 
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] == false ) break;
				// ±â¼ú »ç¿ë ½Ã°£ ID°¡ ´Þ¶óµµ ¹«½Ã v1.12
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] != m_pDelayEventList[i]->m_iV2) break;
				
				// ±â¼ú »ç¿ë »óÅÂ ÇØÁ¦ 
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] = false;
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] = 0;
				
				// ÀÌÁ¦ SkillÀÇ È¿°ú¿¡ µû¸¥ °è»êÀ» ÇÑ´Ù. 
				iResult = iCalculateUseSkillItemEffect(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cTargetType,
				 	                                   m_pDelayEventList[i]->m_iV1, iSkillNum, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);

				// ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
				SendNotifyMsg(0, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SKILLUSINGEND, iResult, 0, 0, 0);
				break;
			}
			break;
		
		case DEF_DELAYEVENTTYPE_DAMAGEOBJECT:
			break;

		case DEF_DELAYEVENTTYPE_MAGICRELEASE: 
			// Removes the aura after time
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[ m_pDelayEventList[i]->m_iTargetH ] == 0) break;
				
				SendNotifyMsg(0, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF, 
					          m_pDelayEventList[i]->m_iEffectType, m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ], 0, 0);
				
				m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = 0;
				
				// Inbitition casting 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INHIBITION)
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bInhibition = false;

				// Invisibility ȿ  
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
					SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);

				// Berserk ȿ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
					SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);

				// Haste
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_HASTE)
					SetHasteFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);

				// Confusion
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
					switch(m_pDelayEventList[i]->m_iV1){
						case 3: SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false); break;
						case 4: SetIllusionMovementFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false); break;
					}	

				// Protection Magic
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) {
					switch(m_pDelayEventList[i]->m_iV1){
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
							break;
						case 3:
						case 4:
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
							break;
					}
				}

				
				// polymorph ȿ  
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
				}

				// Ice ȿ  
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
					SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
				break;
			
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ] == 0) break;
				
				m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = 0;
				
				// Invisibility È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
					SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);

				// Berserk È¿°ú ÇØÁ¦
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
					SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);

				// polymorph È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
					m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
				}

				// Ice È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
					SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);
				
				// Illusion
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
					SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);

				// Protection Magic
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) {
					switch(m_pDelayEventList[i]->m_iV1){
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);
							break;
						case 3:
						case 4:
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);
							break;
					}
				}
				//	if (m_pDelayEventList[i]->m_iEffectType == /*notcoded*/)

				break;
			}
			break;
		}
		
		delete m_pDelayEventList[i];
		m_pDelayEventList[i] = 0;
	}
}
bool CGame::bRemoveFromDelayEventList(int iH, char cType, int iEffectType)
{
 int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if (m_pDelayEventList[i] != 0) {
		
		if (iEffectType == 0) {
			// Effect Á¾·ù¿¡ »ó°ü¾øÀÌ ¸ðµÎ »èÁ¦ 	
			if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) ) {
				delete m_pDelayEventList[i];
				m_pDelayEventList[i] = 0;
			}
		}
		else {
			// ÇØ´ç Effect¸¸ »èÁ¦.
			if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) &&
				 (m_pDelayEventList[i]->m_iEffectType == iEffectType) ) {
				delete m_pDelayEventList[i];
				m_pDelayEventList[i] = 0;
			}
		}
	}
	
	return true;
}

void CGame::SendObjectMotionRejectMsg(int iClientH)
{
 char  * cp, cData[30];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;

	m_pClientList[iClientH]->m_bIsMoveBlocked = true; // v2.171
	
	// ÀÌµ¿ÀÌ ºÒ°¡´ÉÇÏ´Ù. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
 	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_REJECT;
	
	cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX; 
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY; 
	cp += 2;
	
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, true, true);
		return;
	}
	return;
}

int CGame::_iGetTotalClients()
{
 int i, iTotal;

	iTotal = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != 0) iTotal++;

	return iTotal;
}

void CGame::DynamicObjectEffectProcessor()
{
 int i, ix, iy, iIndex;
 short sOwnerH, iDamage, sType;
 char  cOwnerType;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
	
	// 
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != 0) {
		switch (m_pDynamicObjectList[i]->m_sType) {

		case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
			// Æ÷ÀÌÁð Å¬¶ó¿ìµå
			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != 0) {
					// Poison Damage¸¦ ÀÔ´Â´Ù.
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled ) break;
						// v1.41 Áß¸³ÀÌ°í ÀüÅõ¸ðµå°¡ ¾Æ´Ï¸é ÇÇÇØ¸¦ ÀÔÁö ¾Ê´Â´Ù.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral ) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						// ÀÌ·± ½ÄÀ¸·Î ´ë¹ÌÁöÀÇ Å©±â¸¦ °áÁ¤
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(1,6);
						else iDamage = iDice(1,8);

						// New 17/05/2004 Changed
						if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// ¸¶ºñ »óÅÂ°¡ Ç®¸°´Ù.	
									// 1: Hold-Person 
									// 2: Paralize
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], 0, 0);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							// v1.42 Poison È¿°ú
							if ( (bCheckResistingMagicSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, 100) == false) &&
								 (m_pClientList[sOwnerH]->m_bIsPoisoned == false) ) {
								
								m_pClientList[sOwnerH]->m_bIsPoisoned  = true;
								m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
								m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
								// Áßµ¶µÇ¾úÀ½À» ¾Ë¸°´Ù. 
								SetPoisonFlag(sOwnerH, cOwnerType, true);// poison aura appears from dynamic objects
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sOwnerH]->m_iPoisonLevel, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						// ¸ó½ºÅÍÀÇ Áßµ¶È¿°ú´Â ¾ÆÁ÷ ±¸Çö ¾ÈµÊ
						if (m_pNpcList[sOwnerH] == 0) break;

						// ÀÌ·± ½ÄÀ¸·Î ´ë¹ÌÁöÀÇ Å©±â¸¦ °áÁ¤
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(1,6);
						else iDamage = iDice(1,8);

						// ÀüÀï¿ë ±¸Á¶¹°Áß ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ´Â ÇÊµå·ù ¸¶¹ý¿¡ ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40: // ESG
						case 41: // GMG
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							iDamage = 0;
							break;
						}
						
						// HP¿¡¼­ »«´Ù. Action Limit¿¡ µû¶ó Ã³¸®ÇÑ´Ù.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // ÀÏ¹Ý
						case 3: // ´õ¹Ì·ù
						case 5: // °ÇÃà¹° 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC°¡ »ç¸ÁÇß´Ù.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 Áßµ¶±¸¸§¿¡ Á×À¸¸é ¸¶Áö¸· ´ë¹ÌÁö°¡ 0. ¾ÆÀÌÅÛÀ» ½±°Ô ±¸ÇÏÁö ¸øÇÏ°Ô ÇÏ±â À§ÇÔ.
						}
						else {
							// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
							}
						
							// NPC¸¦ µµ¸Á°¡´Â ¸ðµå·Î ÀüÈ¯½ÃÅ²´Ù.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
						}
						break;
					}
				}
			}
			break;
						
		case DEF_DYNAMICOBJECT_ICESTORM:
			for (ix = m_pDynamicObjectList[i]->m_sX -2; ix <= m_pDynamicObjectList[i]->m_sX+2; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -2; iy <= m_pDynamicObjectList[i]->m_sY+2; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != 0) {
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled ) break;

						iDamage = iDice(3,3) + 5;

						if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {

									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {

									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], 0, 0);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1) == false) &&
								 (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
								
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ýÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
									                sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);

								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) break;
						
						iDamage = iDice(3,3) + 5;

						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40: // ESG
						case 41: // GMG
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							iDamage = 0;
							break;
						}
						
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0:
						case 3:
						case 5:
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC°¡ »ç¸ÁÇß´Ù.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 Å¸¼­ Á×À¸¸é ¸¶Áö¸· ´ë¹ÌÁö°¡ 0. ¾ÆÀÌÅÛÀ» ½±°Ô ±¸ÇÏÁö ¸øÇÏ°Ô ÇÏ±â À§ÇÔ.
						}
						else {
							// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
							}
						
							// NPC¸¦ µµ¸Á°¡´Â ¸ðµå·Î ÀüÈ¯½ÃÅ²´Ù.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

							// v1.42 Ice È¿°ú
							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1) == false) &&
								 (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
																
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ýÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
								                    sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
					   	break;
					}
				}

				// Á×ÀºÃ´ÇÏ°í ÀÖ´Â Ä³¸¯ÀÌ ÀÖ´Ù¸é
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					iDamage = iDice(3,2);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
							SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
						}
					}
				}

				// ±ÙÃ³¿¡ Fire Object°¡ ÀÖ´Ù¸é ¼ö¸íÀ» ÁÙÀÎ´Ù.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if (((sType == DEF_DYNAMICOBJECT_FIRE) || (sType == DEF_DYNAMICOBJECT_FIRE3)) && (m_pDynamicObjectList[iIndex] != 0)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		
		case DEF_DYNAMICOBJECT_FIRE3:
		case DEF_DYNAMICOBJECT_FIRE:
			// Fire-Wall·ùÀÇ Å¸´Â ºÒ²É
			if (m_pDynamicObjectList[i]->m_iCount == 1) {
				// ±ÙÃ³¿¡ Å¸´Â ¹°°ÇÀÌ ÀÖ´Ù¸é ¹øÁø´Ù. 
				CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
			}
			m_pDynamicObjectList[i]->m_iCount++;
			if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10; 


			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != 0) {
					// Fire Damage¸¦ ÀÔ´Â´Ù.
					switch (cOwnerType) {
					
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled ) break;
						// v1.41 Áß¸³ÀÌ°í ÀüÅõ¸ðµå°¡ ¾Æ´Ï¸é ÇÇÇØ¸¦ ÀÔÁö ¾Ê´Â´Ù.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral ) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						iDamage = iDice(1,6);
						// New 17/05/2004
						if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. Fire Field·Î´Â ÆÐ·²¶óÀÌÁî µÈ°Íµµ Ç®¸°´Ù. 	
									// 1: Hold-Person 
									// 2: Paralize	
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], 0, 0);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) break;
						
						iDamage = iDice(1,6);

						// ÀüÀï¿ë ±¸Á¶¹°Áß ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ´Â ÇÊµå·ù ¸¶¹ý¿¡ ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40: // ESG
						case 41: // GMG
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							iDamage = 0;
							break;
						}
												
						// HP¿¡¼­ »«´Ù. Action Limit¿¡ µû¶ó Ã³¸®ÇÑ´Ù.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // ÀÏ¹Ý
						case 3: // ´õ¹Ì·ù
						case 5: // °ÇÃà¹° 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC°¡ »ç¸ÁÇß´Ù.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 Å¸¼­ Á×À¸¸é ¸¶Áö¸· ´ë¹ÌÁö°¡ 0. ¾ÆÀÌÅÛÀ» ½±°Ô ±¸ÇÏÁö ¸øÇÏ°Ô ÇÏ±â À§ÇÔ.
						}
						else {
							// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
							}
						
							// NPC¸¦ µµ¸Á°¡´Â ¸ðµå·Î ÀüÈ¯½ÃÅ²´Ù.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
						}
					   	break;
					}
				}

				// Á×ÀºÃ´ÇÏ°í ÀÖ´Â Ä³¸¯ÀÌ ÀÖ´Ù¸é
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					iDamage = iDice(1,6);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
							SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
						}
					}
				}

				// ±ÙÃ³¿¡ Ice Object°¡ ÀÖ´Ù¸é ¼ö¸íÀ» ÁÙÀÎ´Ù.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if ((sType == DEF_DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != 0)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		}
	}
}

char _tmp_cCorpseX[] = {  0,  1, 1, 1, 0, -1, -1, -1, 0, 0, 0, 0};
char _tmp_cCorpseY[] = { -1, -1, 0, 1, 1,  1,  0, -1, 0, 0, 0};

void CGame::ClearSkillUsingStatus(int iClientH)
{
 int i;
 short tX, fX, tY, fY;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] ) {
		tX = m_pClientList[iClientH]->m_sX;
		tY = m_pClientList[iClientH]->m_sY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(tX, tY, 0) == false) {
			fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
			fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX, fY, 0) == false) {
				m_pClientList[iClientH]->m_cDir = iDice(1,8);
				fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
				fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX , fY, 0) == false) {
					return;
				}
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_DAMAGEMOVE, m_pClientList[iClientH]->m_cDir, 0, 0, 0);
		}
	}
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_bSkillUsingStatus[i] = false;
		m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = 0;
	}
	
	if (m_pClientList[iClientH]->m_iAllocatedFish != 0) {
		if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != 0) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		m_pClientList[iClientH]->m_iAllocatedFish = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FISHCANCELED, 0, 0, 0, 0);
	}

}

int CGame::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
 class CItem * pItem;
 char  cItemName[21];
 short lX, lY;
 int   iResult, iFish;

	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iOwnerH] == 0) return 0;
		if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pClientList[iOwnerH]->m_sX;
		lY = m_pClientList[iOwnerH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iOwnerH] == 0) return 0;
		if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pNpcList[iOwnerH]->m_sX;
		lY = m_pNpcList[iOwnerH]->m_sY;
		break;
	}

	// ½ºÅ³ »ç¿ë ¿©ºÎ ÁÖ»çÀ§¸¦ ±¼¸°´Ù. 
	if (cOwnerSkill == 0) return 0;
	
	// ½ºÅ³ÀÌ 100ÀÌ¶ó°í ÇØµµ °¡²û ³¬½Ã¸¦ ½ÇÆÐÇÏ°Ô ÇÏ±â À§ÇØ¼­ 1D105 
	iResult = iDice(1, 105);
	if (cOwnerSkill <= iResult)	return 0;  // ½ÇÆÐ´Ù.

	// ¶¥¿¡¼­´Â ³¬½Ã°¡ ºÒ°¡´É 
	if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == false) return 0;

	// ¼º°øÇßÀ¸¹Ç·Î ½ºÅ³ Ä«¿îÆ®¸¦ ¿Ã¸°´Ù.
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(iOwnerH, iSkillNum, 1);

	switch (m_pSkillConfigList[iSkillNum]->m_sType) {
	case DEF_SKILLEFFECTTYPE_TAMING:
		// ±æµéÀÌ±â ±â¼ú: dX, dY ºÎ±ÙÀÇ ¸ó½ºÅÍ¸¦ ±æµéÀÎ´Ù.
		_TamingHandler(iOwnerH, iSkillNum, cMapIndex, dX, dY);
		break;
	
	case DEF_SKILLEFFECTTYPE_GET: 
		// ¾ÆÀÌÅÛÀ» ¾ò´Â ±â¼úÀÌ¾ú´Ù. 
		ZeroMemory(cItemName, sizeof(cItemName));
		switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
		case 1:
			// ±¤¹° 
			wsprintf(cItemName, "Meat");
			break;

		case 2:
			// ¹°°í±â 
			// ³¬½ÃÀÇ °æ¿ì À§Ä¡¿Í ½Ã°£´ëÀÇ ¿µÇâ¿¡ µû¶ó ¶Ç ¼º°ø·üÀÌ ´Þ¶óÁø´Ù. 
			//if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == false) return 0; 
			
			// ±ÙÃ³¿¡ ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ® ¹°°í±â°¡ Á¸ÀçÇÑ´Ù¸é º»°Ý³¬½Ã ¸ðµå·Î µé¾î°£´Ù.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
		   		if (iFish == 0) wsprintf(cItemName, "Fish");
			}
			else wsprintf(cItemName, "Fish");
			break;
		}

		if (strlen(cItemName) != 0) {
			
			// ³¬½Ã¿¡ ¼º°øÇß´Ù¸é ¸Þ½ÃÁö¸¦ Àü¼Û.
			if (memcmp(cItemName, "Fish", 6) == 0) {
				SendNotifyMsg(0, iOwnerH, DEF_NOTIFY_FISHSUCCESS, 0, 0, 0, 0);
				// v1.41 ¾à°£ÀÇ °æÇèÄ¡ »ó½Â 
				m_pClientList[iOwnerH]->m_iExpStock += iDice(1,2);
			}
			
			pItem = new class CItem;
			if (pItem == 0) return 0;
			if (_bInitItemAttr(pItem, cItemName) ) {
				// ¾ÆÀÌÅÛÀ» ³õ´Â´Ù. 
				m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);
		
				// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, cMapIndex,
					lX, lY, pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4
			}
		}
		break;
	}

	return 1;
}



void CGame::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{
 char  cOwnerType;
 short sAttackerWeapon, sOwnerH;
 int   iResult, iPlayerSkillLevel;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((iV1 < 0) || (iV1 >= DEF_MAXSKILLTYPE)) return;
	if (m_pSkillConfigList[iV1]	== 0) return;
	// ÀÌ¹Ì ±â¼úÀ» »ç¿ëÁßÀÌ¶óµµ ¸®ÅÏ.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] ) return;

	// v1.3 !!1ÇØÅ· °É·¯³»±â¿ë! 
	/*
	if (iV1 != 19) {
		m_pClientList[iClientH]->m_iAbuseCount++;
		if ((m_pClientList[iClientH]->m_iAbuseCount % 30) == 0) {
			wsprintf(G_cTxt, "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) Skill(%d) Tries(%d)",m_pClientList[iClientH]->m_cCharName, 
				                                                       iV1, m_pClientList[iClientH]->m_iAbuseCount);
			PutLogFileList(G_cTxt);
		}
	}
	*/

	// ÇÃ·¹ÀÌ¾îÀÇ ±â¼ú¼öÁØ¿¡ µû¶ó ¼º°ø¿©ºÎ¸¦ °è»êÇÑ´Ù. 
	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		// ½ÇÆÐ´Ù. 
		// ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
		return;
	}

	// iV1ÀÌ ±â¼ú ¹øÈ£ 
	switch (m_pSkillConfigList[iV1]->m_sType) {
	case DEF_SKILLEFFECTTYPE_PRETEND:
		switch (m_pSkillConfigList[iV1]->m_sValue1) {
		case 1:
			// Á×ÀºÃ´ÇÏ±â ±â¼úÀÌ´Ù.	
			
			// v1.44 »çÅõÀåÀÌ¸é Á×ÀºÃ´ÇÏ±â ¸øÇÑ´Ù.
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone ) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
				return;
			}
			
			//¸¸¾à ¹Ù´Ú¿¡ ½ÃÃ¼°¡ ÀÖ´Ù¸é Á×ÀºÃ´ ÇÏ±â¸¦ ÇÒ ¼ö ¾ø´Ù. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (sOwnerH != 0) {
				// Á×ÀºÃ´ ÇÏ±â¸¦ ÇÒ ÀÚ¸®¿¡ ½ÃÃ¼°¡ ÀÖ¾î ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
				return;
			}
			
			// Á×ÀºÃ´ ÇÏ°íÀÚ ÇÏ´Â ÁÖº¯¿¡ ¹°Ã¼°¡ ÀÖ¾îµµ ÇÒ ¼ö ¾ø´Ù. 
			iResult = 0;
			if (m_pClientList[iClientH]->m_iAdminUserLevel <= 0) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
			}

			if (iResult != 0) {
				// Á×ÀºÃ´ ÇÏ±â¸¦ ÇÒ ÀÚ¸®¿¡ ½ÃÃ¼°¡ ÀÖ¾î ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
				return;
			}

			// ½ºÅ³ Ä«¿îÆ® ¿Ã¸°´Ù. <-- ³»ºÎ¿¡¼­ Ä«¿îÆÃÀ» ÇØ¾ß ¾û¶×ÇÑ ½ºÅ³ÀÌ ¿À¸£´Â °æ¿ì°¡ ¾ø´Ù. 
			CalculateSSN_SkillIndex(iClientH, iV1, 1);
			
			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Á×´Â µ¿ÀÛ Àü¼Û.
			sAttackerWeapon = 1;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, sAttackerWeapon, 0);
			// Á¤»ó À§Ä¡¿¡¼­ Áö¿î´Ù.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(14, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			// Á×Àº À§Ä¡ Ç¥½Ã¸¦ ÇÑ´Ù.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			break;
		}
		break;

	}

	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = true;
}

void CGame::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, char * pItemName)
{
 char cItemCategory,cItemName[21];
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 bool   bNeutral;
 DWORD  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;
 CItem * m_pGold;

	// »ç¿ëÀÚÀÇ ¾ÆÀÌÅÛ ÆÈ±â ¿ä±¸.
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;

	iCalcTotalWeight(iClientH);

	m_pGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(m_pGold, cItemName);

	// v1.42
	bNeutral = false;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = true;
	// v2.13 ¼ºÈÄ´Ï ¼öÁ¤ ¹°°ÇÀ» ¾îµð¼­³ª ÆÈ°Ô ¼öÁ¤ÇÏ¿©¼­ ÆÈ¶§´Â NPC ±¸ºÐÀÌ ÇÊ¿ä¾ø´Ù. 
	// ´Ü Ä«Å×°í¸®¸¦ ±âÁØÀ¸·Î ¾ÆÀÌÅÛ °¡°ÝÀ» °áÁ¤ÇÑ´Ù.
	switch (cSellToWhom) {
	case 15: 		// »óÁ¡ ¾ÆÁÜ¸¶ 
	case 24:        // ´ëÀå°£ ÁÖÀÎ 
		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
		// 12-22 ¼ºÈÄ´Ï ¼öÁ¤ ¾îµð¼­µç ÆÈ¼ö ÀÖ°Ô ¼öÁ¤ 
		// »óÁ¡¾ÆÀÌÅÛ 
		if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {

			// ÀûÇÕÇÏ´Ù. ¹«Á¶°Ç ¹Ý°ª 
			iPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2)*iNum;
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;


			//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
			if (bNeutral ) iPrice = iPrice/2;
			if (iPrice <= 0)    iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;

			if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > (DWORD)_iCalcMaxLoad(iClientH)) {
				// v2.12 ÆÈ °æ¿ì ¹«°Ô°¡ ÃÊ°úµÇ¾î¼­ ÆÈ ¼ö ¾ø´Ù.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else SendNotifyMsg(0, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
		}
		// ´ëÀå°£ ¾ÆÀÌÅÛ
		else if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
			// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ °¡°ÝÀ» ¸Å±ä´Ù.
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			if (sRemainLife == 0) {
				// °íÀå³­ ¾ÆÀÌÅÛÀº ÆÈ ¼ö ¾ø´Ù
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 2, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else {
				d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
				d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 

				iPrice = (int)d3;
				iPrice = iPrice*iNum;

				dwAddPrice1 = 0;
				dwAddPrice2 = 0;
				// ¾ÆÀÌÅÛ Æ¯¼ºÄ¡¿¡ µû¸¥ °¡°Ý »ó½Â 
	if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != 0) {
		dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
		dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;

	switch (dwSWEType) {
		case 6: dwMul1 = 2; break;  // °¡º­¿î 
		case 8: dwMul1 = 2; break;  // °­È­µÈ
		case 5: dwMul1 = 3; break;  // ¹ÎÃ¸ÀÇ
		case 1: dwMul1 = 4; break;  // ÇÊ»ìÀÇ 
		case 7: dwMul1 = 5; break;  // ¿¹¸®ÇÑ
		case 2: dwMul1 = 6; break;  // Áßµ¶ÀÇ
		case 3: dwMul1 = 15; break; // Á¤ÀÇÀÇ 
		case 9: dwMul1 = 20; break; // °í´ë¹®¸í 
		default: dwMul1 = 1; break;
	}

	d1 = (double)iPrice*dwMul1;
	switch (dwSWEValue) {
		case 1: d2 = 10.0f; break;
		case 2: d2 = 20.0f; break;
		case 3: d2 = 30.0f; break;
		case 4: d2 = 35.0f; break;
		case 5: d2 = 40.0f; break;
		case 6: d2 = 50.0f; break;
		case 7: d2 = 100.0f; break;
		case 8: d2 = 200.0f; break;
		case 9: d2 = 300.0f; break;
		case 10: d2 = 400.0f; break;
		case 11: d2 = 500.0f; break;
		case 12: d2 = 700.0f; break;
		case 13: d2 = 900.0f; break;
		default: d2 = 0.0f; break;
	}
	d3 = d1*(d2/100.0f);

	dwAddPrice1 = (int)(d1 + d3);
	}

				// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Sub È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°Ý¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
	if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != 0) {
		dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
		dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;

	switch (dwSWEType) {
		case 1: 
		case 12: dwMul2 = 2; break;

		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7: dwMul2 = 4; break;

		case 8:
		case 9:
		case 10:
		case 11: dwMul2 = 6; break;
	}

	d1 = (double)iPrice*dwMul2;
	switch (dwSWEValue) {
		case 1: d2 = 10.0f; break;
		case 2: d2 = 20.0f; break;
		case 3: d2 = 30.0f; break;
		case 4: d2 = 35.0f; break;
		case 5: d2 = 40.0f; break;
		case 6: d2 = 50.0f; break;
		case 7: d2 = 100.0f; break;
		case 8: d2 = 200.0f; break;
		case 9: d2 = 300.0f; break;
		case 10: d2 = 400.0f; break;
		case 11: d2 = 500.0f; break;
		case 12: d2 = 700.0f; break;
		case 13: d2 = 900.0f; break;
		default: d2 = 0.0f; break;
	}
	d3 = d1*(d2/100.0f);

	dwAddPrice2 = (int)(d1 + d3);
}

				// v2.03 925 Æ¯¼ö ¾ÆÀÌÅÛ °¡°Ý °¡ÁßÄ¡¸¦ 77%¼öÁØÀ¸·Î ´Ù¿î 
				iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

				//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
				if (bNeutral ) iPrice = iPrice/2;
				if (iPrice <= 0)    iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;

				if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > (DWORD)_iCalcMaxLoad(iClientH)) {
					// v2.12 ÆÈ °æ¿ì ¹«°Ô°¡ ÃÊ°úµÇ¾î¼­ ÆÈ ¼ö ¾ø´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
				}
				else SendNotifyMsg(0, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
			}
		}
		else SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 1, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;


	default:
		break;
	}
	if (m_pGold != 0) delete m_pGold;
}

void CGame::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, char * pString)
{
 class CItem * pItemGold;
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 char   * cp, cItemName[21], cData[120], cItemCategory;
 DWORD  * dwp, dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
 WORD   * wp;
 int    iEraseReq, iRet;
 short * sp;
 bool   bNeutral;


	// ¾ÆÀÌÅÛÀ» ÆÈ°Ú´Ù´Â °ÍÀÌ °áÁ¤µÇ¾ú´Ù.
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	iCalcTotalWeight(iClientH);
	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// v1.42
	bNeutral = false;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = true;

	iPrice = 0;
	// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó °¡°Ý °è»ê.
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// ¹«±â·ù´Ù
  		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ °¡°ÝÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		
		if (sRemainLife <= 0) {
			// ¸Á°¡Áø ¾ÆÀÌÅÛÀº ÆÈÁö ¸øÇÑ´Ù.	
			return;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 
			
			iPrice = (short)d3;
			iPrice = iPrice*iNum;

			dwAddPrice1 = 0;
			dwAddPrice2 = 0;
			// ¾ÆÀÌÅÛ Æ¯¼ºÄ¡¿¡ µû¸¥ °¡°Ý »ó½Â 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != 0) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 4-ÀúÁÖÀÇ 
				// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ
				switch (dwSWEType) {
				case 6: dwMul1 = 2; break;  // °¡º­¿î 
				case 8: dwMul1 = 2; break;  // °­È­µÈ
				case 5: dwMul1 = 3; break;  // ¹ÎÃ¸ÀÇ
				case 1: dwMul1 = 4; break;  // ÇÊ»ìÀÇ 
				case 7: dwMul1 = 5; break;  // ¿¹¸®ÇÑ
				case 2: dwMul1 = 6; break;  // Áßµ¶ÀÇ
				case 3: dwMul1 = 15; break; // Á¤ÀÇÀÇ 
				case 9: dwMul1 = 20; break; // °í´ë¹®¸í 
				default: dwMul1 = 1; break;
				}

				d1 = (double)iPrice*dwMul1;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice1 = (int)(d1 + d3);
			}

			// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Sub È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°Ý¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != 0) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				//Ãß°¡ µ¶¼ºÀúÇ×(1), Ãß°¡ ¸íÁß°ª(2), Ãß°¡ ¹æ¾î°ª(3), HP È¸º¹·® Ãß°¡(4), SP È¸º¹·® Ãß°¡(5)
				//MP È¸º¹·® Ãß°¡(6), Ãß°¡ ¸¶¹ýÀúÇ×(7), ¹°¸® ´ë¹ÌÁö Èí¼ö(8), ¸¶¹ý ´ë¹ÌÁö Èí¼ö(9)
				//¿¬Å¸ ´ë¹ÌÁö Ãß°¡(10), ´õ ¸¹Àº °æÇèÄ¡(11), ´õ¸¹Àº Gold(12)
				switch (dwSWEType) {
				case 1: 
				case 12: dwMul2 = 2; break;
					
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7: dwMul2 = 4; break;
					
				case 8:
				case 9:
				case 10:
				case 11: dwMul2 = 6; break;
				}
					
				d1 = (double)iPrice*dwMul2;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice2 = (int)(d1 + d3);
			}

			iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

			//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
			if (bNeutral ) iPrice = iPrice/2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000; // New 06/05/2004

			// ¾ÆÀÌÅÛÀ» ÆÈ¾Ò´Ù´Â ¸Þ½ÃÁö Àü¼Û (´ÙÀÌ¾ó·Î±× ¹Ú½º ºñÈ°¼ºÈ­¿ë)
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, 0, 0, 0);

			_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]) ;

			// ÆÈ ¾ÆÀÌÅÛÀ» »èÁ¦ 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
				// ¼ö·® °³³äÀÌ ÀÖ´Ù¸é °¹¼ö¸¦ ÁÙÀÎ´Ù.
				// v1.41 !!!
				SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
			}
			else ItemDepleteHandler(iClientH, cItemID, false);
		}
	}
	else 
	if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {
		// ½ÄÇ°, ÀâÈ­µîÀÇ ¹Ý°ª¹°°Çµé 
		iPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice/2; 
		iPrice = iPrice*iNum;

		//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
		if (bNeutral ) iPrice = iPrice/2;
		if (iPrice <= 0) iPrice = 1;
		if (iPrice > 1000000) iPrice = 1000000; // New 06/05/2004

		// ¾ÆÀÌÅÛÀ» ÆÈ¾Ò´Ù´Â ¸Þ½ÃÁö Àü¼Û (´ÙÀÌ¾ó·Î±× ¹Ú½º ºñÈ°¼ºÈ­¿ë)
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, 0, 0, 0);

		_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]) ;

		// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó ÀûÀýÇÑ Ã³¸®¸¦ ÇÑ´Ù.
		if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			// ¼ö·® °³³äÀÌ ÀÖ´Ù¸é °¹¼ö¸¦ ÁÙÀÎ´Ù.
			// v1.41 !!!
			SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
		}
		else ItemDepleteHandler(iClientH, cItemID, false);
	}

	// Gold¸¦ Áõ°¡½ÃÅ²´Ù. ¸¸¾à ÆÇ °¡°ÝÀÌ 0 È¤Àº ¸¶ÀÌ³Ê½ºÀÌ¸é ±ÝÀ» ÁÖÁö ¾Ê´Â´Ù.
	if (iPrice <= 0) return;

	pItemGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItemGold, cItemName);
	
	pItemGold->m_dwCount = iPrice;
	
	if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq) ) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1°³ È¹µæÇß´Ù. <- ¿©±â¼­ 1°³¶õ Ä«¿îÆ®¸¦ ¸»ÇÏ´Â °ÍÀÌ ¾Æ´Ï´Ù
		*cp = 1;
		cp++;
		
		memcpy(cp, pItemGold->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItemGold->m_dwCount;
		cp += 4;
		
		*cp = pItemGold->m_cItemType;
		cp++;
		
		*cp = pItemGold->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sLevelLimit;
		cp += 2;
		
		*cp = pItemGold->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSpriteFrame;
		cp += 2;

		*cp = pItemGold->m_cItemColor;
		cp++;

		*cp = (char)pItemGold->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItemGold->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItemGold->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		cp++;
		*/
		
		if (iEraseReq == 1)
			delete pItemGold;
		
		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		
		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, true, true);
			break;
		}
	}
	else {
		// Áß·® ÃÊ°úµîÀÇ ¹®Á¦·Î Ãß°¡ ½ÇÆÐ.
		// ¹ÞÁö ¸øÇßÀ¸¹Ç·Î ¹Ù´Ú¿¡ ¶³¾îÁø´Ù. 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, pItemGold);
		
		// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItemGold->m_sIDnum, 0, pItemGold->m_cItemColor, pItemGold->m_dwAttribute); // v1.4 color

		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);
		
		// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, true, true);
			return;
		}
	}
}

void CGame::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, char * pString)
{
 char cItemCategory;
 short sRemainLife, sPrice;
 double d1, d2, d3;

	// ¾ÆÀÌÅÛÀ» °íÄ¡°Ú´Ù´Â ¿ä±¸.
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó °¡°Ý °è»ê.
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// ¹«±â·ù´Ù
  		
		// ¸¸¾à ¹«±â¸¦ ´ëÀå°£ ÁÖÀÎÀÌ ¾Æ´Ñ ÀÌ¿¡°Ô °íÃÄ´Þ¶ó°í ÇÑ´Ù¸é ÇÒ ¼ö ¾ø´Ù. 
		if (cRepairWhom != 24) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ ¼ö¸® ºñ¿ëÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// ¿ÏÀüÈ÷ ¸Á°¡Áø °ÍÀÌ¶ó¸é ¿ø·¡°¡°ÝÀÇ Àý¹ÝÀÌ µç´Ù. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else if ( ((cItemCategory >= 43) && (cItemCategory <= 50)) || ((cItemCategory >= 11) && (cItemCategory <= 12))) {
		// ³¬½Ã´ë, °î±ªÀÌ µî°ú °°Àº ºñ¹«±â·ù ¼ö¸®°¡´É ¾ÆÀÌÅÛ. ¿Ê, ºÎÃ÷·ù
		
		// ¸¸¾à »óÁ¡ ÁÖÀÎÀÌ ¾Æ´Ñ ÀÌ¿¡°Ô °íÃÄ´Þ¶ó°í ÇÑ´Ù¸é ÇÒ ¼ö ¾ø´Ù. 
		if (cRepairWhom != 15) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ ¼ö¸® ºñ¿ëÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// ¿ÏÀüÈ÷ ¸Á°¡Áø °ÍÀÌ¶ó¸é ¿ø·¡°¡°ÝÀÇ Àý¹ÝÀÌ µç´Ù. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else {
		// °íÄ¥¼ö ¾ø´Â ¾ÆÀÌÅÛÀÌ´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 1, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
}

void CGame::ReqRepairItemCofirmHandler(int iClientH, char cItemID, char * pString)
{
 short    sRemainLife, sPrice;
 char   * cp, cItemCategory, cData[120];
 double   d1, d2, d3;
 DWORD  * dwp, dwGoldCount;
 WORD   * wp;
 int      iRet, iGoldWeight;

	// ¾ÆÀÌÅÛÀ» ¼ö¸®ÇÏ°Ú´Ù´Â °ÍÀÌ °áÁ¤µÇ¾ú´Ù.
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	//testcode
	//PutLogList("Repair!");

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó °¡°Ý °è»ê.
  	if ( ((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) || 
		 ((cItemCategory >= 11) && (cItemCategory <= 12))) {
		// ¹«±â·ù È¤Àº ³¬½Ã´ë, °î±ªÀÌ¿Í °°Àº ¾ÆÀÌÅÛ, ¿Ê, ½Å¹ß 

  		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ ¼ö¸® ºñ¿ëÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// ¿ÏÀüÈ÷ ¸Á°¡Áø °ÍÀÌ¶ó¸é ¿ø·¡°¡°ÝÀÇ Àý¹ÝÀÌ µç´Ù. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)abs(sRemainLife);
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)abs(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan);
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}
		
		// sPrice¸¸Å­ÀÇ µ·ÀÌ µÇ¸é °íÄ¥ ¼ö ÀÖÀ¸³ª ºÎÁ·ÇÏ¸é °íÄ¥ ¼ö ¾ø´Ù. 
		dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
		if ( dwGoldCount < (DWORD)sPrice ) {
			// ÇÃ·¹ÀÌ¾î°¡ °®°íÀÖ´Â Gold°¡ ¾ÆÀÌÅÛ ¼ö¸® ºñ¿ë¿¡ ºñÇØ Àû´Ù. °íÄ¥ ¼ö ¾øÀ½.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
			cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp  = cItemID;
			cp++;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, true, true);
				return;
			}
			return;
		}
		else {
			//µ·ÀÌ ÃæºÐÇÏ´Ù. °íÄ¥ ¼ö ÀÖ´Ù. 
			
			// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀ» ´Ã¸®°í Åëº¸ÇÑ´Ù. !BUG POINT À§Ä¡°¡ Áß¿äÇÏ´Ù. ¸ÕÀú ¼ö¸íÀ» ´Ã¸®°í µ·ÀÇ Ä«¿îÆ®¸¦ ³·Ãá´Ù.
			m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
		 	SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMREPAIRED, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan, 0, 0);
			
			iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - sPrice );
			
			// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
			iCalcTotalWeight(iClientH);

			//v1.4 ¸¶À»ÀÇ ÀÚ±Ý¿¡ ´õÇÑ´Ù. 
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += sPrice;
		}
	}
	else {
		// °íÄ¥ ÇÊ¿ä°¡ ¾ø´Â ¾ÆÀÌÅÛ 
		// ÇØÅ·ÀÌ³ª ¹ö±×¿¡ ÀÇÇÑ °ÍÀÏµí 
	}
}

int CGame::iCalcTotalWeight(int iClientH)
{
 int i, iWeight;
 short sItemIndex;
	
	if (m_pClientList[iClientH] == 0) return 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	// Âø¿ëÇÏÁö ¾Ê¾Æµµ È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ È¿°ú. ¼ÒÁöÇÏ°í ÀÖ¾îµµ È¿°ú°¡ ÀÖ±â ¶§¹®¿¡ ¿©±â¼­ °Ë»ç.
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				// ¼ö¸íÀÌ ÀÖ¾î¾ß È¿°ú°¡ ÀÖ´Ù.
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}

	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
		
		iWeight += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
	}

	m_pClientList[iClientH]->m_iCurWeightLoad = iWeight;

	return iWeight;	
}

void CGame::CheckAndNotifyPlayerConnection(int iClientH, char * pMsg, DWORD dwSize)
{
 char   seps[] = "= \t\n";
 char   * token, * cp, cName[11], cBuff[256], cPlayerLocation[120];
 class  CStrTok * pStrTok;
 int i;
 WORD * wp;

	if (m_pClientList[iClientH] == 0) return;
	if (dwSize <= 0) return;

	ZeroMemory(cPlayerLocation,sizeof(cPlayerLocation));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == 0) {
		delete pStrTok;
		return;
	}

	if (strlen(token) > 10) 
		 memcpy(cName, token, 10);	
	else memcpy(cName, token, strlen(token));

	// cNameÀÇ ÀÌ¸§À» °¡Áø ÇÃ·¹ÀÌ¾î°¡ Á¢¼ÓÁßÀÎÁö Ã£´Â´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != 0) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) {
		// °°Àº ÀÌ¸§À» °¡Áø Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. 
		if(m_pClientList[iClientH]->m_iAdminUserLevel > 0){ // GM's get more info
			cp = (char *)cPlayerLocation;

			memcpy(cp,m_pClientList[i]->m_cMapName,10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_sX;
			cp += 2;

			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_sY;
			cp += 2;
		}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERONGAME, 0, 0, 0, m_pClientList[i]->m_cCharName,0,0,0,0,0,0,cPlayerLocation);

		delete pStrTok;
		return;
	}

	/*ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, cName, 10);
	cp += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;

	bStockMsgToGateServer(cBuff, 25);*/

	delete pStrTok;
}



void CGame::ToggleWhisperPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 int i;
 char *cp;
 WORD *wp;

	if (m_pClientList[iClientH] == 0) return;
	if (dwMsgSize <= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token == 0) {
		// ±Ó¼Ó¸» »ó´ë°¡ ÁöÁ¤µÇÁö ¾Ê¾Ò´Ù. ±Ó¼Ó¸» ¸ðµå¸¦ ÇØÁ¦ÇÑ´Ù. 
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
		ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
		m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = false;
		// ±Ó¼Ó¸» »óÅÂ°¡ ÇØÁ¦µÇ¾úÀ½À» Åëº¸. 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_WHISPERMODEOFF, 0, 0, 0, cName);
	}
	else {
		if (strlen(token) > 10)	
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
				// °°Àº ÀÌ¸§À» °¡Áø ÇÃ·¹ÀÌ¾î¸¦ Ã£¾Ò´Ù. 
				// ÀÚ±â ÀÚ½ÅÀÌ¶ó¸é ÇÒ´çÇÏÁö ¾Ê´Â´Ù.
				if (i == iClientH) {
					delete pStrTok;
					return;
				}
				//ÀÎµ¦½º¸¦ ÇÒ´ç 
				m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
				ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
				strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
		   		break;
			}

		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1) {
			/*ZeroMemory(cBuff, sizeof(cBuff));
			cp = (char *)cBuff;
			*cp = GSM_REQUEST_FINDCHARACTER;
			cp++;

			wp = (WORD *)cp;
			*wp = m_wServerID_GSS;
			cp += 2;

			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;

			memcpy(cp, cName, 10);
			cp += 10;

			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			bStockMsgToGateServer(cBuff, 25);*/

			ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
			strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
			m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = true;
		}
		else{
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_WHISPERMODEON, 0, 0, 0, m_pClientList[iClientH]->m_cWhisperPlayerName);
		}
	}
 
	delete pStrTok;
}


void CGame::SetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char cTemp[256];
 int i;


	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize - 7) <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	memcpy(cTemp, (pMsg + 7), dwMsgSize - 7);
	
	// °ø¹é¶õÀ» ¾ð´õ¹Ù·Î ¹Ù²Û´Ù. 
	for (i = 0; i < 256; i++)
		if (cTemp[i] == ' ') cTemp[i] = '_';

	// ¿¡·¯ ¹æÁö ÄÚµå 
	cTemp[255] = 0;

	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
	strcpy(m_pClientList[iClientH]->m_cProfile, cTemp);
}

void CGame::GetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256], cBuff2[500];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != 0) {
		// tokenÀÌ °ð ÇÁ·ÎÇÊÀ» ¾ò°íÀÚ ÇÏ´Â »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
		
			ZeroMemory(cBuff2, sizeof(cBuff2));
			wsprintf(cBuff2, "%s Profile: %s", cName, m_pClientList[i]->m_cProfile);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERPROFILE, 0, 0, 0, cBuff2);

			delete pStrTok;
			return;
		}
		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cName);
	}

	delete pStrTok;
	return;
}

void CGame::___RestorePlayerCharacteristics(int iClientH)
{
	int iStr, iDex, iInt, iVit, iMag, iCharisma;
	int iOriginalPoint, iCurPoint, iVerifyPoint, iToBeRestoredPoint;
	int iMax, iA, iB;
	bool bFlag;
	char cTxt[120];
	return;
		if (m_pClientList[iClientH] == 0) return;

	// ¸ÕÀú °ªÀ» ¹é¾÷ÇÑ´Ù. 
	iStr = m_pClientList[iClientH]->m_iStr;
	iDex = m_pClientList[iClientH]->m_iDex;
	iInt = m_pClientList[iClientH]->m_iInt;
	iVit = m_pClientList[iClientH]->m_iVit;
	iMag = m_pClientList[iClientH]->m_iMag;
	iCharisma = m_pClientList[iClientH]->m_iCharisma;


	iCurPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
		m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
		m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	iOriginalPoint = (m_pClientList[iClientH]->m_iLevel - 1)*3 + 70;

	iToBeRestoredPoint = iOriginalPoint - iCurPoint;

	// º¹±¸ÇÒ ÇÊ¿ä°¡ ¾ø´Ù¸é ±ÍÈ¯.
	if (iToBeRestoredPoint == 0) return;

	if (iToBeRestoredPoint > 0) {
		// ÀÌÁ¦ iToBeRestoredPoint ¸¸Å­ÀÇ Æ÷ÀÎÆ®¸¦ º¹±¸ÇÑ´Ù. 
		// ¸ÕÀú 10 ÀÌÇÏÀÇ Æ÷ÀÎÆ®°¡ ÀÖ´Ù¸é ¿ì¼±ÀûÀ¸·Î Ã¤¿î´Ù. 
		while (1) {
			bFlag = false;

			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < 10)) {
				m_pClientList[iClientH]->m_iStr++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < 10)) {
				m_pClientList[iClientH]->m_iMag++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < 10)) {
				m_pClientList[iClientH]->m_iInt++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < 10)) {
				m_pClientList[iClientH]->m_iDex++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iVit < 10)) {
				m_pClientList[iClientH]->m_iVit++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iCharisma < 10)) {
				m_pClientList[iClientH]->m_iCharisma++;
				iToBeRestoredPoint--;
				bFlag = true;
			}

			if (bFlag == false)          break;
			if (iToBeRestoredPoint <= 0) break; 
		}

		// ¸Ç¼Õ °ÝÅõ ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, StrÀÌ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[5];

		if (m_pClientList[iClientH]->m_iStr < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iStr == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// ¹«±â »ç¿ë ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, Dex°¡ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[7];
		iB = m_pClientList[iClientH]->m_cSkillMastery[8];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;
		iA = m_pClientList[iClientH]->m_cSkillMastery[9];
		if (iA > iMax) iMax = iA;
		iA = m_pClientList[iClientH]->m_cSkillMastery[6];
		if (iA > iMax) iMax = iA;


		if (m_pClientList[iClientH]->m_iDex < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iDex == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// Á×ÀºÃ´ÇÏ±â ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, IntÀÌ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[19];

		if (m_pClientList[iClientH]->m_iInt < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iInt == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// ¸¶¹ý ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, MagÀÌ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[3];
		iB = m_pClientList[iClientH]->m_cSkillMastery[4];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;

		if (m_pClientList[iClientH]->m_iMag < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iMag == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// ³²Àº Æ÷ÀÎÆ®¸¦ ·£´ýÇÏ°Ô ¿Ã¸°´Ù.
		while (iToBeRestoredPoint != 0) {
			switch (iDice(1,6)) {
			case 1:
				if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}
				break;
			case 2:
				if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iVit++;
					iToBeRestoredPoint--;
				}
				break;
			case 3:
				if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}
				break;
			case 4:
				if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}
				break;
			case 5:
				if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}
				break;
			case 6:
				if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iCharisma++;
					iToBeRestoredPoint--;
				}
				break;
			}
		}

		// º¹±¸°¡ ¼º°øÀûÀ¸·Î µÇ¾ú´ÂÁö È®ÀÎÇÑ´Ù. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Minor) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

			// ¿¡·¯´Ù. ÀÌÀü °ªÀ¸·Î º¹±¸.
			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Minor) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
	else {
		// ÇØÅ·ÀÌ³ª ¿¡·¯¿¡ ÀÇÇØ¼­ Æ¯¼ºÄ¡°¡ ¿À¹öµÈ °æ¿ìÀÌ´Ù. ¿À¹öµÈ Æ÷ÀÎÆ®¸¸Å­ »«´Ù. iToBeRestoredPoint°¡ ¸¶ÀÌ³Ê½º»óÅÂ! 

		// ¸ÕÀú Æ¯¼ºÄ¡ Á¦ÇÑÄ¡¸¦ ¿À¹öÇÑ °ªÀ» »«´Ù.
		while (1) {
			bFlag = false;
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iStr--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iDex--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iVit--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iInt--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iMag--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iCharisma--;
				iToBeRestoredPoint++;
			}

			if (bFlag == false)	break;
			if (iToBeRestoredPoint >= 0) break;
		}

		if (iToBeRestoredPoint < 0) {
			// ³²Àº Æ÷ÀÎÆ® ¸¸Å­ ·£´ýÇÏ°Ô ¼±ÅÃµÈ Æ¯¼ºÄ¡ÀÇ °ªÀ» ³»¸°´Ù.
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr > 10) {
						m_pClientList[iClientH]->m_iStr--;
						iToBeRestoredPoint++;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit > 10) {
						m_pClientList[iClientH]->m_iVit--;
						iToBeRestoredPoint++;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex > 10) {
						m_pClientList[iClientH]->m_iDex--;
						iToBeRestoredPoint++;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag > 10) {
						m_pClientList[iClientH]->m_iMag--;
						iToBeRestoredPoint++;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt > 10) {
						m_pClientList[iClientH]->m_iInt--;
						iToBeRestoredPoint++;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma > 10) {
						m_pClientList[iClientH]->m_iCharisma--;
						iToBeRestoredPoint++;
					}
					break;
				}
			}
		}
		else {
			// °è»êÀ» Çß´õ´Ï ´Ù½Ã °ªÀÌ ¿À¹öµÇ¾ú´Ù. ÀÌ·²¼ö°¡ ÀÖÀ»±î?
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iStr++;
						iToBeRestoredPoint--;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iVit++;
						iToBeRestoredPoint--;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iDex++;
						iToBeRestoredPoint--;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iMag++;
						iToBeRestoredPoint--;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iInt++;
						iToBeRestoredPoint--;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iCharisma++;
						iToBeRestoredPoint--;
					}
					break;
				}
			}
		}

		// º¹±¸°¡ ¼º°øÀûÀ¸·Î µÇ¾ú´ÂÁö È®ÀÎÇÑ´Ù. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Over) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Over) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
}

void CGame::CalcTotalItemEffect(int iClientH, int iEquipItemID, bool bNotify)
{
 short sItemIndex;
 int  i, iArrowIndex, iPrevSAType, iTemp;
 char cEquipPos;
 double dV1, dV2, dV3;
 DWORD  dwSWEType, dwSWEValue;
 short  sTemp;

   	if (m_pClientList[iClientH] == 0) return;

	if ( (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]   != -1) &&
		 (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) ) {
		
		// ߸   ̴.   ϳ  ´. 
		if (m_pClientList[iClientH]->m_pItemList[ m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] ] != 0) {
			// Ѽ   ¸ Ѵ. 
			m_pClientList[iClientH]->m_bIsItemEquipped[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]] = false;
			m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] = -1;
		}
	}

	m_pClientList[iClientH]->m_iAngelicStr = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicInt = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicDex = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicMag = 0; // By Snoopy81	
	SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 0, 0);

	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
	m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;  

	m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
	m_pClientList[iClientH]->m_cAttackBonus_L      = 0;

	m_pClientList[iClientH]->m_iHitRatio = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = m_pClientList[iClientH]->m_iDex * 2;
	m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 0;
	
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
	m_pClientList[iClientH]->m_iDamageAbsorption_Armor[i]  = 0;

	m_pClientList[iClientH]->m_iManaSaveRatio  = 0;
	m_pClientList[iClientH]->m_iAddResistMagic = 0;

	m_pClientList[iClientH]->m_iAddPhysicalDamage = 0;
	m_pClientList[iClientH]->m_iAddMagicalDamage  = 0;

	m_pClientList[iClientH]->m_bIsLuckyEffect  = false;
	m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = -1;
	m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 0;

	m_pClientList[iClientH]->m_iAddAbsAir   = 0;	// Ӽ  
	m_pClientList[iClientH]->m_iAddAbsEarth = 0;
	m_pClientList[iClientH]->m_iAddAbsFire  = 0;
	m_pClientList[iClientH]->m_iAddAbsWater = 0;

	m_pClientList[iClientH]->m_iCustomItemValue_Attack  = 0;
	m_pClientList[iClientH]->m_iCustomItemValue_Defense = 0;

	m_pClientList[iClientH]->m_iMinAP_SM = 0;
	m_pClientList[iClientH]->m_iMinAP_L  = 0;

	m_pClientList[iClientH]->m_iMaxAP_SM = 0;
	m_pClientList[iClientH]->m_iMaxAP_L  = 0;

	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = 0;	//   ȿ : 0-None 1-ʻ߰ 2-ߵȿ 3- 4-
	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = 0;	//   ȿ 

	m_pClientList[iClientH]->m_iAddHP = m_pClientList[iClientH]->m_iAddSP = m_pClientList[iClientH]->m_iAddMP = 0; 
	m_pClientList[iClientH]->m_iAddAR = m_pClientList[iClientH]->m_iAddPR = m_pClientList[iClientH]->m_iAddDR = 0;
	m_pClientList[iClientH]->m_iAddMR = m_pClientList[iClientH]->m_iAddAbsPD = m_pClientList[iClientH]->m_iAddAbsMD = 0;
	m_pClientList[iClientH]->m_iAddCD = m_pClientList[iClientH]->m_iAddExp = m_pClientList[iClientH]->m_iAddGold = 0;	
	
	iPrevSAType = m_pClientList[iClientH]->m_iSpecialAbilityType;

	m_pClientList[iClientH]->m_iSpecialAbilityType     = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityLastSec  = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = 0;

	m_pClientList[iClientH]->m_iAddTransMana = 0;
	m_pClientList[iClientH]->m_iAddChargeCritical = 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	//  ʾƵ ȿ ִ .
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				//  ־ ȿ ִ.
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}
	
	//  ؾ ȿ ִ  
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  ((m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) && 
		 (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] )) {

		cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		
		case DEF_ITEMEFFECTTYPE_MAGICDAMAGESAVE:
			//    . ε Ѵ.
			m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = sItemIndex;
			break;
		
		case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
		case DEF_ITEMEFFECTTYPE_ATTACK:
			//   ȿ
			m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
			m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
			m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
			m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;

			// v2.05  Ưġ ߰ 
			iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
			//testcode
			//wsprintf(G_cTxt, "Add Damage: %d", iTemp);
			//PutLogList(G_cTxt);

			//   ߰
			m_pClientList[iClientH]->m_iAddPhysicalDamage += iTemp;
			m_pClientList[iClientH]->m_iAddMagicalDamage  += iTemp;
						
			// ݹ ش ųŭ ߷ Ѵ. 
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			
			// v1.432  ʴ´.  ݴ ߷ ġ Ѵ.
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			// ÷̾ ϴ  ų Ѵ. 
			m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;
			
			// v1.41 Custom-Made ̶ ȿ Ѵ. ݹ 1 ȴٰ  ȿ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != 0) {
				m_pClientList[iClientH]->m_iCustomItemValue_Attack += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				//   
				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = 100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < -100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = -100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 0) {
					//   Ÿġ ּҰ ִ 5 ö󰣴.
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMinAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM + 
														   m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					
					m_pClientList[iClientH]->m_iMinAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L + 
														   m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;

					// ġ  
					if (m_pClientList[iClientH]->m_iMinAP_SM < 1) m_pClientList[iClientH]->m_iMinAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMinAP_L < 1)  m_pClientList[iClientH]->m_iMinAP_L = 1;

					// ּҰ ִ밪 ũ ִ밪ŭ 
					if (m_pClientList[iClientH]->m_iMinAP_SM > (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMinAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					
					if (m_pClientList[iClientH]->m_iMinAP_L > (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMinAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
					
					//testcode
					//wsprintf(G_cTxt, "MinAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMinAP_SM, m_pClientList[iClientH]->m_iMinAP_L, (int)dV1);
					//PutLogList(G_cTxt);
				}
				else if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < 0) {
					//   Ÿġ ִ밪 ִ 5 .
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMaxAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM 
														   + m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					
					m_pClientList[iClientH]->m_iMaxAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L 
														   + m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;
					
					// ġ  
					if (m_pClientList[iClientH]->m_iMaxAP_SM < 1) m_pClientList[iClientH]->m_iMaxAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMaxAP_L < 1)  m_pClientList[iClientH]->m_iMaxAP_L = 1;

					// ִ밪 ּҰ  ּҰŭ 
					if (m_pClientList[iClientH]->m_iMaxAP_SM < (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMaxAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					
					if (m_pClientList[iClientH]->m_iMaxAP_L < (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMaxAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
					
					//testcode
					//wsprintf(G_cTxt, "MaxAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMaxAP_SM, m_pClientList[iClientH]->m_iMaxAP_L, (int)dV1);
					//PutLogList(G_cTxt);
				}
			}

			// v1.42  ̶ Main ȿ Ѵ. ݹ 1 ȴٰ  ȿ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				
				//   ȿ : 
				// 0-None 1-ʻ߰ 2-ߵȿ 3- 4- 
				// 5-ø 6- 7- 8-ȭ 9-빮 10- 
				m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = (int)dwSWEType;	
				m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = (int)dwSWEValue;

				switch (dwSWEType) {
				case 7: //  
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;

				case 9: // 빮
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;
				}
			}

			// v1.42  ̶ Sub ȿ Ѵ. ݹ 1 ȴٰ  ȿ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != 0) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
				
				//   ȿ : 
				//߰ (1), ߰ ߰(2), ߰ (3), HP ȸ ߰(4), SP ȸ ߰(5)
				//MP ȸ ߰(6), ߰ (7),   (8),   (9)
				//Ÿ  ߰(10),   ġ(11),  Gold(12)
				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break;
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break;
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue*3; break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}

				// v2.04 Ưġ  .
				switch (dwSWEType) {
				case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break;
				}
			}

			// Ϲ  ̿ ȿ .
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
				// ִ HP  ȿ
				m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
				//   ȿ:   ִ 80%
				m_pClientList[iClientH]->m_iManaSaveRatio    += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
				// ߰   ɷ ȿ 
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
				// Ư ɷ 
				m_pClientList[iClientH]->m_iSpecialAbilityType    = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// Ư ɷ  ð
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				//  ġ  ´.
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
								
				// Ư ɷ  ˷ش.
				if ((bNotify ) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, 0);
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_ADDEFFECT:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// ߰    
				m_pClientList[iClientH]->m_iAddResistMagic += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 2:
				//   ȿ 
				m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				//   ִ 80%
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case 3:
				//    ȿ.   ݿ ؼ   ٴ´. 
				m_pClientList[iClientH]->m_iAddPhysicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 4:
				// ߰   
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 5:
				//  ȿ?
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 != 0)
					 m_pClientList[iClientH]->m_bIsLuckyEffect = true;
				else m_pClientList[iClientH]->m_bIsLuckyEffect = false;
				break;

			case 6:
				//    ȿ.   ݿ ؼ   ٴ´. 
				m_pClientList[iClientH]->m_iAddMagicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 7:
				m_pClientList[iClientH]->m_iAddAbsAir += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 8:
				m_pClientList[iClientH]->m_iAddAbsEarth += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 9:
				m_pClientList[iClientH]->m_iAddAbsFire += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 10:
				// 迭   Ҵ  Ȯ ȿ ִ. (2 Ȯ )
				m_pClientList[iClientH]->m_iAddAbsWater += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 11:
				//  .
				m_pClientList[iClientH]->m_iAddPR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 12:
				m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 13: // Magin Ruby		Characters Hp recovery rate(% applied) added by the purity formula.
				m_pClientList[iClientH]->m_iAddHP += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 5);
				break;

			case 14: // Magin Diamond	Attack probability(physical&magic) added by the purity formula.
				m_pClientList[iClientH]->m_iAddAR += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 5);
				break;


			case 15: // Magin Emerald	Magical damage decreased(% applied) by the purity formula.	
				m_pClientList[iClientH]->m_iAddAbsMD += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 10);
				if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80;
				break;

			case 30: // Magin Sapphire	Phisical damage decreased(% applied) by the purity formula.	
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 10);
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] += iTemp;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += iTemp;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] += iTemp;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] += iTemp;
				break;
				
				/*Functions rates confirm.
				Magic Diamond: Completion rate / 5 = Functions rate. ? Maximum 20. (not%)
				Magic Ruby: Completion rate / 5 = Functions rate.(%) ? Maximum 20%.
				Magic Emerald: Completion rate / 10 = Functions rate.(%) ? Maximum 10%.
				Magic Sapphire: Completion rate / 10 = Functions rate.(%) ? Maximum 10%.*/

				// ******* Angel Code - Begin ******* //			
			case 16: // Angel STR//AngelicPandent(STR)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicStr = iTemp + 1;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 1, iTemp);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
				break;
			case 17: // Angel DEX //AngelicPandent(DEX)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicDex = iTemp + 1;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 2, iTemp);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
				break;
			case 18: // Angel INT//AngelicPandent(INT)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicInt = iTemp + 1;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 3, iTemp);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
				break;
			case 19: // Angel MAG//AngelicPandent(MAG)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicMag = iTemp + 1;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 4, iTemp);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
				break;

			}
			break;
			
		case DEF_ITEMEFFECTTYPE_ATTACK_ARROW:
			// ȭ ʿ ϴ (Ȱ)
			//  ȿ  ȭ õǴĿ  ޶.  ȭ ã ҴѴ.
			if ( (m_pClientList[iClientH]->m_cArrowIndex != -1) && 
				 (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cArrowIndex] == 0) ) {
				// ArrowIndex ȭ . (ִ ) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			}
			else if (m_pClientList[iClientH]->m_cArrowIndex == -1) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			
			if (m_pClientList[iClientH]->m_cArrowIndex == -1) {
				// ȭ .
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
				m_pClientList[iClientH]->m_cAttackBonus_L      = 0;
			}
			else {
				iArrowIndex = m_pClientList[iClientH]->m_cArrowIndex;
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
			}
			
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			break;
			
		case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_DEFENSE:
			m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
			
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != 0) {
				m_pClientList[iClientH]->m_iCustomItemValue_Defense += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				
				dV2 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				dV3 = (double)m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
				dV1 = (double)(dV2 / 100.0f)*dV3;
					
				dV1 = dV1 / 2.0f;
				m_pClientList[iClientH]->m_iDefenseRatio += (int)dV1;
				if (m_pClientList[iClientH]->m_iDefenseRatio <= 0) m_pClientList[iClientH]->m_iDefenseRatio = 1;

				//testcode
				//wsprintf(G_cTxt, "Custom-Defense: %d", (int)dV1);
				//PutLogList(G_cTxt);
			}

			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				
				//   ȿ : 
				// 0-None 1-ʻ߰ 2-ߵȿ 3- 4- 
				// 5-ø 6- 7- 8-ȭ 9-빮 10- 11-ȯ 12-ʻ
			
				switch (dwSWEType) {
				case 7: //  
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;

				case 9: // 빮
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;

				// v2.04 
				case 11: //  ȯ 
					m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddTransMana > 13) m_pClientList[iClientH]->m_iAddTransMana = 13;
					break;

				case 12: // ʻ  
					m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
					break;
				}
			}

			// v1.42  ̶ Sub ȿ Ѵ. ݹ 1 ȴٰ  ȿ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != 0) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
				
				//   ȿ : 
				//߰ (1), ߰ ߰(2), ߰ (3), HP ȸ ߰(4), SP ȸ ߰(5)
				//MP ȸ ߰(6), ߰ (7),   (8),   (9)
				//Ÿ  ߰(10),   ġ(11),  Gold(12)
				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break;
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break;
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue*3; break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}

				// v2.04 Ưġ  .
				switch (dwSWEType) {
				case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break; //    ִ 80%
				}
			}

			switch ( cEquipPos ) {
			case DEF_EQUIPPOS_LHAND:
				//   а  Ǿ. 
				// п    ȿ ҴѴ.  70%  
				m_pClientList[iClientH]->m_iDamageAbsorption_Shield	= (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) - (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1)/3;
				break;
			default:
				// ʿ    ȿ Ѵ.  70%  <- v1.43 100% Ǿ. V2!
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				break;
			}

			// Ϲ  ̿ ȿ .
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
				// Ư ɷ 
				m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// Ư ɷ  ð
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				//  ġ  ´.
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
				
				// Ư ɷ  ˷ش.
				if ((bNotify ) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, 0);
				break;
			}
			break;
		}
	}

	// Snoopy: Bonus for Angels	
	m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_iAngelicDex * 2;
	if (m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
	if (m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	if (m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);


	//v1.432
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) && (bNotify )) {
		// Ư ɷ Ǿ.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 4, 0, 0, 0);
		//  Ư ɷ  ̾ٸ ܸ ȭϸ 뵵 .
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled ) {
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = false;
			//    ð ԷѴ.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// ȿ Ʈ Ŭ
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			//   ˸.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		}
	}
	
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) && 
		(iPrevSAType != m_pClientList[iClientH]->m_iSpecialAbilityType) && (bNotify )) {
		// Ư ɷ  ߿ Ư ɷ ٲٸ ɷ  .
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled ) {
			// ð  Ǿ.
			SendNotifyMsg(0, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, 0, 0, 0);
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = false;
			//    ð ԷѴ.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// ȿ Ʈ Ŭ
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			//   ˸.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		}
	}
}

int CGame::_iGetPlayerNumberOnSpot(short dX, short dY, char cMapIndex, char cRange)
{
 int ix, iy, iSum = 0;
 short sOwnerH;
 char  cOwnerType;

	for (ix = dX - cRange; ix <= dX + cRange; ix++)
	for (iy = dY - cRange; iy <= dY + cRange; iy++) {
		m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
			iSum++;
	}

	return iSum;
}

void CGame::RequestAdminUserMode(int iClientH, char * pData)
{
	// ¿î¿µÀÚ ¸ðµå¸¦ È®ÀÎÇÏ±â À§ÇØ¼­´Â ÀÏ´Ü ÀÌ ¸Þ½ÃÁö¸¦ Àü¼ÛÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ °®°í ÀÖ¾î¾ß ÇÑ´Ù. 
	// ¶ÇÇÑ ³¯Â¥¸¦ Á¶ÇÕÇØ¼­ »ý¼ºµÇ´Â È®ÀÎ ÄÚµå°¡ ÀÏÄ¡ÇØ¾ß ÇÑ´Ù. 

}

bool CGame::bAnalyzeCriminalAction(int iClientH, short dX, short dY, bool bIsCheck)
{
 int   iNamingValue, tX, tY;
 short sOwnerH;
 char  cOwnerType, cName[11], cNpcName[21];
 char  cNpcWaypoint[11];

	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return false;
	if (m_bIsCrusadeMode ) return false;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0)) {
		if (_bGetIsPlayerHostile(iClientH, sOwnerH) != true) {
			if (bIsCheck ) return true;

			ZeroMemory(cNpcName, sizeof(cNpcName));
			if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0) 
				strcpy(cNpcName, "Guard-Neutral");

			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {

			}
			else {
				ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
				ZeroMemory(cName, sizeof(cName));
			   	wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, 0, 0, -1, false, true) == false) {
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					bSetNpcAttackMode(cName, iClientH, DEF_OWNERTYPE_PLAYER, true);
				}
			}
		}
	}
	return false;
}

bool CGame::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[sOwnerH]  == 0) return false;

	// ÀÚ±â ÀÚ½Å¿¡ ´ëÇÑ °ø°ÝÀº ¹üÁË¶ó º¼ ¼ö ¾ø´Ù. 
	if (iClientH == sOwnerH) return true;

	if (m_pClientList[iClientH]->m_cSide == 0) {
		// °ø°ÝÀÚ´Â ¿©ÇàÀÚÀÌ´Ù.
		// »ó´ë¹æÀÌ ¹üÁËÀÚÀÌ¸é Àû¼ºÀÌ¸ç ±× ÀÌ¿Ü¿¡´Â ¾Æ´Ï´Ù. 
		if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 return true;
		else return false;
	}
	else {
		// °ø°ÝÀÚ´Â ¼Ò¼Ó ¸¶À»À» °®°í ÀÖ´Ù. 
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) {
			// ¼­·Î »çÀÌµå°¡ ´Ù¸£´Ù. 
			if (m_pClientList[sOwnerH]->m_cSide == 0) {
				if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
				 	 return true;
				else return false;
			}
			else return true;
		}
		else {
			if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 	 return true;
			else return false;
		}
	}

	return false;
}

void CGame::bSetNpcAttackMode(char * cName, int iTargetH, char cTargetType, bool bIsPermAttack)
{
 int i, iIndex;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != 0) && (memcmp(m_pNpcList[i]->m_cName, cName, 5) == 0) ) {
		iIndex = i;
		goto NEXT_STEP_SNAM1;

		//testcode
		//PutLogList("bSetNpcAttackMode - Npc found");
	}
	// °°Àº ÀÌ¸§À» °¡Áø NPC°¡ ¾ø´Ù.
	return;

NEXT_STEP_SNAM1:

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == 0) return;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iTargetH] == 0) return;
		break;
	}

	// ¸ñÇ¥¹°À» ÇÒ´çÇÑ´Ù. 
	m_pNpcList[iIndex]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
	m_pNpcList[iIndex]->m_sBehaviorTurnCount = 0;		
	m_pNpcList[iIndex]->m_iTargetIndex = iTargetH;
	m_pNpcList[iIndex]->m_cTargetType  = cTargetType;

	// ¿µ±¸ °ø°Ý ¸ðµå ¿©ºÎ ¼³Á¤ 
	m_pNpcList[iIndex]->m_bIsPermAttackMode = bIsPermAttack;

	//testcode
	//PutLogList("bSetNpcAttackMode - complete");
}


void CGame::PoisonEffect(int iClientH, int iV1)
{
 int iPoisonLevel, iDamage, iPrevHP, iProb;

	// Áßµ¶À¸·Î Á×Áö´Â ¾Ê´Â´Ù. ´Ù¸¸ Ã¼·ÂÀÌ °è¼Ó ±ïÀÌ°í ÃÖ¼Ò 1¸¸ ³²´Â´Ù. 
	if (m_pClientList[iClientH] == 0)     return;
	if (m_pClientList[iClientH]->m_bIsKilled ) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;

	iDamage = iDice(1, iPoisonLevel);
	
	iPrevHP = m_pClientList[iClientH]->m_iHP;
	m_pClientList[iClientH]->m_iHP -= iDamage;
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

	if (iPrevHP != m_pClientList[iClientH]->m_iHP)
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);
		

	// µ¶¼º ÀúÇ× È®·ü·Î Áßµ¶ÀÌ Ç®¸± ¼ö ÀÖ´Ù.
	iProb = m_pClientList[iClientH]->m_cSkillMastery[23] -10 +m_pClientList[iClientH]->m_iAddPR;
	if (iProb <= 10) iProb = 10;
	if (iDice(1,100) <= iProb) {
		m_pClientList[iClientH]->m_bIsPoisoned = false;
		// Áßµ¶ÀÌ Ç®·ÈÀ½À» ¾Ë¸°´Ù. 
		SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, false); // remove poison aura after effect complete
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, 0, 0, 0);
	}
}
bool CGame::bCheckResistingPoisonSuccess(short sOwnerH, char cOwnerType)
{
 int iResist, iResult;
	
	// µ¶¼º ÀúÇ×ÀÌ ¼º°øÇß´ÂÁö¸¦ °è»êÇÑ´Ù. 
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return false;
		iResist = m_pClientList[sOwnerH]->m_cSkillMastery[23] +m_pClientList[sOwnerH]->m_iAddPR;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return false;
		iResist = 0;
		break;
	}

	iResult = iDice(1, 100);
  	if (iResult >= iResist) // µ¶¼º ÀúÇ× ½ÇÆÐ. Áßµ¶µÈ´Ù.
		return false;

	// µ¶¼º ÀúÇ× ¼º°ø. ÇÃ·¹ÀÌ¾î¶ó¸é ½ºÅ³À» ¿Ã¸°´Ù. 
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sOwnerH, 23, 1);

	return true;
}

bool CGame::bCheckBadWord(char * pString)
{
 char * cp;

	// ½ºÆ®¸µÀ» °Ë»öÇÏ¸ç ¿å¼³ÀÌ ÀÖ´ÂÁö¸¦ Ã£´Â´Ù. 
	cp = pString;
	while (*cp != 0) {
		
		cp++;
	}

	return false;
}

void CGame::CheckDayOrNightMode()
{
 SYSTEMTIME SysTime;	
 char cPrevMode;
 int  i;

	//if (m_bManualTime = true) return;

	// ÇöÀç ½Ã°£¿¡ µû¶ó ³· È¤Àº ¹ãÀ» °áÁ¤ÇÑ´Ù. 
	// ÁÖ, ¾ß°£ ¸ðµå ¼³Á¤ 
	cPrevMode = m_cDayOrNight;
 
	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= DEF_NIGHTTIME) 
		 m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	if (cPrevMode != m_cDayOrNight) {
		// ÁÖ, ¾ß°£ ¸ðµå°¡ º¯°æµÇ¾ú´Ù. ÁÖ, ¾ß°£ ¸ðµåÀÇ ¿µÇâÀ» ¹Þ´Â ¸Ê¿¡ Á¸ÀçÇÏ´Â Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ¾Ë¸°´Ù. 
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
			if ((m_pClientList[i]->m_cMapIndex >= 0) && 
				(m_pMapList[m_pClientList[i]->m_cMapIndex] != 0) &&
				(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == false))
				SendNotifyMsg(0, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, 0, 0, 0);	
		}
	}
}


void CGame::ShutUpPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 int i, iTime;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelShutup) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != 0) {
		// tokenÀÌ °ð Ã¤ÆÃÀ» ºÒ°¡´ÉÇÏ°Ô ¸¸µé »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		// ´ÙÀ½ ÅäÅ«Àº Á¤Áö ½ÃÅ³ ½Ã°£. 
		token = pStrTok->pGet();
		if (token == 0) 
			 iTime = 0;
		else iTime = atoi(token);
	
		if (iTime < 0) iTime = 0;
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			m_pClientList[i]->m_iTimeLeft_ShutUp = iTime * 20; // 1ÀÌ 3ÃÊ´Ù. 20ÀÌ¸é 1ºÐ 
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERSHUTUP, iTime, 0, 0, cName);
			SendNotifyMsg(0, i, DEF_NOTIFY_PLAYERSHUTUP, iTime, 0, 0, cName);

			// Admin Log
			wsprintf(G_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName, 
				     m_pClientList[i]->m_cCharName, iTime);
			PutAdminLogFileList(G_cTxt);

			delete pStrTok;
			return;
		}
		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		/*ZeroMemory(cBuff, sizeof(cBuff));

		char *cp;
		WORD *wp;

		cp = (char *)cBuff;

		*cp = GSM_REQUEST_SHUTUPPLAYER;
		cp++;

		wp = (WORD *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD)iClientH;
		cp += 2;

		memcpy(cp, cName, 10);
		cp += 10;

		wp = (WORD *)cp;
		*wp = iTime;
		cp += 2;

		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		bStockMsgToGateServer(cBuff, 27);*/
	}

	delete pStrTok;
	return;
}


void CGame::SetPlayerReputation(int iClientH, char * pMsg, char cValue, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 40) return;

	if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) {
		// 򰡸  ð  ʾҰų ڴ 򰡸   .    .
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, 0, 0, 0);
		return;
	}
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		// Ҽ       .
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTRATING, 0, 0, 0, 0);
		return;	
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != 0) {
		// token     ̸ 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			if (i != iClientH) {
				// ڱ ڽ   .
				if (cValue == 0) 
					m_pClientList[i]->m_iRating--;
				else if (cValue == 1)
					m_pClientList[i]->m_iRating++;
				
				if (m_pClientList[i]->m_iRating > 500)  m_pClientList[i]->m_iRating = 500;
				if (m_pClientList[i]->m_iRating < -500) m_pClientList[i]->m_iRating = -500;
				// 򰡸 Ƿ ð   Ҵ. 
				m_pClientList[iClientH]->m_iTimeLeft_Rating = 20*60;

				SendNotifyMsg(0, i, DEF_NOTIFY_RATINGPLAYER, cValue, 0, 0, cName);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_RATINGPLAYER, cValue, 0, 0, cName);
				
				delete pStrTok;
				return;
			}
		}
		//   ƴϴ.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cName);
	}
	
	delete pStrTok;
	return;
}

bool CGame::bReadNotifyMsgListFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "=\t\n;";
 class CStrTok * pStrTok;
 int   i;

	cReadMode = 0;
	m_iTotalNoticeMsg = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		PutLogList("(!) Notify Message list file not found!...");
		return false;
	}
	else {
		PutLogList("(!) Reading Notify Message list file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != 0 )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					for (i = 0; i < DEF_MAXNOTIFYMSGS; i++) 
					if (m_pNoticeMsgList[i] == 0) {
						m_pNoticeMsgList[i] = new class CMsg;	
						m_pNoticeMsgList[i]->bPut(0, token, strlen(token), 0, 0);
						m_iTotalNoticeMsg++;
						goto LNML_NEXTSTEP1;
					}
LNML_NEXTSTEP1:	
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "notify_msg", 10) == 0) cReadMode = 1;
			}
			
			token = pStrTok->pGet();
			//token = strtok( 0, seps );
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}
void CGame::NoticeHandler()
{
 char  cTemp, cBuffer[1000], cKey;
 DWORD dwSize, dwTime = timeGetTime();
 int i, iMsgIndex, iTemp;

	// °øÁö»çÇ×ÀÌ 1°³ ÀÌÇÏ¶ó¸é º¸³¾ ÇÊ¿ä°¡ ¾ø´Ù.
	if (m_iTotalNoticeMsg <= 1) return;

	if ((dwTime - m_dwNoticeTime) > DEF_NOTICETIME) {
		// °øÁö»çÇ×À» Àü¼ÛÇÒ ½Ã°£ÀÌ µÇ¾ú´Ù. 
		m_dwNoticeTime = dwTime;	
		do {
			iMsgIndex = iDice(1, m_iTotalNoticeMsg) - 1;
		} while (iMsgIndex == m_iPrevSendNoticeMsg);

		m_iPrevSendNoticeMsg = iMsgIndex;
		
		ZeroMemory(cBuffer, sizeof(cBuffer));
		if (m_pNoticeMsgList[iMsgIndex] != 0) {
			m_pNoticeMsgList[iMsgIndex]->Get(&cTemp, cBuffer, &dwSize, &iTemp, &cKey);
		}
		
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			SendNotifyMsg(0, i, DEF_NOTIFY_NOTICEMSG, 0, 0, 0, cBuffer);
		}
	}
}


void CGame::ResponseSavePlayerDataReplyHandler(char * pData, DWORD dwMsgSize)
{
 char * cp, cCharName[11];
 int i;

	ZeroMemory(cCharName, sizeof(cCharName));
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);

	// ÀÌÁ¦ ÀÌ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£¾Æ Á¢¼ÓÀ» ²÷¾îµµ ÁÁ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù. 
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != 0) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			// °°Àº ÀÌ¸§À» °¡Áø Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. Á¢¼ÓÀ» Á¾·áÇÏ¶ó´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
			SendNotifyMsg(0, i, DEF_NOTIFY_SERVERCHANGE, 0, 0, 0, 0);
		}
	}
}

void CGame::CalcExpStock(int iClientH)
{
	bool bIsLevelUp;
	class CItem * pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iExpStock <= 0) return;
	// !!!!
	// v2.12 2002-2-6 ÁöÁ¸µµ ÇöÀç °æÇèÄ¡°¡ ÃÖ´ë ·¹º§ °æÇèÄ¡º¸´Ù ÀûÀ¸¸é °æÇèÄ¡¸¦ ¾òÀ»¼ö ÀÖ°Ô º¯°æ .. v2.15 »èÁ¦. ÁöÁ¸µµ °æÇèÄ¡ ¾ò´Â´Ù.
	//if ((m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) && (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_iPlayerMaxLevel])) return;

	// Æ÷»ó°ú Æä³ÎÆ¼°¡ ¾ø´Â ¸Ê À§¿¡ ¼­ ÀÖ´Ù¸é °æÇèÄ¡´Â ¿Ã¶ó°¡Áö ¾Ê´Â´Ù.
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) {
		m_pClientList[iClientH]->m_iExpStock = 0;
		return;
	}

	// ±×µ¿¾È ÃàÀû µÇ¾ú´ø °æÇèÄ¡¸¦ °è»êÇÑ´Ù. 
	m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iExpStock = 0;

	if (bCheckLimitedUser(iClientH) == false) {
		// Ã¼ÇèÆÇ »ç¿ëÀÚ Á¦ÇÑ¿¡ ÇØ´çµÇÁö ¾ÊÀ¸¸é °æÇèÄ¡°¡ ¿Ã¶ú´Ù´Â Åëº¸¸¦ ÇÑ´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
	}
	// ·¹º§ÀÌ ¿Ã¶ú´ÂÁö¸¦ °Ë»çÇÑ´Ù.
	bIsLevelUp = bCheckLevelUp(iClientH);

	// v2.03 º¯°æ 9/1
	if ((bIsLevelUp ) && (m_pClientList[iClientH]->m_iLevel <= 5)) {
		// ÃÊº¸¿ë Gold Áö±Þ. ·¹º§ 1~5±îÁö 100 Gold Áö±Þ.
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == false) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (DWORD)100000;
		bAddItem(iClientH, pItem, 0);
	}

	// v2.03 º¯°æ 9/1
	if ((bIsLevelUp ) && (m_pClientList[iClientH]->m_iLevel > 5 ) &&  (m_pClientList[iClientH]->m_iLevel <= 20) ) {
		// ÃÊº¸¿ë Gold Áö±Þ. ·¹º§ 5~20±îÁö 300 Gold Áö±Þ.
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == false) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (DWORD)100000;
		bAddItem(iClientH, pItem, 0);
	}
}

void CGame::___RestorePlayerRating(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iRating < -10000) m_pClientList[iClientH]->m_iRating = 0;
	if (m_pClientList[iClientH]->m_iRating >  10000) m_pClientList[iClientH]->m_iRating = 0;
}

int CGame::iGetExpLevel(DWORD iExp)
{
 int i;

	// °æÇèÄ¡°¡ ¾î´À ·¹º§ ¼öÁØ¿¡ ¼ÓÇÏ´ÂÁö ÆÇ´ÜÇÑ´Ù.
	for (i = 1; i < 1000; i++) 
	if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i+1] > iExp)) return i;

	return 0;
}

void CGame::AdminOrder_CallGuard(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
 class  CStrTok * pStrTok;
 int i, iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCallGaurd) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != 0) {
		// tokenÀÌ °ð Ã¤ÆÃÀ» ºÒ°¡´ÉÇÏ°Ô ¸¸µé »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			// ¸ñÇ¥ Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. 	
			
			if (memcmp(m_pClientList[i]->m_cMapName, "aresden", 7) == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (memcmp(m_pClientList[i]->m_cMapName, "elvine", 6) == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else strcpy(cNpcName, "Guard-Neutral");  // <- ÀÌ°ÍÀº ¸¶À»ÀÌ ¾Æ´Ï¹Ç·Î Áß¸³ °¡µå¸¦ »ý¼º½ÃÅ²´Ù.
			
			iNamingValue = m_pMapList[ m_pClientList[i]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
			}
			else {
				// NPC¸¦ »ý¼ºÇÑ´Ù.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[i]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[i]->m_sX;
				tY = (int)m_pClientList[i]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[i]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, 0, 0, -1, false, true) == false) {
					// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
					m_pMapList[ m_pClientList[i]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					// °¡µå¸¦ »ý¼º½ÃÄ×´Ù. °ø°Ý ¸ñÇ¥¸¦ ÇÒ´çÇÑ´Ù.
					bSetNpcAttackMode(cName, i, DEF_OWNERTYPE_PLAYER, true);
				}
			}

			delete pStrTok;
			return;
		}

		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cTargetName);
	}

	delete pStrTok;
	return;
}
void CGame::AdminOrder_Kill(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
	class  CStrTok * pStrTok;
	int i;
	int sAttackerWeapon, sDamage, iExH;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGMKill) {
	// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//
	token = pStrTok->pGet();
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//
	if (token != 0) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}

	token = pStrTok->pGet();
	if (token != 0) {
		sDamage = atoi(token);
	} else {
		sDamage = 1;
	}

	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//

	if (token == 0) { token = "null"; }
	if (cName != 0) {
		token = cName;
		// tokenÀÌ °ð Ã¤ÆÃÀ» ºÒ°¡´ÉÇÏ°Ô ¸¸µé »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				// ¸ñÇ¥ Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. 	

				m_pClientList[i]->m_iHP = 0;
				//if (iGetMaxHP(i) < m_pClientList[i]->m_iHP) m_pClientList[i]->m_iHP = iGetMaxHP(i);
				m_pClientList[i]->m_bIsKilled = true;

				if (m_pClientList[i]->m_bIsExchangeMode ) {
					iExH = m_pClientList[i]->m_iExchangeH;
					_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(i);
				}

				RemoveFromTarget(i, DEF_OWNERTYPE_PLAYER);

				SendNotifyMsg(0, i, DEF_NOTIFY_KILLED, 0, 0, 0, m_pClientList[iClientH]->m_cCharName);
				sAttackerWeapon = 1;
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, 0);
				// Á¤»ó À§Ä¡¿¡¼­ Áö¿î´Ù.
				m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(12, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				// Á×Àº À§Ä¡ Ç¥½Ã¸¦ ÇÑ´Ù.
				m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);

				delete pStrTok;
				return;
			}

			// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cTargetName);
	}

	delete pStrTok;
	return;
} 

void CGame::AdminOrder_Revive(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
	class  CStrTok * pStrTok;
	int i;
	int sAttackerWeapon, sDamage, sHP;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGMRevive) {
	// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);


	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != 0) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}

	token = pStrTok->pGet();

	if (token != 0) {
		sDamage = atoi(token);
	} else {
		sDamage = 1;
	}
	token = pStrTok->pGet();
	if (token != 0) {
		sHP = atoi(token);
	} else {
		sHP = 1;
	}

	token = cName;
	//if (token == 0) { token = "null"; }
	if (cName != 0) {
		// tokenÀÌ °ð Ã¤ÆÃÀ» ºÒ°¡´ÉÇÏ°Ô ¸¸µé »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				// ¸ñÇ¥ Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. 	

				m_pClientList[i]->m_iHP = sHP;
				if (iGetMaxHP(i) < m_pClientList[i]->m_iHP) m_pClientList[i]->m_iHP = iGetMaxHP(i);
				m_pClientList[i]->m_bIsKilled = false;
				m_pClientList[i]->m_iLastDamage = sDamage;
				//			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[i]->m_iLastDamage, 0, 0);
				SendNotifyMsg(0, i, DEF_NOTIFY_HP, 0, 0, 0, 0);
				sAttackerWeapon = 1;
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, sDamage, sAttackerWeapon, 0);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(14, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);

				delete pStrTok;
				return;
			}

			// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cTargetName);
	}

	delete pStrTok;
	return;
} 
void CGame::AdminOrder_SummonDemon(int iClientH)
{
 char cName[21], cNpcName[21], cNpcWaypoint[11];	
 int iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == false) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonDemon) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
	}
	else {
		// NPC¸¦ »ý¼ºÇÑ´Ù.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Demon");	
		
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)m_pClientList[iClientH]->m_sX;
		tY = (int)m_pClientList[iClientH]->m_sY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, 0, 0, -1, false, false) == false) {
			// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Summon Demon", m_pClientList[iClientH]->m_cCharName);
			PutAdminLogFileList(G_cTxt);
		}
	}

}
void CGame::AdminOrder_SummonDeath(int iClientH)
{
	char cName[21], cNpcName[21], cNpcWaypoint[11];	
	int iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == false) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonDeath) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
	}
	else {
		// NPC¸¦ »ý¼ºÇÑ´Ù.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Wyvern");	

		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;

		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)m_pClientList[iClientH]->m_sX;
		tY = (int)m_pClientList[iClientH]->m_sY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, 0, 0, -1, false, false) == false) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			} 
		else {
			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Summon Death", m_pClientList[iClientH]->m_cCharName);
			PutAdminLogFileList(G_cTxt);
		}
	}

}
// v1.4311-3 Ãß°¡ ¿î¿µÀÚ°¡ »çÅõÀåÀ» ¿¹¾àÇÑ´Ù.
void CGame::AdminOrder_ReserveFightzone(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256];
 class  CStrTok * pStrTok;
 int iNum ;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelReserveFightzone) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if( m_iFightzoneNoForceRecall == 0 ) {
		m_iFightzoneNoForceRecall = 1 ; 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -5, 0, 0, 0);
	} else {
		m_iFightzoneNoForceRecall = 0 ; 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -4, 0, 0, 0);
	}

	if (token == 0) {
		delete pStrTok;
		return;
	}

	iNum = atoi(token) - 1;
			
	if ( m_iFightZoneReserve[iNum] != -1) {
		// Admin Log
		wsprintf(G_cTxt, "Admin Order(%s):  %d FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		PutAdminLogFileList(G_cTxt);
		
		m_iFightZoneReserve[iNum] = - 1 ;        // ¿î¿µÀÚ°¡ ¿¹¾àÇÑ »çÅõÀåÀº -1 °ªÀÌ µé¾î°£´Ù.
												 // ÀÌÁ¦ºÎÅÍ °è¼Ó ´Ù¸¥ À¯Àú´Â ¿¹¾àÀÌ ºÒ°¡´ÉÇÏ´Ù.
		// ¿î¿µÀÚ°¡ »çÅõÀå ¿¹¾à¿¡ ¼º°øÇÏ´Â °æ¿ì 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, iNum+1, 0, 0, 0);
		
	}  else {	// ¿î¿µÀÚ°¡ ¿¹¾àÇÑ »çÅõÀåÀ» ´Ù½Ã ¿¹¾àÇÏ¸é ¿¹¾àÀÌ Ãë¼ÒµÈ´Ù.
		wsprintf(G_cTxt, "Admin Order(%s):  %d Cancel FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		PutAdminLogFileList(G_cTxt);

		m_iFightZoneReserve[iNum] = 0 ;       
		// ¿î¿µÀÚ°¡ »çÅõÀå ¿¹¾àÀ» Ãë¼ÒÇÏ´Â °æ¿ì       -3 °ªÀ» ³Ñ°ÜÁØ´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -3, 0, 0, 0);

	}
		
	return;
}


void CGame::AdminOrder_CloseConn(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGMCloseconn) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != 0) {
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			if (m_pClientList[i]->m_bIsInitComplete ) {
				DeleteClient(i, true, true, true, true);
			}

			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Close Conn", m_pClientList[iClientH]->m_cCharName);
			PutAdminLogFileList(G_cTxt);

			delete pStrTok;
			return;
		}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cTargetName);
	}

	delete pStrTok;
	return;
}



void CGame::UserCommand_BanGuildsman(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iGuildRank != 0 ) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOGUILDMASTERLEVEL, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != 0) {
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) ) {

			if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0)  {
				
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTBANGUILDMAN, 0, 0, 0, 0);
				delete pStrTok;
				return;
			}
			//bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
		
			SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, 0, 0, 0);
	
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1; 
			m_pClientList[i]->m_iGuildGUID = -1;

		    SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUCCESSBANGUILDMAN, 0, 0, 0, 0);
			
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_BANGUILD, 0, 0, 0, 0);
		
			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		
			delete pStrTok;
			return;
		}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cTargetName);
	}

	delete pStrTok;
	return;
}



void CGame::UserCommand_DissmissGuild(int iClientH, char * pData, DWORD dwMsgSize)
{

}

void CGame::RequestCreateNewGuild(int iClientH, char* pData)
{
	char cFileName[255], cData[512];
	char cTxt[500];
	char cTxt2[100];
	char cGuildMasterName[11], cGuildLocation[11], cDir[255], cGuildName[21];
	char* cp;
	DWORD* dwp, dwGuildGUID;
	WORD* wp;
	int iRet;
	SYSTEMTIME SysTime;
	FILE* pFile;

	if (m_pClientList[iClientH] == 0) return;
	ZeroMemory(cFileName, sizeof(cFileName));
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTxt2, sizeof(cTxt2));
	ZeroMemory(cDir, sizeof(cDir));
	ZeroMemory(cData, sizeof(cData));
	ZeroMemory(cGuildMasterName, sizeof(cGuildMasterName));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	ZeroMemory(cGuildLocation, sizeof(cGuildLocation));

	cp = (char*)pData;

	memcpy(cGuildMasterName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	memcpy(cGuildLocation, cp, 10);
	cp += 10;

	dwp = (DWORD*)cp;
	dwGuildGUID = *dwp;
	cp += 4;

	strcat(cFileName, "Guilds");
	strcat(cFileName, "\\");
	wsprintf(cTxt2, "AscII%d", *cGuildName);
	strcat(cFileName, cTxt2);
	strcat(cDir, cFileName);
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cGuildName);
	strcat(cFileName, ".txt");

	_mkdir("Guilds");
	_mkdir(cDir);

	pFile = fopen(cFileName, "rt");
	if (pFile != 0) {
		wsprintf(cTxt2, "(X) Cannot create new guild - Already existing guild name: Name(%s)", cFileName);
		PutLogList(cTxt2);

		ResponseCreateNewGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
		fclose(pFile);
	}
	else {
		pFile = fopen(cFileName, "wt");
		if (pFile == 0) {
			wsprintf(cTxt2, "(X) Cannot create new guild - cannot create file : Name(%s)", cFileName);
			PutLogList(cTxt2);

			ResponseCreateNewGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
		}
		else {
			wsprintf(cTxt2, "(O) New guild created : Name(%s)", cFileName);
			PutLogList(cTxt2);

			ZeroMemory(cTxt2, sizeof(cTxt2));
			ZeroMemory(cTxt, sizeof(cTxt));
			GetLocalTime(&SysTime);

			wsprintf(cTxt, ";Guild file - Updated %4d/%2d/%2d/%2d/%2d", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
			strcat(cTxt, "\n");
			strcat(cTxt, ";Just created\n\n");

			strcat(cTxt, "[GUILD-INFO]\n\n");

			strcat(cTxt, "guildmaster-name     = ");
			strcat(cTxt, cGuildMasterName);
			strcat(cTxt, "\n");

			strcat(cTxt, "guild-GUID           = ");
			wsprintf(cTxt2, "%d", dwGuildGUID);
			strcat(cTxt, cTxt2);
			strcat(cTxt, "\n");

			strcat(cTxt, "guild-location       = ");
			strcat(cTxt, cGuildLocation);
			strcat(cTxt, "\n\n");

			strcat(cTxt, "[GUILDSMAN]\n\n");

			fwrite(cTxt, 1, strlen(cTxt), pFile);

			ResponseCreateNewGuildHandler(cGuildMasterName, 1); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
			fclose(pFile);
		}
	}
	/*switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, 0);
		delete m_pClientList[iClientH];
		m_pClientList[iClientH] = 0;
		return;
	}*/
}

void CGame::RequestDisbandGuild(int iClientH, char* pData)
{
	char cTemp[500];
	DWORD* dwp;
	WORD* wp;
	char* cp;
	char cFileName[255], cTxt[100], cDir[100];
	char cGuildMasterName[11], cGuildName[21];
	int iRet;
	FILE* pFile;

	if (m_pClientList[iClientH] == 0) return;
	ZeroMemory(cFileName, sizeof(cFileName));
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cDir, sizeof(cDir));
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cGuildMasterName, sizeof(cGuildMasterName));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp = (char*)(pData);
	memcpy(cGuildMasterName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	strcat(cFileName, "Guilds");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	wsprintf(cTxt, "AscII%d", *cGuildName);
	strcat(cFileName, cTxt);
	strcat(cDir, cFileName);
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cGuildName);
	strcat(cFileName, ".txt");

	pFile = fopen(cFileName, "rt");
	if (pFile != 0) {
		fclose(pFile);
		wsprintf(G_cTxt, "(O) Disband Guild - Deleting guild file... : Name(%s)", cFileName);
		PutLogList(G_cTxt);
		if (DeleteFile(cFileName) != 0) {
			ResponseDisbandGuildHandler(cGuildMasterName, 1); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16, DEF_USE_ENCRYPTION);
		}
		else {

			ResponseDisbandGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16, DEF_USE_ENCRYPTION);
		}
	}
	else {

		ResponseDisbandGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16, DEF_USE_ENCRYPTION);
	}

	/*switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, 0);
		delete m_pClientList[iClientH];
		m_pClientList[iClientH] = 0;
		return;
	}*/
}


int CGame::iCreateFish(char cMapIndex, short sX, short sY, short sType, class CItem * pItem, int iDifficulty, DWORD dwLastTime)
{
 int i, iDynamicHandle;

	// ¸ÊÀÇ À§Ä¡°¡ ¹°ÀÎÁö È®ÀÎÇÑ´Ù. 
	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == 0) return 0;
	if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == false) return 0;

	for (i = 1; i < DEF_MAXFISHS; i++) 
	if (m_pFish[i] == 0) {
		// ºó °ø°£¿¡ ¹°°í±â¸¦ ¸¸µç´Ù.
		m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
		if (m_pFish[i] == 0) return 0;
 		
		// Dynamic Object¸¦ ¹ß»ý½ÃÅ²´Ù. Owner¿¡ Fish ÀÎµ¦½º¸¦ ³Ö´Â´Ù.
		switch (pItem->m_sIDnum) {
		case 101: // »¡°­¹°°í±â
		case 102: // ÃÊ·Ï¹°°í±â
		case 103: // ³ë¶û¹°°í±â
		case 570:
		case 571:
		case 572:
		case 573:
		case 574:
		case 575:
		case 576:
		case 577:	
			iDynamicHandle = iAddDynamicObjectList(i, 0, DEF_DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
			break;
		default: 
			// ¹°°í±â°¡ ¾Æ´Ñ ´Ù¸¥ ¾ÆÀÌÅÛ 
			iDynamicHandle = iAddDynamicObjectList(i, 0, DEF_DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
			break;
		}
		
		if (iDynamicHandle == 0) {
			delete m_pFish[i];
			m_pFish[i] = 0;
			return 0;
		}
		m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMapList[cMapIndex]->m_iCurFish++;

		return i;
	}

	return 0;
}


bool CGame::bDeleteFish(int iHandle, int iDelMode)
{
 int i, iH;
 DWORD dwTime;
		
	if (m_pFish[iHandle] == 0) return false;
	
	dwTime = timeGetTime();

	// ¿¬°üµÇ¾î ÀÖ´Â DynamicObject¸¦ »èÁ¦ÇÑ´Ù.
	iH = m_pFish[iHandle]->m_sDynamicObjectHandle;
	
	if (m_pDynamicObjectList[iH] != 0) {
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, 0, (short)0);
		// ¸Ê¿¡¼­ »èÁ¦ÇÑ´Ù.
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;

		delete m_pDynamicObjectList[iH];
		m_pDynamicObjectList[iH] = 0;
	}

	// ÀÌ ¹°°í±â¿Í ¿¬°áµÇ¾î ÀÖ´Â ÇÃ·¹ÀÌ¾îµé¿¡°Ô ¹°°í±â°¡ »ç¶óÁ® ³¬½Ã°¡ Ãë¼ÒµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete ) &&
			(m_pClientList[i]->m_iAllocatedFish == iHandle)) {
			// ¸Þ½ÃÁö Àü¼Û 
			SendNotifyMsg(0, i, DEF_NOTIFY_FISHCANCELED, iDelMode, 0, 0, 0);
			ClearSkillUsingStatus(i); // v1.4 ³¬½Ã ½ºÅ³À» Å¬¸®¾îÇÑ´Ù.
 		}
	}
	
	// »èÁ¦ÇÑ´Ù.
	delete m_pFish[iHandle];
	m_pFish[iHandle] = 0;

	return true;
}


int CGame::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{
 int i;
 short sDistX, sDistY;

	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((cMapIndex < 0)	|| (cMapIndex >= DEF_MAXMAPS)) return 0;

	// ¸ÊÀÇ Æ¯Á¤ À§Ä¡ ³»¿¡ ¹°°í±â ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ®°¡ ÀÖ´ÂÁö ÆÇ´ÜÇÑ´Ù. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != 0) {
		sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
		sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);
		
		if ((m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) && 
			((m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISH) || (m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISHOBJECT)) &&
			(sDistX <= 2) && (sDistY <= 2)) {
			// ¹°°í±â ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ®¸¦ Ã£¾Ò´Ù. ÀÌÁ¦ ÀÌ ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ® ÀÎµ¦½º¸¦ ¼ÒÀ¯ÇÑ FishÀÇ ÀÎµ¦½º¸¦ ¹ÝÈ¯ÇÑ´Ù. 

			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ] == 0) return 0;
			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount >= DEF_MAXENGAGINGFISH) return 0;

			// ÀÌ¹Ì ³¬½Ã¸ðµå¿¡ µé¾î°¡ ÀÖ´Â Ä³¸¯ÅÍ´Â Áßº¹ µ¿ÀÛÀÌ ºÒ°¡´É.
			if (m_pClientList[iClientH]->m_iAllocatedFish != 0) return 0;
			if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
			// ÀÌÁ¦ Ä³¸¯ÅÍ¿¡°Ô ³¬½Ã ¸ðµå¸¦ ½ÃÀÛÇÒ °ÍÀ» ÇÒ´çÇÑ´Ù.
			m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
			m_pClientList[iClientH]->m_iFishChance = 1;
			// ÀÌ Ä³¸¯ÅÍ´Â ³¬½Ã ½ºÅ³À» »ç¿ëÁßÀÓÀ» ¼³Á¤.
			m_pClientList[iClientH]->m_bSkillUsingStatus[1] = true;

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_EVENTFISHMODE, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice/2), m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite,
				          m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);

			// Ä«¿îÆ® Áõ°¡ 
			m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount++;
			
			return i;
		}
	}

	return 0;
}

void CGame::FishProcessor()
{
 int i, iSkillLevel, iResult, iChangeValue;

	// ̺Ʈ  尡 Ҵ ÷̾ óѴ.
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete ) && 
			(m_pClientList[i]->m_iAllocatedFish != 0)) {
		
			if (m_pFish[ m_pClientList[i]->m_iAllocatedFish ] == 0) break;	
	
			//  ÷̾ Ҵ Ⱑ ִ.  Ȯ Ͽ 뺸 ش. 
			//   ų 
			iSkillLevel  = m_pClientList[i]->m_cSkillMastery[1];
			//  ̵  ų  . 
			iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
			if (iSkillLevel <= 0) iSkillLevel = 1;
			
			iChangeValue = iSkillLevel / 10;
			if (iChangeValue <= 0) iChangeValue = 1;
			iChangeValue = iDice(1, iChangeValue);

			iResult = iDice(1, 100);
			if (iSkillLevel > iResult)	{
				// ų ֻ  .  Ȯ .
				m_pClientList[i]->m_iFishChance += iChangeValue;
				if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;

				SendNotifyMsg(0, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, 0, 0, 0);
			}
			else if (iSkillLevel < iResult) {
				// ų ֻ  .  Ȯ .	
				m_pClientList[i]->m_iFishChance -= iChangeValue;
				if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;

				SendNotifyMsg(0, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, 0, 0, 0);
			}
		}
	}
}

void CGame::AdminOrder_CreateFish(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cItemName[21];
 class  CStrTok * pStrTok;
 class  CItem   * pItem;
 int tX, tY, iType;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCreateFish) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	tX = tY = iType = 0;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != 0) {
		tX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != 0) {
		tY = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != 0) {
		iType = atoi(token);
	}

	if ((tX != 0) && (tY != 0) && (iType != 0)) {
		// ÀÌ ÁÂÇ¥¿¡ ¹°°í±â¸¦ ¸¸µç´Ù.
		pItem = new class CItem;
		if (pItem == 0) {
			delete pStrTok;
			return;
		}
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, "¹°°í±â");
		if (_bInitItemAttr(pItem, cItemName) ) {
   			iCreateFish(m_pClientList[iClientH]->m_cMapIndex, tX, tY, iType, pItem, 1, 60000*20);
		}
		else delete pItem;
   	}

	delete pStrTok;
	return;
}

void CGame::AdminOrder_Teleport(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256];
 class  CStrTok * pStrTok;
 int dX, dY;
 bool   bFlag;

	dX = dY = -1;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelTeleport) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != 0) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != 0) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != 0) {
		dY = atoi(token);
	}

	bFlag = false;
	if (strcmp("2ndmiddle", cMapName) == 0) bFlag = true;
	if (strcmp("abaddon", cMapName) == 0) bFlag = true; 
	if (strcmp("arebrk11", cMapName) == 0) bFlag = true;
	if (strcmp("arebrk12", cMapName) == 0) bFlag = true;
	if (strcmp("arebrk21", cMapName) == 0) bFlag = true;
	if (strcmp("arebrk22", cMapName) == 0) bFlag = true;
	if (strcmp("arefarm", cMapName) == 0) bFlag = true;
	if (strcmp("arejail", cMapName) == 0) bFlag = true;
	if (strcmp("aremidl", cMapName) == 0) bFlag = true;
	if (strcmp("aremidr", cMapName) == 0) bFlag = true;
	if (strcmp("aresden", cMapName) == 0) bFlag = true;
	if (strcmp("aresdend1", cMapName) == 0) bFlag = true;
	if (strcmp("areuni", cMapName) == 0) bFlag = true;
	if (strcmp("arewrhus", cMapName) == 0) bFlag = true;
	if (strcmp("bisle", cMapName) == 0)   bFlag = true;
	if (strcmp("bsmith_1", cMapName) == 0) bFlag = true;
	if (strcmp("bsmith_1f", cMapName) == 0) bFlag = true;
	if (strcmp("bsmith_2", cMapName) == 0) bFlag = true;
	if (strcmp("bsmith_2f", cMapName) == 0) bFlag = true;
	if (strcmp("BtField", cMapName) == 0) bFlag = true;
	if (strcmp("cath_1", cMapName) == 0) bFlag = true;
	if (strcmp("cath_2", cMapName) == 0)      bFlag = true;
	if (strcmp("cityhall_1", cMapName) == 0) bFlag = true;
	if (strcmp("cityhall_2", cMapName) == 0) bFlag = true;
	if (strcmp("CmdHall_1", cMapName) == 0) bFlag = true;
	if (strcmp("CmdHall_2", cMapName) == 0) bFlag = true;
	if (strcmp("default", cMapName) == 0) bFlag = true;
	if (strcmp("dglv2", cMapName) == 0) bFlag = true;
	if (strcmp("dglv3", cMapName) == 0) bFlag = true;
	if (strcmp("dglv4", cMapName) == 0) bFlag = true;
	if (strcmp("druncncity", cMapName) == 0) bFlag = true; 
	if (strcmp("elvbrk11", cMapName) == 0) bFlag = true;
	if (strcmp("elvbrk12", cMapName) == 0) bFlag = true;
	if (strcmp("elvbrk21", cMapName) == 0) bFlag = true;
	if (strcmp("elvbrk22", cMapName) == 0) bFlag = true;
	if (strcmp("elvfarm", cMapName) == 0) bFlag = true;
	if (strcmp("elvine", cMapName) == 0)  bFlag = true;
	if (strcmp("elvined1", cMapName) == 0)    bFlag = true;
	if (strcmp("elvjail", cMapName) == 0)    bFlag = true;
	if (strcmp("elvmidl", cMapName) == 0) bFlag = true;
	if (strcmp("elvmidr", cMapName) == 0) bFlag = true;
	if (strcmp("elvuni", cMapName) == 0) bFlag = true;
	if (strcmp("elvwrhus", cMapName) == 0) bFlag = true;
	if (strcmp("fightzone1", cMapName) == 0) bFlag = true;
	if (strcmp("fightzone2", cMapName) == 0) bFlag = true;
	if (strcmp("fightzone3", cMapName) == 0) bFlag = true;
	if (strcmp("fightzone4", cMapName) == 0) bFlag = true;
	if (strcmp("fightzone5", cMapName) == 0) bFlag = true;
	if (strcmp("fightzone6", cMapName) == 0) bFlag = true;
	if (strcmp("fightzone7", cMapName) == 0) bFlag = true;
	if (strcmp("fightzone8", cMapName) == 0) bFlag = true;
	if (strcmp("fightzone9", cMapName) == 0) bFlag = true;
	if (strcmp("fightzone10", cMapName) == 0) bFlag = true;
	if (strcmp("gldhall_1", cMapName) == 0) bFlag = true;
	if (strcmp("gldhall_2", cMapName) == 0)   bFlag = true;
	if (strcmp("GodH", cMapName) == 0)   bFlag = true;
	if (strcmp("gshop_1", cMapName) == 0) bFlag = true;
	if (strcmp("gshop_1f", cMapName) == 0) bFlag = true;
	if (strcmp("gshop_2", cMapName) == 0)     bFlag = true;
	if (strcmp("gshop_2f", cMapName) == 0)     bFlag = true;
	if (strcmp("HRampart", cMapName) == 0)     bFlag = true;
	if (strcmp("huntzone1", cMapName) == 0) bFlag = true;
	if (strcmp("huntzone2", cMapName) == 0) bFlag = true;
	if (strcmp("huntzone3", cMapName) == 0) bFlag = true;
	if (strcmp("huntzone4", cMapName) == 0) bFlag = true;
	if (strcmp("icebound", cMapName) == 0) bFlag = true; 
	if (strcmp("inferniaA", cMapName) == 0) bFlag = true; 
	if (strcmp("inferniaB", cMapName) == 0) bFlag = true; 
	if (strcmp("maze", cMapName) == 0) bFlag = true; 
	if (strcmp("middled1n", cMapName) == 0) bFlag = true;
	if (strcmp("middled1x", cMapName) == 0) bFlag = true;
	if (strcmp("middleland", cMapName) == 0) bFlag = true;
	if (strcmp("penalty", cMapName) == 0) bFlag = true;
	if (strcmp("procella", cMapName) == 0) bFlag = true;
	if (strcmp("resurr1", cMapName) == 0) bFlag = true;
	if (strcmp("resurr2", cMapName) == 0) bFlag = true;
	if (strcmp("toh1", cMapName) == 0) bFlag = true;
	if (strcmp("toh2", cMapName) == 0) bFlag = true;
	if (strcmp("toh3", cMapName) == 0) bFlag = true;
	if (strcmp("wrhus_1", cMapName) == 0) bFlag = true;
	if (strcmp("wrhus_1f", cMapName) == 0) bFlag = true;
	if (strcmp("wrhus_2", cMapName) == 0)     bFlag = true;
	if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = true;
	if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = true;
	if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = true;
	if (strcmp("Test", cMapName) == 0) bFlag = true;
	if (strcmp("GMMap", cMapName) == 0) bFlag = true;
	if (strcmp("dv", cMapName) == 0) bFlag = true;
	if (strcmp("HBX", cMapName) == 0) bFlag = true;

	if (bFlag )
		RequestTeleportHandler(iClientH, "2   ", cMapName, dX, dY);
   	
	delete pStrTok;
	return;
}


void CGame::ReqGetFishThisTimeHandler(int iClientH)
{
 int iResult, iFishH;
 class CItem * pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iAllocatedFish == 0) return;
	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == 0) return;

	//  ų  Ų.
	m_pClientList[iClientH]->m_bSkillUsingStatus[1] = false;

	iResult = iDice(1, 100);
	if (m_pClientList[iClientH]->m_iFishChance >= iResult) {
		//  ⸦ µ Ͽ!
		
		// ġ  
		GetExp(iClientH, iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5)); //m_pClientList[iClientH]->m_iExpStock += iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5);
		// ų  
		CalculateSSN_SkillIndex(iClientH, 1, m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty);

		//  ͸ ´.
		pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = 0;

		//   ٴڿ ߸.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                       m_pClientList[iClientH]->m_sY, 
															       pItem);

		// ٸ Ŭ̾Ʈ    ˸. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			                        pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color

		//   ޽  
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FISHSUCCESS, 0, 0, 0, 0);
		iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
		m_pClientList[iClientH]->m_iAllocatedFish = 0;
				
		// ⸦   
		bDeleteFish(iFishH, 1); // <- ⼭ ٸ ò۵鿡 ޽ ۵ ̴.
		return;
	}

	// µ ! 
	m_pFish[ m_pClientList[iClientH]->m_iAllocatedFish ]->m_sEngagingCount--;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_FISHFAIL, 0, 0, 0, 0);
	
	m_pClientList[iClientH]->m_iAllocatedFish = 0;
}


void CGame::FishGenerator() 
{ 
 int i, iP, tX, tY, iRet; 
 char  cItemName[21]; 
 short sDifficulty; 
 DWORD dwLastTime; 
 class CItem * pItem; 

	for (i = 0; i < DEF_MAXMAPS; i++) { 
		if ((iDice(1,10) == 5) && (m_pMapList[i] != 0) && 
			(m_pMapList[i]->m_iCurFish < m_pMapList[i]->m_iMaxFish)) { 
    
			iP = iDice(1, m_pMapList[i]->m_iTotalFishPoint) - 1; 
			if ((m_pMapList[i]->m_FishPointList[iP].x == -1) || (m_pMapList[i]->m_FishPointList[iP].y == -1)) break; 

			tX = m_pMapList[i]->m_FishPointList[iP].x + (iDice(1,3) - 2); 
			tY = m_pMapList[i]->m_FishPointList[iP].y + (iDice(1,3) - 2); 

			pItem = new class CItem; 
			if (pItem == 0) break; 
                   
			// ¸¸µé ¹°°í±â Á¾·ù¿Í ³­ÀÌµµ, Áö¼Ó ½Ã°£À» °áÁ¤ÇÑ´Ù. 
			ZeroMemory(cItemName, sizeof(cItemName)); 
			switch (iDice(1,9)) { 
			case 1:   strcpy(cItemName, "RedCarp"); sDifficulty = iDice(1,10) + 20; break; 
			case 2:   strcpy(cItemName, "GreenCarp"); sDifficulty = iDice(1,5)  + 10; break; 
			case 3:   strcpy(cItemName, "GoldCarp"); sDifficulty = iDice(1,10) + 1;  break; 
			case 4:   strcpy(cItemName, "CrucianCarp"); sDifficulty = 1;  break;    
			case 5:   strcpy(cItemName, "BlueSeaBream"); sDifficulty = iDice(1,15) + 1;  break; 
			case 6:   strcpy(cItemName, "RedSeaBream"); sDifficulty = iDice(1,18) + 1;  break; 
			case 7:   strcpy(cItemName, "Salmon"); sDifficulty = iDice(1,12) + 1;  break; 
			case 8:   strcpy(cItemName, "GrayMullet"); sDifficulty = iDice(1,10) + 1;  break; 
			case 9: 
				// °¡²û °¡´Ù ³¬À» ¼ö ÀÖ´Â Æ¯¼ö ¾ÆÀÌÅÛ 
				switch (iDice(1,150)) { 
				case 1: 
				case 2: 
				case 3: 
					strcpy(cItemName, "PowerGreenPotion"); 
					sDifficulty = iDice(5,4) + 30; 
					break; 

				case 10: 
				case 11: 
					strcpy(cItemName, "SuperPowerGreenPotion"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 20: 
					strcpy(cItemName, "Dagger+2"); 
					sDifficulty = iDice(5,4) + 30; 
					break; 

				case 30: 
					strcpy(cItemName, "LongSword+2"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 

				case 40: 
					strcpy(cItemName, "Scimitar+2"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 50: 
					strcpy(cItemName, "Rapier+2"); 
					sDifficulty = iDice(5,4) + 60; 
					break; 

				case 60: 
					strcpy(cItemName, "Flameberge+2"); 
					sDifficulty = iDice(5,4) + 60; 
					break; 

				case 70: 
					strcpy(cItemName, "WarAxe+2"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 90: 
					strcpy(cItemName, "Ruby"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 

				case 95: 
					strcpy(cItemName, "Diamond"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 
				} 
			break; 
			} 
			dwLastTime  = (60000 * 10) + (iDice(1,3) - 1)*(60000 * 10); 

			if (_bInitItemAttr(pItem, cItemName) ) { 
				iRet = iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime); 
			} 
			else { 
				delete pItem; 
				pItem = 0; 
			} 
		} 
	}                                         
}


int CGame::_iCalcPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{
 int ix, iy, iRet;
 class CTile * pTile;	

	// Ã³¸® ¼Óµµ¸¦ ³ôÀÌ±â À§ÇØ ÇÔ¼ö¸¦ ÄÝÇÏÁö ¾Ê´Â´Ù.
	if ((cMapIndex < 0)	|| (cMapIndex > DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == 0) return 0;

	iRet = 0;
	for (ix = dX - cRadius; ix <= dX + cRadius; ix++)
	for (iy = dY - cRadius; iy <= dY + cRadius; iy++) {
		if ( (ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			 (iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY) ) {
			// ÁÂÇ¥¸¦ ¹þ¾î³ª¹Ç·Î Ã³¸®ÇÏÁö ¾Ê´Â´Ù.	
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_sOwner != 0) && (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER))
				iRet++;
		}
	}

	return iRet;
}


void CGame::WhetherProcessor()
{
char cPrevMode;
int i, j;
DWORD dwTime;

	dwTime = timeGetTime();

	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((m_pMapList[i] != 0) && (m_pMapList[i]->m_bIsFixedDayMode == false)) {
			cPrevMode = m_pMapList[i]->m_cWhetherStatus;
			if (m_pMapList[i]->m_cWhetherStatus != 0) {
				if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
					m_pMapList[i]->m_cWhetherStatus = 0;
				}
				else {
					if (iDice(1,300) == 13) {
						m_pMapList[i]->m_cWhetherStatus = iDice(1,3); //This looks better or else we only get snow :(
						//m_pMapList[i]->m_cWhetherStatus = iDice(1,3)+3; <- This original code looks fucked
						m_pMapList[i]->m_dwWhetherStartTime = dwTime;
						m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
					}
				}

			if (m_pMapList[i]->m_bIsSnowEnabled ) {
				m_pMapList[i]->m_cWhetherStatus = iDice(1,3)+3;
				m_pMapList[i]->m_dwWhetherStartTime = dwTime;
				m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
			}

			if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) {
				for (j = 1; j < DEF_MAXCLIENTS; j++) 
					if ((m_pClientList[j] != 0) && (m_pClientList[j]->m_bIsInitComplete ) && (m_pClientList[j]->m_cMapIndex == i)) 
						SendNotifyMsg(0, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, 0, 0, 0);
			}
		} //If
	} //for Loop
}


void CGame::FightzoneReserveProcessor()
{
}

/*********************************************************************************************************************
**  int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)										**
**  description			:: checks for a weather bonus when magic is cast											**
**  last updated		:: November 20, 2004; 10:34 PM; Hypnotoad													**
**	return value		:: int																						**
*********************************************************************************************************************/
int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)
{
 int iWheatherBonus;

	iWheatherBonus = 0;
	switch (cWheatherStatus) {
	case 0: break;
	case 1:
	case 2:
	case 3:
		switch (sType) {
		case 10:
		case 37:
		case 43:
		case 51:
			iWheatherBonus = 1;
			break;

		case 20:
		case 30:
			iWheatherBonus = -1;
			break;
		}
   		break;
	}
	return iWheatherBonus;
}


int CGame::iGetPlayerRelationship(int iClientH, int iOpponentH)
{
 int iRet;
	
	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if (m_pClientList[iOpponentH] == 0) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == false) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// º»ÀÎÀÌ ¹üÁËÀÚÀÌÇÏ¸é »ó´ë¹æÀÌ ¸¶À»ÀÌ °°Àº °æ¿ì À§Çù. ´Ù¸£¸é Àû 
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) && (memcmp(m_pClientList[iOpponentH]->m_cLocation, "NONE", 4) != 0)) {
			 iRet = 7; // À§Çù 
		}
		else iRet = 2; // Àû   
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// »ó´ë¹æÀÌ ¹üÁËÀÚÀÌÇÏ¸é
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0)) 
			 iRet = 6; // ¸¶À»ÀÌ °°À¸¸é PK
		else iRet = 2; // ´Ù¸£¸é ±×³É Àû 
	}
	else {
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[iOpponentH]->m_cSide != 0)) {
				// µÑ ´Ù 0(Traveler)ÀÌ ¾Æ´Ï¸é ÀûÀÌ´Ù.
				iRet = 2;
			}
			else {
				iRet = 0;
			}
		}	
		else {
			// ¾Æ±ºÀÌ´Ù. ±æµå¿ø¿©ºÎ¸¦ ÆÇ´Ü.
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) ) {
				// ±æµå ÀÌ¸§ÀÌ °°´Ù. 
				if (m_pClientList[iOpponentH]->m_iGuildRank == 0)
					 iRet = 5;	// ±æµå ·©Å©°¡ 0. ±æµå¸¶½ºÅÍÀÌ´Ù.
				else iRet = 3;	// °°Àº ±æµå¿ø
			}
			else 
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
				// ±æµå À§Ä¡´Â °°°í ±æµå ÀÌ¸§ÀÌ ´Ù¸£´Ù.
				iRet = 4; // ´Ù¸¥ ±æµå¿ø 
			}
			else iRet = 1; // ±×³É °°ÀºÆí 
		}
	}

	return iRet;
}

int CGame::iGetPlayerABSStatus(int iWhatH, int iRecvH)
{
	int iRet;

	if (m_pClientList[iWhatH] == 0) return 0;
	if (m_pClientList[iRecvH] == 0) return 0;

	iRet = 0;

	/*if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone  &&
		m_pClientList[iWhatH]->m_iGuildRank != -1 && m_pClientList[iRecvH]->m_iGuildRank != -1 &&
		memcmp(m_pClientList[iWhatH]->m_cGuildName,m_pClientList[iRecvH]->m_cGuildName,20) != 0) {
			iRet = 8;
		}*/

		if (m_pClientList[iWhatH]->m_iPKCount != 0) {
			iRet = 8;
		}

		if (m_pClientList[iWhatH]->m_cSide != 0) {
			iRet = iRet | 4;
		}

		if (m_pClientList[iWhatH]->m_cSide == 1) {
			iRet = iRet | 2;
		}

		if (m_pClientList[iWhatH]->m_bIsPlayerCivil )
			iRet = iRet | 1;

		return iRet;
}

int CGame::iGetNpcRelationship(int iWhatH, int iRecvH) 
{ 
	int iRet; 

	if (m_pClientList[iRecvH] == 0) return 0; 
	if (m_pNpcList[iWhatH] == 0) return 0; 

	iRet = 0; 
	switch (m_pNpcList[iWhatH]->m_cSide) { 
	case 10: iRet |= 8; //Fixed, Original 15 
	case 1:  iRet = (iRet | 4) | 2; //Fixed, Original 1 
	case 2:  iRet |= 4; //Fixed, Orignal 8 
	} 

	return iRet; 
}

int CGame::iGetNpcRelationship_SendEvent(int iNpcH, int iOpponentH)
{
 int iRet;
	
	if (m_pClientList[iOpponentH] == 0) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == false) return 0;

	if (m_pNpcList[iNpcH] == 0) return 0;

	iRet = 0;

	if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[iOpponentH]->m_cSide)
			 iRet = 7; 
		else iRet = 2;
	}
	else {
		if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			if (m_pNpcList[iNpcH]->m_cSide == 10) 
				iRet = 2;
			else 
			if (m_pNpcList[iNpcH]->m_cSide == 0) iRet = 0;
			else 
			if (m_pClientList[iOpponentH]->m_cSide == 0) 
				 iRet = 0; 
			else iRet = 2; 
			
		}
		else iRet = 1; // °°Àº Æí 
	}

	return iRet;
}


int CGame::iGetMapIndex(char * pMapName)
{
 int i, iMapIndex;
 char cTmpName[256];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);

	iMapIndex = -1;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != 0) {
		if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0) 
			iMapIndex = i;
	}

	return iMapIndex;
}



int CGame::_iForcePlayerDisconect(int iNum)
{
 int i, iCnt;

	iCnt = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != 0) {
		if (m_pClientList[i]->m_bIsInitComplete )
			 DeleteClient(i, true, true);
		else DeleteClient(i, false, false);
		iCnt++;
		if (iCnt >= iNum) break;
	}

	return iCnt;
}

void CGame::SpecialEventHandler()
{
 DWORD dwTime;
 
	// Æ¯º°ÇÑ ÀÌº¥Æ®¸¦ »ý¼ºÇÑ´Ù. 
	dwTime = timeGetTime();

	if ((dwTime - m_dwSpecialEventTime) < DEF_SPECIALEVENTTIME) return; // DEF_SPECIALEVENTTIME
	m_dwSpecialEventTime  = dwTime;
	m_bIsSpecialEventTime = true;
	
	switch (iDice(1,180)) {
	case 98: m_cSpecialEventType = 2; break; // µ¥¸ó È¤Àº À¯´ÏÄÜÀÌ ³ª¿Ã °¡´É¼ºÀº 30ºÐ¿¡ 1¹ø 1/30
	default: m_cSpecialEventType = 1; break;
	}
}

void CGame::AdminOrder_CheckIP(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cIP[21], cInfoString[500];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCheckIP) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != 0) {
		// tokenÀÌ IP addressÀÌ´Ù. 
		ZeroMemory(cIP, sizeof(cIP));
		strcpy(cIP, token);

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cIPaddress, cIP, strlen(cIP)) == 0)) {
			// ¿ä±¸ÇÑ ÁÖ¼Ò¿Í ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ® ¹ß°ß. 
			ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "Name(%s/%s) Loc(%s: %d %d) Level(%d:%d) Init(%d) IP(%s)", 
				     m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName, 
					 m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 
					 m_pClientList[i]->m_iLevel, 0/*m_pClientList[i]->m_cAccountStatus*/,
					 m_pClientList[i]->m_bIsInitComplete, m_pClientList[i]->m_cIPaddress);

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_IPACCOUNTINFO, 0, 0, 0, cInfoString);
		}
	}

	
	delete pStrTok;
}

void CGame::ToggleSafeAttackModeHandler(int iClientH) //v1.1
{
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled ) return;

	// ¾ÈÀü °ø°Ý ¸ðµå¸¦ Åä±ÛÇÑ´Ù. 
	if (m_pClientList[iClientH]->m_bIsSafeAttackMode ) 
		 m_pClientList[iClientH]->m_bIsSafeAttackMode = false;
	else m_pClientList[iClientH]->m_bIsSafeAttackMode = true;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SAFEATTACKMODE, 0, 0, 0, 0);
}

void CGame::NpcRequestAssistance(int iNpcH)
{
 int ix, iy, sX, sY;
 short sOwnerH;
 char  cOwnerType;
	
	// iNpc ±Ù¹æ¿¡ ÀÖ´Â ÀüÅõÁßÀÌ ¾Æ´Ñ NPC¿¡°Ô µµ¿òÀ» ¿äÃ»ÇÑ´Ù. 
	if (m_pNpcList[iNpcH] == 0) return;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	for (ix = sX - 8; ix <= sX + 8; ix++)
	for (iy = sY - 8; iy <= sY + 8; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != 0) && (m_pNpcList[sOwnerH] != 0) && (cOwnerType == DEF_OWNERTYPE_NPC) && 
			(iNpcH != sOwnerH) && (m_pNpcList[sOwnerH]->m_cSide == m_pNpcList[iNpcH]->m_cSide) &&
			(m_pNpcList[sOwnerH]->m_bIsPermAttackMode == false) && (m_pNpcList[sOwnerH]->m_cBehavior == DEF_BEHAVIOR_MOVE)) {
			
			// Á¶°Ç¿¡ ºÎÇÕÇÏ´Â NPC¸¦ Ã£¾Ò´Ù. 
			m_pNpcList[sOwnerH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[sOwnerH]->m_iTargetIndex = m_pNpcList[iNpcH]->m_iTargetIndex;
			m_pNpcList[sOwnerH]->m_cTargetType  = m_pNpcList[iNpcH]->m_cTargetType;

			return;
		}
	}
}

void CGame::ForceDisconnectAccount(char *pAccountName, WORD wCount)
{
 int i;

	// Áßº¹µÈ °èÁ¤À» °®°íÀÖ´Â Ä³¸¯ÅÍ¸¦ »èÁ¦ÇÑ´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cAccountName, pAccountName, 10) == 0)) {
		wsprintf(G_cTxt, "<%d> Force disconnect account: CharName(%s) AccntName(%s) Count(%d)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, wCount);
		PutLogList(G_cTxt);
		
		// v1.42 Ä«¿îÆÃ ÇÃ·¡±×¸¦ È°¼ºÈ­ ÇØ¾ß ÇÑ´Ù. 
		//DeleteClient(i, true, true);

		//v1.4312
		SendNotifyMsg(0, i, DEF_NOTIFY_FORCEDISCONN, wCount, 0, 0, 0);
	}
}

void CGame::AdminOrder_Polymorph(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelPolymorph) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != 0) {
		if (memcmp(token, "off", 3) == 0)
			m_pClientList[iClientH]->m_sType = m_pClientList[iClientH]->m_sOriginalType;

		else if (memcmp(token, "Slime", 5) == 0)
			m_pClientList[iClientH]->m_sType = 10;

		else if (memcmp(token, "Skeleton", 8) == 0)
			m_pClientList[iClientH]->m_sType = 11;

		else if (memcmp(token, "Stone-Golem", 11) == 0)
			m_pClientList[iClientH]->m_sType = 12;

		else if (memcmp(token, "Cyclops", 7) == 0)
			m_pClientList[iClientH]->m_sType = 13;

		else if (memcmp(token, "Orc", 3) == 0)
			m_pClientList[iClientH]->m_sType = 14;

		else if (memcmp(token, "ShopKeeper", 10) == 0)
			m_pClientList[iClientH]->m_sType = 15;

		else if (memcmp(token, "Giant-Ant", 9) == 0)
			m_pClientList[iClientH]->m_sType = 16;

		else if (memcmp(token, "Scorpion", 8) == 0)
			m_pClientList[iClientH]->m_sType = 17;

		else if (memcmp(token, "Zombie", 6) == 0)
			m_pClientList[iClientH]->m_sType = 18;

		else if (memcmp(token, "Gandlf", 6) == 0)
			m_pClientList[iClientH]->m_sType = 19;

		else if (memcmp(token, "Howard", 6) == 0)
			m_pClientList[iClientH]->m_sType = 20;

		else if (memcmp(token, "Gaurd", 5) == 0)
			m_pClientList[iClientH]->m_sType = 21;

		else if (memcmp(token, "Amphis", 6) == 0)
			m_pClientList[iClientH]->m_sType = 22;

		else if (memcmp(token, "Clay-Golem", 10) == 0)
			m_pClientList[iClientH]->m_sType = 23;

		else if (memcmp(token, "Tom", 3) == 0)
			m_pClientList[iClientH]->m_sType = 24;

		else if (memcmp(token, "William", 7) == 0)
			m_pClientList[iClientH]->m_sType = 25;

		else if (memcmp(token, "Kennedy", 7) == 0)
			m_pClientList[iClientH]->m_sType = 26;

		else if (memcmp(token, "Hellbound", 9) == 0)
			m_pClientList[iClientH]->m_sType = 27;

		else if (memcmp(token, "Troll", 5) == 0)
			m_pClientList[iClientH]->m_sType = 28;

		else if (memcmp(token, "Orge", 4) == 0)
			m_pClientList[iClientH]->m_sType = 29;

		else if (memcmp(token, "Liche", 5) == 0)
			m_pClientList[iClientH]->m_sType = 30;

		else if (memcmp(token, "Demon", 5) == 0)
			m_pClientList[iClientH]->m_sType = 31;

		else if (memcmp(token, "Unicorn", 7) == 0)
			m_pClientList[iClientH]->m_sType = 32;

		else if (memcmp(token, "WereWolf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 33;

		else if (memcmp(token, "Dummy", 5) == 0)
			m_pClientList[iClientH]->m_sType = 34;

		else if (memcmp(token, "Energy-Sphere", 13) == 0)
			m_pClientList[iClientH]->m_sType = 35;

		else if (memcmp(token, "AGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 36;

		else if (memcmp(token, "CGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 37;

		else if (memcmp(token, "MS", 2) == 0)
			m_pClientList[iClientH]->m_sType = 38;

		else if (memcmp(token, "DT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 39;

		else if (memcmp(token, "ESG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 40;

		else if (memcmp(token, "GMG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 41;

		else if (memcmp(token, "ManaStone", 9) == 0)
			m_pClientList[iClientH]->m_sType = 42;

		else if (memcmp(token, "LWB", 3) == 0)
			m_pClientList[iClientH]->m_sType = 43;

		else if (memcmp(token, "GHK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 44;

		else if (memcmp(token, "GHC", 6) == 0)
			m_pClientList[iClientH]->m_sType = 45;

		else if (memcmp(token, "TK", 2) == 0)
			m_pClientList[iClientH]->m_sType = 46;

		else if (memcmp(token, "BG", 2) == 0)
			m_pClientList[iClientH]->m_sType = 47;

		else if (memcmp(token, "Stalker", 7) == 0)
			m_pClientList[iClientH]->m_sType = 48;

		else if (memcmp(token, "Hellclaw", 8) == 0)
			m_pClientList[iClientH]->m_sType = 49;

		else if (memcmp(token, "Tigerworm", 8) == 0)
			m_pClientList[iClientH]->m_sType = 50;

		else if (memcmp(token, "CP", 2) == 0)
			m_pClientList[iClientH]->m_sType = 51;

		else if (memcmp(token, "Gagoyle", 7) == 0)
			m_pClientList[iClientH]->m_sType = 52;

		else if (memcmp(token, "Beholder", 8) == 0)
			m_pClientList[iClientH]->m_sType = 53;

		else if (memcmp(token, "Dark-Elf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 54;

		else if (memcmp(token, "Rabbit", 6) == 0)
			m_pClientList[iClientH]->m_sType = 55;

		else if (memcmp(token, "Cat", 3) == 0)
			m_pClientList[iClientH]->m_sType = 56;

		else if (memcmp(token, "Giant-Frog", 10) == 0)
			m_pClientList[iClientH]->m_sType = 57;

		else if (memcmp(token, "Mountain-Giant", 14) == 0)
			m_pClientList[iClientH]->m_sType = 58;

		else if (memcmp(token, "Ettin", 5) == 0)
			m_pClientList[iClientH]->m_sType = 59;

		else if (memcmp(token, "Cannibal-Plant", 13) == 0)
			m_pClientList[iClientH]->m_sType = 60;

		else if (memcmp(token, "Rudolph", 7) == 0)
			m_pClientList[iClientH]->m_sType = 61;

		else if (memcmp(token, "DireBoar", 8) == 0)
			m_pClientList[iClientH]->m_sType = 62;

		else if (memcmp(token, "Frost", 5) == 0)
			m_pClientList[iClientH]->m_sType = 63;

		else if (memcmp(token, "Crops", 5) == 0)
			m_pClientList[iClientH]->m_sType = 64;

		else if (memcmp(token, "Ice-Golem", 9) == 0)
			m_pClientList[iClientH]->m_sType = 65;

		//else if (memcmp(token, "Wyvern", 6) == 0)
		//	m_pClientList[iClientH]->m_sType = 66;

		else if (memcmp(token, "McGaffin", 8) == 0)
			m_pClientList[iClientH]->m_sType = 67;

		else if (memcmp(token, "Perry", 5) == 0)
			m_pClientList[iClientH]->m_sType = 68;

		else if (memcmp(token, "Devlin", 6) == 0)
			m_pClientList[iClientH]->m_sType = 69;

		else if (memcmp(token, "Barlog", 6) == 0)
			m_pClientList[iClientH]->m_sType = 70;

		else if (memcmp(token, "Centaurus", 9) == 0)
			m_pClientList[iClientH]->m_sType = 71;

		else if (memcmp(token, "Claw-Turtle", 11) == 0)
			m_pClientList[iClientH]->m_sType = 72;

		//else if (memcmp(token, "Fire-Wyvern", 11) == 0)
		//	m_pClientList[iClientH]->m_sType = 73;

		else if (memcmp(token, "Giant-Crayfish", 14) == 0)
			m_pClientList[iClientH]->m_sType = 74;

		else if (memcmp(token, "Giant-Lizard", 12) == 0)
			m_pClientList[iClientH]->m_sType = 75;

		else if (memcmp(token, "Giant-Plant", 11) == 0)
			m_pClientList[iClientH]->m_sType = 76;

		else if (memcmp(token, "MasterMage-Orc", 14) == 0)
			m_pClientList[iClientH]->m_sType = 77;

		else if (memcmp(token, "Minotaurs", 9) == 0)
			m_pClientList[iClientH]->m_sType = 78;

		else if (memcmp(token, "Nizie", 5) == 0)
			m_pClientList[iClientH]->m_sType = 79;

		else if (memcmp(token, "Tentocle", 8) == 0)
			m_pClientList[iClientH]->m_sType = 80;

		//else if (memcmp(token, "Abaddon", 7) == 0)
		//	m_pClientList[iClientH]->m_sType = 81;

		else if (memcmp(token, "Sor", 3) == 0)
			m_pClientList[iClientH]->m_sType = 82;

		else if (memcmp(token, "ATK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 83;

		else if (memcmp(token, "Elf", 3) == 0)
			m_pClientList[iClientH]->m_sType = 84;

		else if (memcmp(token, "DSK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 85;

		else if (memcmp(token, "HBT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 86;

		else if (memcmp(token, "CT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 87;

		else if (memcmp(token, "Bar", 3) == 0)
			m_pClientList[iClientH]->m_sType = 88;

		else if (memcmp(token, "AGC", 3) == 0)
			m_pClientList[iClientH]->m_sType = 89;

		else if (memcmp(token, "Gail", 4) == 0)
			m_pClientList[iClientH]->m_sType = 90;

		else if (memcmp(token, "gate", 4) == 0)
			m_pClientList[iClientH]->m_sType = 91;
	}
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
	delete pStrTok;
}

void CGame::AdminOrder_SetInvi(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetInvis) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != 0) {
		// ÀÌ °ªÀÌ ¹®ÀÚ '1'ÀÌ¸é Åõ¸íÀ¸·Î ¼¼Æ®. '0'ÀÌ¸é ÇØÁ¦ 
		if (token[0] == '1') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
		else
		if (token[0] == '0') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	}

	delete pStrTok;
}

bool CGame::bOnClose()
{
	if (m_bIsServerShutdowned == false) 
		if (MessageBox(0, "Player data not saved! Shutdown server now?", m_cServerName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return true;
		else return false;
	else return true;
		
	return false;
}

void CGame::AdminOrder_SetZerk(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetZerk) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != 0) {
		// ÀÌ °ªÀÌ ¹®ÀÚ '1'ÀÌ¸é Åõ¸íÀ¸·Î ¼¼Æ®. '0'ÀÌ¸é ÇØÁ¦ 


		if (token[0] == '1')
		{
			SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[32]->m_sValue4;
		}
		else
			if (token[0] == '0') SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	}

	delete pStrTok;
}

void CGame::AdminOrder_SetFreeze(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetIce) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != 0) {
		// ÀÌ °ªÀÌ ¹®ÀÚ '1'ÀÌ¸é Åõ¸íÀ¸·Î ¼¼Æ®. '0'ÀÌ¸é ÇØÁ¦ 
		if (token[0] == '1') SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
		else
			if (token[0] == '0') SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	}

	delete pStrTok;
}

// 05/24/2004 - Hypnotoad - Hammer and Wand train to 100% fixed
void CGame::_CheckAttackType(int iClientH, short *spType)
{
	WORD wType;

	if (m_pClientList[iClientH] == 0) return;
	wType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	switch (*spType) {
	case 2:	
		// ÃˆÂ­Â»Ã¬Ã€ÃŒ Â¾Ã¸Â´Ã™Â¸Ã© ÃˆÂ­Â»Ã¬ EffectÂ´Ã‚ Â³Ã–ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
		if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
		// ÃˆÂ° Â°Ã¸Â°ÃÃ€ÃŽÂµÂ¥ Ã€Ã¥Ã‚Ã¸Ã‡Ã‘ Â¹Â«Â±Ã¢Â°Â¡ ÃˆÂ°Ã€ÃŒ Â¾Ã†Â´ÃÂ´Ã™. Ã€ÃÂ¹Ã Â°Ã¸Â°ÃÃ€Â¸Â·ÃŽ Ã€Ã¼ÃˆÂ¯.
		if (wType < 40) *spType = 1;
		break;

	case 20:
		// Â¸Ã‡Â¼Ã• Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100) *spType = 1;
		break;

	case 21: 
		// Â´ÃœÂ°Ã‹ Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100) *spType = 1;
		break;

	case 22: 
		// Ã†Ã¦Â½ÃŒ Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100) *spType = 1;
		break;

	case 23: 
		// Ã€Ã¥Â°Ã‹ Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100) *spType = 1;
		break;

	case 24: 
		// ÂµÂµÂ³Â¢ Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100) *spType = 1;
		break;

	case 25: 
		// ÃˆÂ° Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100) *spType = 2;
		if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
		// ÃˆÂ° Â°Ã¸Â°ÃÃ€ÃŽÂµÂ¥ Ã€Ã¥Ã‚Ã¸Ã‡Ã‘ Â¹Â«Â±Ã¢Â°Â¡ ÃˆÂ°Ã€ÃŒ Â¾Ã†Â´ÃÂ´Ã™. Ã€ÃÂ¹Ã Â°Ã¸Â°ÃÃ€Â¸Â·ÃŽ Ã€Ã¼ÃˆÂ¯.
		if (wType < 40) *spType = 1;
		break;

	case 26: 
		// v2.16 2002-5-27 ÇØ¸Ó ÇÊ»ì±â 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[14] < 100) *spType = 1;
		break;

	case 27: 
		// v2.16 2002-5-27 ÁöÆÎÀÌ ÇÊ»ì±â 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[21] < 100) *spType = 1;
		break;
	}
}

void CGame::ReqCreatePortionHandler(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cI[6], cPortionName[21], cData[120];
 int    iRet, i, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
 short * sp, sItemIndex[6], sTemp;
 short  sItemNumber[6], sItemArray[12];
 bool   bDup, bFlag;
 class  CItem * pItem;

	if (m_pClientList[iClientH] == 0) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) {
		cI[i] = -1;
		sItemIndex[i]  = -1;
		sItemNumber[i] = 0;
	}

	cp = (char *)(pData + 11);
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;
	// Æ÷¼ÇÀÇ Àç·á ÀÎµ¦½º¸¦ ¹Þ¾Ò´Ù. ÀÌ Àç·á°¡ Æ÷¼ÇÀ» ¸¸µé ¼ö ÀÖ´Â Á¶ÇÕÀÎÁö È®ÀÎÇÑ´Ù. 

	// µ¥ÀÌÅÍ°¡ À¯È¿ÇÑ ¾ÆÀÌÅÛ ÀÎµ¦½ºÀÎÁö Ã¼Å©ÇÑ´Ù.
	for (i = 0; i < 6; i++) {
		if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == 0)) return;
	}

	for (i = 0; i < 6; i++)
	if (cI[i] >= 0) {
		// ¸ÕÀú ÀÌ¹Ì ÀÖ´Â ¸®½ºÆ®ÀÎÁö °Ë»ö 
		bDup = false;
		for (j = 0; j < 6; j++) 
		if (sItemIndex[j] == cI[i]) {
			// ÀÖ´Ù. Ä«¿îÆ® Áõ°¡ 
			sItemNumber[j]++;
			bDup = true;
		}
		if (bDup == false) {
			// ¾ø´Ù. »õ·Î Ãß°¡ÇÑ´Ù.
			for (j = 0; j < 6; j++) 
			if (sItemIndex[j] == -1) {
				sItemIndex[j] = cI[i];
				sItemNumber[j]++;
				goto RCPH_LOOPBREAK;
			}
RCPH_LOOPBREAK:;
		}
	}
	
	// ¾ÆÀÌÅÛ ¸®½ºÆ®°¡ ¸¸µé¾î Á³´Ù. ¼ÒºñµÇ´Â ¾ÆÀÌÅÛÀÌ¶ó¸é °¹¼ö¸¦ È®ÀÎÇÑ´Ù. 
	for (i = 0; i < 6; i++) 
	if (sItemIndex[i] != -1) {
		if (sItemIndex[i] < 0) return;
		if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == 0) return;
		// ¾ÆÀÌÅÛÀÌ °¹¼ö°¡ ¿À¹öÇØµµ ¸®ÅÏ.
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
	}

	// ¾ÆÀÌÅÛÀ» ¾ÆÀÌÅÛ ¾ÆÀÌµð ¹øÈ£°¡ Å« ¼ø¼­ºÎÅÍ Á¤·ÄÇÑ´Ù. Bubble Sort
	bFlag = true;
	while (bFlag ) {
		bFlag = false;
		for (i = 0; i < 5; i++) 
		if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) {
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) <
				(m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) {
				// ¹Ù²Û´Ù.
				sTemp = sItemIndex[i+1];
				sItemIndex[i+1] = sItemIndex[i];
				sItemIndex[i] = sTemp;
				sTemp = sItemNumber[i+1];
				sItemNumber[i+1] = sItemNumber[i];
				sItemNumber[i] = sTemp;
				bFlag = true;
			}
		}
	}

	j = 0;
	for (i = 0; i < 6; i++) {
		if (sItemIndex[i] != -1)
			 sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}

	ZeroMemory(cPortionName, sizeof(cPortionName));

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) 
	if (m_pPortionConfigList[i] != 0) {
		bFlag = false;
		for (j = 0; j < 12; j++) 
		if (m_pPortionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = true;
		
		if (bFlag == false) {
			ZeroMemory(cPortionName, sizeof(cPortionName));
			memcpy(cPortionName, m_pPortionConfigList[i]->m_cName, 20);
			iSkillLimit = m_pPortionConfigList[i]->m_iSkillLimit;
			iDifficulty = m_pPortionConfigList[i]->m_iDifficulty;
		}
	}

	if (strlen(cPortionName) == 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOMATCHINGPORTION, 0, 0, 0, 0);
		return;
	}

	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[12];
	if (iSkillLimit > iSkillLevel) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_LOWPORTIONSKILL, 0, 0, 0, cPortionName);
		return;
	}

	iSkillLevel -= iDifficulty;
	if (iSkillLevel <= 0) iSkillLevel = 1;

	iResult = iDice(1,100);
	if (iResult > iSkillLevel) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PORTIONFAIL, 0, 0, 0, cPortionName);
		return;
	}

	CalculateSSN_SkillIndex(iClientH, 12, 1);
	
	if (strlen(cPortionName) != 0) {
		pItem = 0;
		pItem = new class CItem;
		if (pItem == 0) return;

		for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				// v1.41 !!!
				SetItemCount(iClientH, sItemIndex[i], //     m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName,
				             m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
			else ItemDepleteHandler(iClientH, sItemIndex[i], false);
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PORTIONSUCCESS, 0, 0, 0, cPortionName);
		m_pClientList[iClientH]->m_iExpStock += iDice(1, (iDifficulty/3));

		if ((_bInitItemAttr(pItem, cPortionName) )) {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {
				ZeroMemory(cData, sizeof(cData));
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;	// ¼ö·®À» ÀÔ·Â 
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; 
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
				cp++;
				*/
				
				if (iEraseReq == 1) delete pItem;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}
				
				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					                                                         m_pClientList[iClientH]->m_sY, pItem);
				
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					                        pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}
			}
		}
		else {
			delete pItem;
			pItem = 0;
		}
	}
}

//bool CGame::_bDecodePortionConfigFileContents(char *pData, DWORD dwMsgSize)
//{
// char * pContents, * token, cTxt[120];
// char seps[] = "= \t\n";
// char cReadModeA = 0;
// char cReadModeB = 0;
// int  iPortionConfigListIndex = 0;
// class CStrTok * pStrTok;
//
//	pContents = new char[dwMsgSize+1];
//	ZeroMemory(pContents, dwMsgSize+1);
//	memcpy(pContents, pData, dwMsgSize);
//
//	pStrTok = new class CStrTok(pContents, seps);
//	token = pStrTok->pGet();
//	while( token != 0 ) {
//		if (cReadModeA != 0) {
//			switch (cReadModeA) {
//			case 1:
//				switch (cReadModeB) {
//				case 1:
//					//  ȣ 
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
//						delete[] pContents;
//						delete pStrTok;
//						return false;
//					}
//					
//					if (m_pPortionConfigList[atoi(token)] != 0) {
//						// ̹ Ҵ ȣ ִ. ̴.
//						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Duplicate portion number.");
//						delete[] pContents;
//						delete pStrTok;
//						return false;
//					}
//					m_pPortionConfigList[atoi(token)] = new class CPortion;
//					iPortionConfigListIndex = atoi(token);
//
//					cReadModeB = 2;
//					break;
//
//				case 2:
//					//  ̸ 
//					ZeroMemory(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, sizeof(m_pPortionConfigList[iPortionConfigListIndex]->m_cName));
//					memcpy(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, token, strlen(token));
//					cReadModeB = 3;
//					break;
//
//				default:
//					//   m_sArray[0~10]
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//						delete pStrTok;
//						return false;
//					}
//					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
//					cReadModeB++;
//					break;
//
//				case 14:
//					//  m_sArray[11]
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//						delete pStrTok;
//						return false;
//					}
//					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[11] = atoi(token);
//					cReadModeB = 15;
//					break;
//
//				case 15:
//					// ų ġ 
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//						delete pStrTok;
//						return false;
//					}
//					m_pPortionConfigList[iPortionConfigListIndex]->m_iSkillLimit = atoi(token);
//					cReadModeB = 16;
//					break;
//	
//				case 16:
//					// ̵
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//						delete pStrTok;
//						return false;
//					}
//					m_pPortionConfigList[iPortionConfigListIndex]->m_iDifficulty = atoi(token);
//					cReadModeA = 0;
//					cReadModeB = 0;
//					break;
//				}
//				break;
//
//			default: 
//				break;
//			}
//		}
//		else {
//			if (memcmp(token, "potion", 5) == 0) {
//				cReadModeA = 1;
//				cReadModeB = 1;
//			}
//			
//		}
//		token = pStrTok->pGet();
//	}	
//
//	delete pStrTok;
//	delete[] pContents;
//
//	if ((cReadModeA != 0) || (cReadModeB != 0)) {
//		PutLogList("(!!!) CRITICAL ERROR! POTION configuration file contents error!");
//		return false;
//	}
//
//	wsprintf(cTxt, "(!) POTION(Total:%d) configuration - success!", iPortionConfigListIndex);
//	PutLogList(cTxt);
//
//	return true;
//}

//////////////////////////////////////////////////////////////////////////////////////////
///		Snoopy: Added Crafting to the same file than potions
//////////////////////////////////////////////////////////////////////////////////////////
bool CGame::_bDecodePortionConfigFileContents(char* pData, DWORD dwMsgSize)
{
	char* pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iPortionConfigListIndex = 0;
	int  iCraftingConfigListIndex = 0;
	class CStrTok* pStrTok;

	char cData[50000] = {};
	DWORD lpNumberOfBytesRead;
	HANDLE hFile = CreateFile(pData, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	DWORD dwFileSize = GetFileSize(hFile, 0);
	if (dwFileSize == -1) {
		wsprintf(G_cTxt, "(X) CRITICAL ERROR! Cannot open configuration file(%s)!", pData);
		PutLogList(pData);
		return false;
	}

	SetFilePointer(hFile, 0, 0, FILE_BEGIN);

	ReadFile(hFile, cData, dwFileSize, &lpNumberOfBytesRead, 0);
	CloseHandle(hFile);

	pContents = new char[dwFileSize + 1];
	ZeroMemory(pContents, dwFileSize + 1);
	memcpy(pContents, cData, dwFileSize);
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while (token != 0) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:	// Potion's index
					if (_bGetIsStringIsNumber(token) == false)
					{
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
						delete[] pContents; delete pStrTok; return false;
					}
					if (m_pPortionConfigList[atoi(token)] != 0)
					{
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Duplicate portion number.");
						delete[] pContents; delete pStrTok; return false;
					}
					m_pPortionConfigList[atoi(token)] = new class CPortion;
					iPortionConfigListIndex = atoi(token);
					cReadModeB = 2;
					break;

				case 2: // Potion's name
					ZeroMemory(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, sizeof(m_pPortionConfigList[iPortionConfigListIndex]->m_cName));
					memcpy(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default: // m_sArray[0~10]
					if (_bGetIsStringIsNumber(token) == false)
					{
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete[] pContents; delete pStrTok; return false;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

				case 14: // m_sArray[11]
					if (_bGetIsStringIsNumber(token) == false)
					{
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete[] pContents; delete pStrTok; return false;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[11] = atoi(token);
					cReadModeB = 15;
					break;

				case 15: // Mini Skill
					if (_bGetIsStringIsNumber(token) == false)
					{
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete[] pContents; delete pStrTok; return false;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 16;
					break;

				case 16:// Difficulty
					if (_bGetIsStringIsNumber(token) == false)
					{
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete[] pContents; delete pStrTok; return false;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iDifficulty = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2: // Crafting
				switch (cReadModeB) {
				case 1:	// 
					if (_bGetIsStringIsNumber(token) == false)
					{
						PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format(1).");
						delete[] pContents; delete pStrTok; return false;
					}
					if (m_pCraftingConfigList[atoi(token)] != 0)
					{
						PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Duplicate crafting number.");
						delete[] pContents; delete pStrTok; return false;
					}
					m_pCraftingConfigList[atoi(token)] = new class CPortion;
					iCraftingConfigListIndex = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					ZeroMemory(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, sizeof(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName));
					memcpy(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default: // m_sArray[0~10]
					if (_bGetIsStringIsNumber(token) == false)
					{
						PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete[] pContents; delete pStrTok; return false;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

				case 14: // m_sArray[11]
					if (_bGetIsStringIsNumber(token) == false)
					{
						PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete[] pContents; delete pStrTok; return false;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[11] = atoi(token);
					cReadModeB = 15;
					break;

				case 15: // 
					if (_bGetIsStringIsNumber(token) == false)
					{
						PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete[] pContents; delete pStrTok; return false;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 16;
					break;

				case 16:// 
					if (_bGetIsStringIsNumber(token) == false)
					{
						PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete[] pContents; delete pStrTok; return false;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_iDifficulty = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default:
				break;
			}
		}
		else
		{
			if (memcmp(token, "potion", 5) == 0)
			{
				cReadModeA = 1;
				cReadModeB = 1;
			}
			if (memcmp(token, "crafting", 8) == 0)
			{
				cReadModeA = 2;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}
	delete pStrTok;
	delete[] pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0))
	{
		PutLogList("(!!!) CRITICAL ERROR! POTION configuration file contents error!");
		return false;
	}
	wsprintf(cTxt, "(!) POTION(Total:%d) configuration - success!", iPortionConfigListIndex);
	PutLogList(cTxt);

	return true;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
///		Crafting functions copyed on Alchemy functions...
//////////////////////////////////////////////////////////////////////////////////////////////////////
void CGame::ReqCreateCraftingHandler(int iClientH, char* pData)
{
	DWORD* dwp;
	WORD* wp;
	char* cp, cI[6], cCraftingName[21], cData[120];
	int    iRet, i, j, iEraseReq, iRiskLevel, iDifficulty, iNeededContrib = 0;
	short* sp, sTemp;
	short  sItemIndex[6], sItemPurity[6], sItemNumber[6], sItemArray[12];
	bool   bDup, bFlag, bNeedLog;
	class  CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++)
	{
		cI[i] = -1;
		sItemIndex[i] = -1;
		sItemNumber[i] = 0;
		sItemPurity[i] = -1;
	}
	cp = (char*)(pData + 11);
	cp += 20;
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;

	for (i = 0; i < 6; i++)
	{
		if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == 0)) return;
	}

	for (i = 0; i < 6; i++)
		if (cI[i] >= 0)
		{
			bDup = false;
			for (j = 0; j < 6; j++)
				if (sItemIndex[j] == cI[i])
				{
					sItemNumber[j]++;
					bDup = true;
				}
			if (bDup == false)
			{
				for (j = 0; j < 6; j++)
					if (sItemIndex[j] == -1)
					{
						sItemIndex[j] = cI[i];
						sItemNumber[j]++;
						goto RCPH_LOOPBREAK;
					}
RCPH_LOOPBREAK:;
			}
		}


	for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1)
		{
			if (sItemIndex[i] < 0) return;
			if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == 0) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
			sItemPurity[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sItemSpecEffectValue2;
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_NONE)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
			{
				sItemPurity[i] = 100; // Merien stones considered 100% purity.
			}
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
			{
				sItemPurity[i] = -1; // Diamonds / Emeralds.etc.. never have purity
			}
			if (sItemNumber[i] > 1) // No purity for stacked items
			{
				sItemPurity[i] = -1;
			}
			/*wsprintf(G_cTxt, "Crafting: %d x %s (%d)"
				, sItemNumber[i]
				, m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName
				, m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum);
			PutLogList(G_cTxt);*/

			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cEquipPos == DEF_EQUIPPOS_NECK))
			{
				iNeededContrib = 10; // Necks Crafting requires 10 contrib
			}
		}

	// Bubble Sort
	bFlag = true;
	while (bFlag )
	{
		bFlag = false;
		for (i = 0; i < 5; i++)
			if ((sItemIndex[i] != -1) && (sItemIndex[i + 1] != -1))
			{
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) < (m_pClientList[iClientH]->m_pItemList[sItemIndex[i + 1]]->m_sIDnum))
				{
					sTemp = sItemIndex[i + 1];
					sItemIndex[i + 1] = sItemIndex[i];
					sItemIndex[i] = sTemp;
					sTemp = sItemPurity[i + 1];
					sItemPurity[i + 1] = sItemPurity[i];
					sItemPurity[i] = sTemp;
					sTemp = sItemNumber[i + 1];
					sItemNumber[i + 1] = sItemNumber[i];
					sItemNumber[i] = sTemp;
					bFlag = true;
				}
			}
	}
	j = 0;
	for (i = 0; i < 6; i++)
	{
		if (sItemIndex[i] != -1)
			sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j + 1] = sItemNumber[i];
		j += 2;
	}

	// Search Crafting you wanna build
	ZeroMemory(cCraftingName, sizeof(cCraftingName));
	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
		if (m_pCraftingConfigList[i] != 0)
		{
			bFlag = false;
			for (j = 0; j < 12; j++)
			{
				if (m_pCraftingConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = true; // one item mismatch	
			}
			if (bFlag == false) // good Crafting receipe
			{
				ZeroMemory(cCraftingName, sizeof(cCraftingName));
				memcpy(cCraftingName, m_pCraftingConfigList[i]->m_cName, 20);
				iRiskLevel = m_pCraftingConfigList[i]->m_iSkillLimit;			// % to loose item if crafting fails
				iDifficulty = m_pCraftingConfigList[i]->m_iDifficulty;
			}
		}


	// Check if recipe is OK
	if (strlen(cCraftingName) == 0)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 1, 0, 0, 0); // "There is not enough material"
		return;
	}
	// Check for Contribution
	if (m_pClientList[iClientH]->m_iContribution < iNeededContrib)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 2, 0, 0, 0); // "There is not enough Contribution Point"	
		return;
	}
	// Check possible Failure
	if (iDice(1, 100) > iDifficulty)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 3, 0, 0, 0); // "Crafting failed"
		// Remove parts...
		pItem = 0;
		pItem = new class CItem;
		if (pItem == 0) return;
		for (i = 0; i < 6; i++)
			if (sItemIndex[i] != -1)
			{	// Deplete any Merien Stone
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_NONE)
					&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
					&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
				{
					ItemDepleteHandler(iClientH, sItemIndex[i], false);
				}
				else
					// Risk to deplete any other items (not stackable ones) // DEF_ITEMTYPE_CONSUME
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
						|| (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_MATERIAL))
					{
						if (iDice(1, 100) < iRiskLevel)
						{
							ItemDepleteHandler(iClientH, sItemIndex[i], false);
						}
					}
			}
		return;
	}

	// Purity
	int iPurity, iTot = 0, iCount = 0;
	for (i = 0; i < 6; i++)
	{
		if (sItemIndex[i] != -1)
		{
			if (sItemPurity[i] != -1)
			{
				iTot += sItemPurity[i];
				iCount++;
			}
		}
	}
	if (iCount == 0)
	{
		iPurity = 20 + iDice(1, 80);			// Wares have random purity (20%..100%)
		bNeedLog = false;
	}
	else
	{
		iPurity = iTot / iCount;
		iTot = (iPurity * 4) / 5;
		iCount = iPurity - iTot;
		iPurity = iTot + iDice(1, iCount);	// Jewel completion depends off Wares purity
		bNeedLog = true;
	}
	if (iNeededContrib != 0)
	{
		iPurity = 0;						// Necks require contribution but no purity/completion
		bNeedLog = true;
	}
	CalculateSSN_SkillIndex(iClientH, 18, 1);

	if (strlen(cCraftingName) != 0)
	{
		pItem = 0;
		pItem = new class CItem;
		if (pItem == 0) return;
		for (i = 0; i < 6; i++)
		{
			if (sItemIndex[i] != -1)
			{
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				{
					SetItemCount(iClientH, sItemIndex[i],
						m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
				}
				else // So if item is not Type 5 (stackable items), you deplete item
				{
					ItemDepleteHandler(iClientH, sItemIndex[i], false);
				}
			}
		}
		if (iNeededContrib != 0)
		{
			m_pClientList[iClientH]->m_iContribution -= iNeededContrib;
			// No known msg to send info to client, so client will compute shown Contrib himself.		
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_SUCCESS, 0, 0, 0, 0);

		m_pClientList[iClientH]->m_iExpStock += iDice(2, 100);

		if ((_bInitItemAttr(pItem, cCraftingName) ))
		{	// // Snoopy: Added Purity to Oils/Elixirs
			if (iPurity != 0)
			{
				pItem->m_sItemSpecEffectValue2 = iPurity;
				pItem->m_dwAttribute = 1;
			}
			pItem->m_sTouchEffectType = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1, 100000);
			pItem->m_sTouchEffectValue2 = iDice(1, 100000);
			// pItem->m_sTouchEffectValue3 = timeGetTime();	
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d", (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);

			// SNOOPY log anything above WAREs
			if (bNeedLog)
			{
				wsprintf(G_cTxt, "PC(%s) Crafting (%s) Purity(%d)"
					, m_pClientList[iClientH]->m_cCharName
					, pItem->m_cName
					, pItem->m_sItemSpecEffectValue2);
				PutLogFileList(G_cTxt);
			}
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) )
			{
				ZeroMemory(cData, sizeof(cData));
				dwp = (DWORD*)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp = (WORD*)(cData + DEF_INDEX2_MSGTYPE);
				*wp = DEF_NOTIFY_ITEMOBTAINED;
				cp = (char*)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				dwp = (DWORD*)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				*cp = pItem->m_cItemType;
				cp++;
				*cp = pItem->m_cEquipPos;
				cp++;
				*cp = (char)0;
				cp++;
				sp = (short*)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				*cp = pItem->m_cGenderLimit;
				cp++;
				wp = (WORD*)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				wp = (WORD*)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				sp = (short*)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				sp = (short*)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;
				*cp = pItem->m_cItemColor;
				cp++;
				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				dwp = (DWORD*)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*	*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item
				cp++;	*/
				if (iEraseReq == 1) delete pItem;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}
				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else
			{
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
					m_pClientList[iClientH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute);

				dwp = (DWORD*)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp = (WORD*)(cData + DEF_INDEX2_MSGTYPE);
				*wp = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}
			}
		}
		else
		{
			delete pItem;
			pItem = 0;
		}
	}
}


void CGame::LocalSavePlayerData(int iClientH)
{
 char * pData, * cp, cFn[256], cDir[256], cTxt[256], cCharDir[256];
 int    iSize;
 FILE * pFile;
 SYSTEMTIME SysTime;

	// ·Î±× ¼­¹ö·ÎÀÇ ¿¬°áÀÌ Á¾·áµÇ¾î ÀÓ½Ã·Î °ÔÀÓ¼­¹ö ³»ÀÇ Æú´õ¿¡ ÀúÀåÇÑ´Ù. 
	if (m_pClientList[iClientH] == 0) return;
 
	pData = new char[30000];
	if (pData == 0) return;
	ZeroMemory(pData, 30000);

	cp = (char *)(pData);
	iSize = _iComposePlayerDataFileContents(iClientH, cp);

	GetLocalTime(&SysTime);
	ZeroMemory(cCharDir, sizeof(cDir));
	wsprintf(cCharDir, "Character_%d_%d_%d_%d", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);

	ZeroMemory(cDir, sizeof(cDir));
	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn,cCharDir);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	wsprintf(cTxt, "MeC77%d", (unsigned char)m_pClientList[iClientH]->m_cCharName[0]);
	strcat(cFn, cTxt);
	strcpy(cDir, cFn);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn, m_pClientList[iClientH]->m_cCharName);
	strcat(cFn, ".txt");

	// µð·ºÅä¸®¸¦ ¸¸µç´Ù.
	_mkdir(cCharDir);
	_mkdir(cDir);

	// (char*)cp ºÎÅÍ (dwMsgSize - 36)Å©±â±îÁö°¡ ÆÄÀÏ¿¡ ÀúÀåµÉ µ¥ÀÌÅÍÀÌ´Ù.
	if (iSize == 0) {
		PutLogList("(!) Character data body empty: Cannot create & save temporal player data file.");
		delete pData;
		return;
	}

	pFile = fopen(cFn, "wt");
	if (pFile == 0) {
		wsprintf(cTxt, "(!) Cannot create temporal player data file : Name(%s)", cFn);
		PutLogList(cTxt);
	}
	else {
		wsprintf(cTxt, "(!) temporal player data file saved : Name(%s)", cFn);
		PutLogList(cTxt);
		fwrite(cp, iSize, 1, pFile);
	}
	
	if (pFile != 0) fclose(pFile);
	delete pData;
}

void CGame::MineralGenerator()
{
 int i, iP, tX, tY, iRet;
 
	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((iDice(1,4) == 1) && (m_pMapList[i] != 0) && 
			(m_pMapList[i]->m_bMineralGenerator ) && 
			(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {
	
			iP = iDice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
			if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_MineralPointList[iP].x;
			tY = m_pMapList[i]->m_MineralPointList[iP].y;

		   	iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
		}
	}		
}

int CGame::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{
 int i, iDynamicHandle, iMineralType;

	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == 0) return 0;
	
	for (i = 1; i < DEF_MAXMINERALS; i++) 
	if (m_pMineral[i] == 0) {
		// ºó °ø°£¿¡ ±¤¹°µ¢ÀÌ¸¦ ¸¸µç´Ù.
		iMineralType = iDice(1, cLevel);
		m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
		if (m_pMineral[i] == 0) return 0;
 		
		iDynamicHandle = 0;
		switch (iMineralType) {
		case 1: // ±¤¹°·ù
		case 2:
		case 3:
		case 4:
			iDynamicHandle = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, 0, i);
			break;
				
		case 5: // º¸¼®·ù 
		case 6:
			iDynamicHandle = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, 0, i);
			break;
		
		default:
			// ¿¡·¯ ¹æÁö¿ë ÄÚµå 
			iDynamicHandle = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, 0, i);
			break;
		}
		
		if (iDynamicHandle == 0) {
			delete m_pMineral[i];
			m_pMineral[i] = 0;
			return 0;
		}
		m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMineral[i]->m_cMapIndex = cMapIndex;
		
		// ³­ÀÌµµ¿Í ¼ö·®À» ÀÔ·ÂÇÑ´Ù.
		switch (iMineralType) {
		case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
		case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
		case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
		case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
		case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
		default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		}

		// ¸ÊÀÇ ¹Ì³×¶ö ¼ö Áõ°¡
		m_pMapList[cMapIndex]->m_iCurMineral++;
	
		return i;
	}

	return 0;
}


void CGame::_CheckMiningAction(int iClientH, int dX, int dY)
{
	short sType;
	DWORD dwRegisterTime;
	int   iDynamicIndex, iSkillLevel, iResult, iItemID;
	class CItem * pItem;
	WORD  wWeaponType;

	iItemID = 0;

	if (m_pClientList[iClientH] == 0)  return;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);

	if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
	}

	switch (sType) {
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		// ±¤¹°Ã¤Ãë¸¦ ½ÃµµÇÑ Ä³¸¯ÅÍÀÇ Á¶°ÇÀ» »ìÇÉ´Ù. °î±ªÀÌ¸¦ µé°í ÀÖ´Â°¡? ±¤¹° Ã¤Ãë ½ºÅ³Àº? 
		// °î±ªÀÌ¿¡ ÇØ´çÇÏ´Â ¿ÜÇüÀÌ¸é Åë°ú 
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 25) {
			// ÇÈ¾×½º¸¦ µé°í ÀÖ´Ù. ±¤¹° Ã¤Ãë °¡´É 
		}
		else return;

		// ÀüÅõ ¸ð¼ÇÀÌ ¾Æ´Ï´õ¶óµµ ¸®ÅÏ 
		if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0) return;

		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[0];
		if (iSkillLevel == 0) break;

		if (m_pDynamicObjectList[iDynamicIndex] == 0) break;
		// Ä³´Â ±¤¹°ÀÇ ³­ÀÌµµ¸¸Å­ ½ºÅ³À» ³·Ãá´Ù.
		iSkillLevel -= m_pMineral[ m_pDynamicObjectList[iDynamicIndex]->m_iV1 ]->m_iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;

		iResult = iDice(1, 100);
		if (iResult <= iSkillLevel) {
			// È®·üÀº ¼º°øÇß´Ù. ±¤¹°Ã¤Ãë ±â¼ú Áõ°¡ 
			CalculateSSN_SkillIndex(iClientH, 0, 1);

			// ÇÃ·¹ÀÌ¾îÀÇ ¹ß ¹Ø¿¡ ±¤¹°À» ¶³¾î¶ß¸°´Ù. 
			switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) { 
				case 1: 
					switch (iDice(1,5)) { 
						case 1: 
						case 2: 
						case 3:    
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 4:    
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 5:
							iItemID = 507; // BlondeStone
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
							break;
					} 
					break; 

				case 2: 
					switch (iDice(1,5)) { 
						case 1: 
						case 2: 
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 3:    
						case 4:    
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 5:
							if (iDice(1,3) == 2) { 
								iItemID = 356; // SilverNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
							} 
							else { 
								iItemID = 507; // BlondeStone
								m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							} 
							break; 
					} 
					break; 

				case 3: 
					switch (iDice(1,6)) { 
						case 1: 
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 2: 
						case 3:    
						case 4:    
						case 5: 
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 6: 
							if (iDice(1,8) == 3) { 
								if (iDice(1,2) == 1) { 
									iItemID = 356; // SilverNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
								} 
								else { 
									iItemID = 357; // IronOre
									m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
								}
								break;
							} 
							else { 
								iItemID = 357; // IronOre
								m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							} 
							break; 
					} 
					break; 

				case 4: 
					switch (iDice(1,6)) { 
						case 1: 
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 2: 
							if (iDice(1,3) == 2) {
								iItemID =  356; // SilverNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
							}
							break;
						case 3:    
						case 4:    
						case 5: 
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 6: 
							if (iDice(1,8) == 3) { 
								if (iDice(1,4) == 3) { 
									if (iDice(1,4) < 3) { 
										iItemID = 508; // Mithral
										m_pClientList[iClientH]->m_iExpStock += iDice(1,15); 
									} 
									else { 
										iItemID =  354; // GoldNugget
										m_pClientList[iClientH]->m_iExpStock += iDice(1,5); 
									}
									break;
								} 
								else { 
									iItemID =  356; // SilverNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
								}
								break;
							} 
							else { 
								if (iDice(1,2) == 1) { 
									iItemID = 354; // GoldNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(1,5);
								}
								else {
									iItemID = 357;  // IronOre
									m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
								}
								break;
							} 
							break; 
					}
					break;

				case 5: 
					switch (iDice(1,19)) { 
						case 3: 
							iItemID = 352; // Sapphire
							m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							break; 
						default: 
							iItemID = 358; // Crystal
							m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							break; 
					} 
					break; 

				case 6: 
					switch (iDice(1,5)) { 
						case 1: 
							if (iDice(1,6) == 3) { 
								iItemID =  353; // Emerald 
								m_pClientList[iClientH]->m_iExpStock += iDice(2,4); 
							} 
							else { 
								iItemID =  358; // Crystal
								m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							} 
							break; 
						case 2: 
							if (iDice(1,6) == 3) { 
								iItemID =  352; // Saphire
								m_pClientList[iClientH]->m_iExpStock += iDice(2,4); 
							} 
							else { 
								iItemID =  358; // Crystal
								m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							} 
							break; 
						case 3: 
							if (iDice(1,6) == 3) { 
								iItemID =  351; // Ruby
								m_pClientList[iClientH]->m_iExpStock += iDice(2,4); 
							} 
							else { 
								iItemID =  358; // Crystal 
								m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							} 
							break; 
						case 4: 
							iItemID =  358; // Crystal 
							m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							break; 
						case 5: 
							if (iDice(1,12) == 3) { 
								iItemID =  350; // Diamond
								m_pClientList[iClientH]->m_iExpStock += iDice(2,5); 
							} 
							else { 
								iItemID =  358; // Crystal
								m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							} 
							break;
					} 
					break;

			} 

			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == false) {
				delete pItem;
			}
			else {
				// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					m_pClientList[iClientH]->m_sY, pItem);
				// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4
				    // testcode
					// wsprintf(G_cTxt, "Mining Success: %d", iItemID); 
					// PutLogList(G_cTxt);
			}

			// ±¤¹°ÀÇ ³²Àº ·®À» ÁÙÀÌ°í 0ÀÎ°æ¿ì »èÁ¦ÇÑ´Ù.
			m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
			if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
				// ±¤¹°ÀÌ ¸ðµÎ ¼Ò¸ðµÇ¾ú´Ù. Delete Mineral 
				bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);

				// µ¿Àû °´Ã¼ »èÁ¦
				delete m_pDynamicObjectList[iDynamicIndex];
				m_pDynamicObjectList[iDynamicIndex] = 0;
			}
		}
		break;

	default: 
		break;
	}
}

bool CGame::bDeleteMineral(int iIndex)
{
 int iDynamicIndex;
 DWORD dwTime;

	dwTime = timeGetTime();
	
	if (m_pMineral[iIndex] == 0) return false;
	iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
	if (m_pDynamicObjectList[iDynamicIndex] == 0) return false;

	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex, 
		                        m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, 
								m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, 0, (short)0);
	// ¸Ê¿¡¼­ ±¤¹° µ¿Àû °´Ã¼¸¦ »èÁ¦ÇÑ´Ù.
	m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
	// ±¤¹°ÀÌ »ç¶óÁ³À¸¹Ç·Î ÀÌµ¿ÀÌ °¡´ÉÇÏ°Ô ÇÑ´Ù. 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, true);
			
	// ±¤¹° °³Ã¼ ¼ö °¨¼Ò 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;

	// ±¤¹° °´Ã¼ »èÁ¦ 
	delete m_pMineral[iIndex];
	m_pMineral[iIndex] = 0;

	return true;
}

void CGame::NpcTalkHandler(int iClientH, int iWho)
{
 char cRewardName[21], cTargetName[21];
 int iResMode, iQuestNum, iQuestType, iRewardType, iRewardAmount, iContribution, iX, iY, iRange, iTargetType, iTargetCount;

	iQuestNum = 0;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	if (m_pClientList[iClientH] == 0) return;
	switch (iWho) {
	case 1: break;
	case 2:	break;
	case 3:	break;
	case 4:
		iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		break;
	case 5: break;
	case 6:	break;
	case 32: break;
	case 21: 
		iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		if (iQuestNum >= 1000) return;
		break;
	}

	ZeroMemory(cRewardName, sizeof(cRewardName));
	if (iQuestNum > 0) {
		if (iRewardType > 1) {
			strcpy(cRewardName, m_pItemConfigList[iRewardType]->m_cName);
		}
		else {
			switch (iRewardType) {
			case -10: strcpy(cRewardName, "F-"); break;
			}
		}

		m_pClientList[iClientH]->m_iAskedQuest        = iQuestNum;
		m_pClientList[iClientH]->m_iQuestRewardType   = iRewardType;
		m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;
	
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
			          iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
	}
	else {
		switch (iQuestNum) {
		case  0: SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (iWho+130), 0, 0, 0, 0); break;
		case -1:
		case -2:
		case -3:
		case -4: SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, abs(iQuestNum)+100, 0, 0, 0, 0); break;
		case -5: break;
		}
	}
}

void CGame::CheckFireBluring(char cMapIndex, int sX, int sY)
{
 int ix, iy, iItemNum;
 short sSpr, sSprFrame;
 char  cItemColor;
 class CItem * pItem;
 short sIDNum;
 DWORD dwAttr;

	for (ix = sX -1; ix <= sX +1; ix++)
	for (iy = sY -1; iy <= sY +1; iy++) {
		// ¸¸¾à ÀÌ À§Ä¡¿¡ ¹ßÈ­¼º ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é Áö¿ì°í ºÒ ¿ÀºêÁ§Æ®¸¦ ³õ´Â´Ù.	
		iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);
				
		switch (iItemNum) {
		case 355: 
			// ¼®ÅºÀÌ´Ù. ¾ÆÀÌÅÛÀ» Áö¿ì°í ºÒÀ» ¸¸µç´Ù.
			pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sIDNum, &cItemColor, &dwAttr);
			if (pItem != 0) delete pItem;
			iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);	

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, cMapIndex,
				                        ix, iy, sIDNum, 0, cItemColor, dwAttr);
			break;
		}
	}
}



void CGame::AdminOrder_GetNpcStatus(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cNpcName[256];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGetNpcStatus) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != 0) {
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, token);
	}

	for (i = 0; i < DEF_MAXNPCS; i++) 
	if (m_pNpcList[i] != 0) {
		if (memcmp(m_pNpcList[i]->m_cName, cNpcName, 5) == 0) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINIFO, 1, i, 0, 0);	
		}
	}

	delete pStrTok;
	return;
}


int CGame::_iGetWeaponSkillType(int iClientH)
{
 WORD wWeaponType;

	if (m_pClientList[iClientH] == 0) return 0;

	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {
		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7) 
			 return 9;
		else return 8;
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		return 10;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {
		return 14;
	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {
		return 21	;
	}
	else if (wWeaponType >= 40) {
		return 6;
	}
	
	return 1;
}

static int ___iCAB5[]  = {0,0, 0,1,2};
static int ___iCAB6[]  = {0,0, 0,0,0};
static int ___iCAB7[]  = {0,0, 1,2,3};
static int ___iCAB8[]  = {0,0, 1,3,5};
static int ___iCAB9[]  = {0,0, 2,4,8};
static int ___iCAB10[] = {0,0, 1,2,3};

int CGame::iGetComboAttackBonus(int iSkill, int iComboCount)
{
	if (iComboCount <= 1) return 0;
	if (iComboCount > 6) return 0;
	switch (iSkill) {
	case 5:
		return ___iCAB5[iComboCount];
		break;
	case 6:
		return ___iCAB6[iComboCount];
		break;
	case 7:
		return ___iCAB7[iComboCount];
		break;
	case 8:
		return ___iCAB8[iComboCount];
		break;
	case 9:
		return ___iCAB9[iComboCount];
		break;
	case 10:
		return ___iCAB10[iComboCount];
		break;
	case 14:
		return ___iCAB6[iComboCount];
		break;
	case 21:
		return ___iCAB10[iComboCount];
		break;
	}

	return 0;
}

void CGame::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{
	if (m_pClientList[iClientH] == 0) return;
	if ((iSkillIndex < 0) || (iSkillIndex >= DEF_MAXSKILLTYPE)) return;

	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillIndex] > 0)
		m_pClientList[iClientH]->m_iDownSkillIndex = iSkillIndex;

	// ´Ù¿î ½ºÅ³À» ¼³Á¤ÇßÀ¸´Ï ÀÀ´äÀ» º¸³½´Ù. 
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, 0, 0, 0);
}


bool CGame::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{
 bool bRet;

	// À§Ä¡¸¦ ÁöÁ¤ÇÏ°í »ç¿ë ÈÄ »ç¶óÁö´Â ¾ÆÀÌÅÛ È¿°ú Ã³¸® ºÎºÐ 
	if (m_pClientList[iClientH] == 0) return false;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return false;

	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
	case DEF_ITEMEFFECTTYPE_OCCUPYFLAG:
		bRet =  __bSetOccupyFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			                     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
				 				 0, iClientH, 0);
		if (bRet ) {
			GetExp(iClientH, (iDice(m_pClientList[iClientH]->m_iLevel, 10)));
		}
		else {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOTFLAGSPOT, 0, 0, 0, 0);
		}
		return bRet;

	// crusade
	case DEF_ITEMEFFECTTYPE_CONSTRUCTIONKIT:
		// °Ç¼³ Å°Æ®ÀÌ´Ù. ¹Ìµé·£µå¿¡¼­¸¸ »ç¿ë °¡´ÉÇÔ. m_sItemEffectValue1: °ÇÃà¹° Á¾·ù, m_sItemEffectValue2: °ÇÃà ½Ã°£ 
		bRet = __bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
				 				     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,        //
								     iClientH); // ¼³Ä¡ÀÚ 
		if (bRet ) {
			// °Ç¼³ ½ÃÀÛ 
		}
		else {
			// °Ç¼³ ½ÇÆÐ			
		}
		return bRet;
	
	case DEF_ITEMEFFECTTYPE_DYE:
		// ¾ÆÀÌÅÛ ¿°»ö: ¾ÆÀÌÅÛ °ªÀÌ À¯È¿ÇÑ°¡ Ã¼Å©.
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != 0) {
				if ( (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 11) ||
					 (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 12) ) {
					// ¿°»öÀÌ °¡´ÉÇÑ ¾ÆÀÌÅÛÀÌ´Ù.
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					// »ö ¼Ó¼ºÀÌ ¹Ù²î¾úÀ½À» ¾Ë·ÁÁØ´Ù. 
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 0, 0);
					return true;
				}
				else {
					// ¿°»öÀÌ ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÌ´Ù. 
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, 0, 0);
					return false;
				}
			}
		}	
		break;

	case DEF_ITEMEFFECTTYPE_ARMORDYE:
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != 0) {
				if  ( (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 6) ||
				   (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 15) ||
			       (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 13) ) {
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 0, 0);
					return true;
				}
				else {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, 0, 0);
					return false;
				}
			}
		}	
		break;

	case DEF_ITEMEFFECTTYPE_WEAPONDYE:
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != 0) {
				if  ( (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 1) ||
				   (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 3) ||
			       (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 8) ) {
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 0, 0);
					return true;
				}
				else {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, 0, 0);
					return false;
				}
			}
		}	
		break;

	case DEF_ITEMEFFECTTYPE_FARMING:
		bRet = bPlantSeedBag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
				 				     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
								     iClientH);
		return bRet;

	default:
		break;
	}

	return true;
}


bool CGame::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, bool bAdminFlag)
{
 int ix,iy;
 int   iDynamicObjectIndex, iIndex;
 class CTile * pTile;
 DWORD dwTime;

	dwTime = timeGetTime();
	
	if (m_pMapList[cMapIndex] == 0) return false;
	if (((m_bIsHeldenianMode == false) || (m_bIsHeldenianMode != m_cHeldenianType)) && (m_bHeldenianInitiated == 1)) return false;
	if ((m_cHeldenianType == 1) && (m_iBTFieldMapIndex == -1)) return false;	
	if ((m_cHeldenianType == 2) && (m_iGodHMapIndex == -1)) return false;	
	if ((m_pClientList[iClientH]->m_iGuildRank == 0)) return false;

	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iAttribute != 0) return false;
	iSide = m_sLastHeldenianWinner;
	if ((dX < 25) || (dX >= m_pMapList[cMapIndex]->m_sSizeX - 25) || 
		(dY < 25) || (dY >= m_pMapList[cMapIndex]->m_sSizeY - 25)) return false;

	if ((iClientH > 0) && (m_pClientList[iClientH] != 0)) {
		if ((bAdminFlag == false) && (m_pClientList[iClientH]->m_cSide != iSide)) return false;
	}

	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iOccupyFlagIndex != 0) return false;
	if (pTile->m_bIsMoveAllowed == false)  return false;

	for (ix = dX-3; ix <= dX+3; ix++) 
	for (iy = dY-3; iy <= dY+3; iy++) {
		if ((ix == dX) && (iy == dY)) {

		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);			
			if ((pTile->m_iOccupyFlagIndex != 0) && (pTile->m_iOccupyFlagIndex > 0) && 
				(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != 0)) {
				if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide == iSide) return false;
			}
		}
	}

	if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= DEF_MAXOCCUPYFLAG) {
		return false;
	}

	switch (iSide) {
	case 1:	iDynamicObjectIndex = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, 0, 0);	break;
	case 2:	iDynamicObjectIndex = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, 0, 0);	break;
	default: iDynamicObjectIndex = 0;
	}
	
	iEKNum = 1;
	iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
	if (iIndex < 0) {
		if (iDynamicObjectIndex > DEF_MAXGUILDS)
			return true; 
	}
	
	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	pTile->m_iOccupyFlagIndex = iIndex;
		
	m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

	if (m_cHeldenianType == 1) {
		for (ix = dX-3; ix <= dX+3; ix++) 
		for (iy = dY-3; iy <= dY+3; iy++) {
			if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
				(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
			}
			else {
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
				switch (iSide) {
				case 1: 
					pTile->m_iOccupyStatus -= iEKNum; 
					break;
				case 2:	
					pTile->m_iOccupyStatus += iEKNum; 
					break;
				}
			}
		}
	}

	if (m_cHeldenianType == 2) {
		if (iSide == m_sLastHeldenianWinner) {
			m_cHeldenianVictoryType = iSide;
			//sub_4AB9D0
		}
	}
	return true;
}

void CGame::SetSummonMobAction(int iClientH, int iMode, DWORD dwMsgSize, char *pData)
{
 int i, iTargetIndex;
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == 0) return;
	// v2.1 ߸     .
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	switch (iMode) {
	case 0: // Free 
	case 1: // Hold 
		//  Ͱ iClientH  带 Ѵ.
		for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != 0) {
			if ( (m_pNpcList[i]->m_bIsSummoned ) && 
				 (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
				 (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) {

				m_pNpcList[i]->m_iSummonControlMode = iMode;
				m_pNpcList[i]->m_bIsPermAttackMode  = false;
				m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_sBehaviorTurnCount = 0;
				m_pNpcList[i]->m_iTargetIndex       = 0;
			}
		}
		break;
	
	case 2:
		//   - ǥ ´. 
		if ((dwMsgSize)	<= 0) return;
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
   	
		iTargetIndex = 0;
		if (token != 0) {
			// token    ̸ 
			if (strlen(token) > 10) 
				 memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));

			// 2002.8.17 ȣ 
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			{
				// if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) { // original
				if ((m_pClientList[i] != 0) &&
					(memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) &&
					(strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0 ) ) // adamas(map ƾ Ѵ.)
				{
					// ǥ ĳ͸ ãҴ. ε 
					iTargetIndex = i;
					goto SSMA_SKIPSEARCH;
				}
			}
		}

SSMA_SKIPSEARCH:

		if ( (iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_cSide != 0) && 
			 (m_pClientList[iTargetIndex]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
			// ǥ Ѵٸ ҴѴ. 
			for (i = 0; i < DEF_MAXNPCS; i++)
			if (m_pNpcList[i] != 0) {
				if ( (m_pNpcList[i]->m_bIsSummoned ) && 
					 (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
					 (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) {

					m_pNpcList[i]->m_iSummonControlMode = iMode;
					m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[i]->m_iTargetIndex       = iTargetIndex;
					m_pNpcList[i]->m_cTargetType        = DEF_OWNERTYPE_PLAYER;
					m_pNpcList[i]->m_bIsPermAttackMode  = true;
				}
			}
		}
		break;
	}
}

void CGame::GetOccupyFlagHandler(int iClientH)
{
 int   i, iNum, iRet, iEraseReq, iEKNum;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 3) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: strcpy(cItemName, "¾Æ·¹½ºµ§±ê¹ß"); break;
	case 2: strcpy(cItemName, "¿¤¹ÙÀÎ±ê¹ß");   break;
	}

	// ReqPurchaseItemHandler¿¡¼­ °¡Á®¿Â ·çÆ¾À» °íÃÆÀ½.
	iNum = 1;
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == false) {
			// ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ±¸ÀÔÀÌ ºÒ°¡´ÉÇÏ´Ù.
			delete pItem;
		}
		else {
											
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¼ö ÀÖ´Ù´Â °ÍÀÌ È®Á¤ µÇ¾úÀ¸¹Ç·Î EK °ªÀ» »©µµ µÈ´Ù.
				if (m_pClientList[iClientH]->m_iEnemyKillCount > 12) {
					iEKNum = 12;
					m_pClientList[iClientH]->m_iEnemyKillCount -= 12;
				}
				else {
					iEKNum = m_pClientList[iClientH]->m_iEnemyKillCount;
					m_pClientList[iClientH]->m_iEnemyKillCount = 0;
				}
								
				// EKNumÀ» ÀÔ·ÂÇÑ´Ù.
				pItem->m_sItemSpecEffectValue1 = iEKNum;

				//testcode ·Î±×ÆÄÀÏ¿¡ ±â·ÏÇÑ´Ù.
				wsprintf(G_cTxt, "(*) Get Flag : Char(%s) Flag-EK(%d) Player-EK(%d)", m_pClientList[iClientH]->m_cCharName, iEKNum, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogFileList(G_cTxt);

				// ¾ÆÀÌÅÛ ¾ò¾ú´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1°³ È¹µæÇß´Ù.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
					
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
				cp++;
				*/
											
				if (iEraseReq == 1) delete pItem;
				
				// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);
				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}

				// º¯°æµÈ ¿¡³Ê¹Ì Å³À» ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, 0, 0, 0);
			}
			else 
			{
				// °ø°£ÀÌ ºÎÁ·ÇØ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
				delete pItem;

				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, true, true);
					return;
				}
			}
		}
 	}
}



// v1.4311-3 Ãß°¡  ÇÔ¼ö ÀÔÀå±ÇÀ» ÁÖ´Â ÇÔ¼ö   GetFightzoneTicketHandler 
void CGame::GetFightzoneTicketHandler(int iClientH)
{
 int   iRet, iEraseReq, iMonth, iDay, iHour;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0) { 
		// ÀÔÀå±ÇÀ» ´Ù »ç¿ëÇßÀ½À» ¾Ë¸°´Ù.
		// »çÅõÀå ¹øÈ£°¡ À½¼ö¸é ¿¹¾àÀº Çß´Âµ¥ ÀÔÀå±ÇÀ» ´Ù ¹ÞÀº°æ¿ì ..
		m_pClientList[iClientH]->m_iFightzoneNumber  *= -1;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -1, 0, 0, 0);
		return;
	}

	ZeroMemory(cItemName, sizeof(cItemName));

	if (m_pClientList[iClientH]->m_iFightzoneNumber == 1) 
		strcpy(cItemName,"ArenaTicket") ;
	else  wsprintf(cItemName,"ArenaTicket(%d)",m_pClientList[iClientH]->m_iFightzoneNumber ) ;

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, cItemName) == false) {
		delete pItem;
		return;	
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {
		// ¿¡·¯ ¹æÁö¿ë ÄÚµå
		if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
			
		// ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¼ö ÀÖ´Ù´Â °ÍÀÌ È®Á¤ µÇ¾úÀ¸¹Ç·Î ÀÔÀå±Ç°³¼ö¸¦ »©µµ µÈ´Ù. 
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber -1 ;
				
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		
		iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000 ;
		iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth*10000) /100 ;
	    iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth*10000 - iDay*100 ;

		pItem->m_sTouchEffectValue1 = iMonth ;
		pItem->m_sTouchEffectValue2 = iDay ;
		pItem->m_sTouchEffectValue3 = iHour ;
		
		
		wsprintf(G_cTxt, "(*) Get FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)(%d)(%d)", m_pClientList[iClientH]->m_cCharName, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3	);		
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		ZeroMemory(cData, sizeof(cData));

		// ¾ÆÀÌÅÛ ¾ò¾ú´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		// 1°³ È¹µæÇß´Ù.
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
				
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
				
		*cp = pItem->m_cItemType;
		cp++;
				
		*cp = pItem->m_cEquipPos;
		cp++;
				
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
				
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
				
		*cp = pItem->m_cGenderLimit;
		cp++;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
				
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
													
		if (iEraseReq == 1) delete pItem;
				
		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);
				
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, true, true);
			return;
		}
	}	
	else {
		// °ø°£ÀÌ ºÎÁ·ÇØ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
		delete pItem;

		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, true, true);
			return;
		}
	}		
}

int CGame::_iComposeFlagStatusContents(char * pData)
{
 SYSTEMTIME SysTime;
 char cTxt[120];
 int i;

	if (m_iMiddlelandMapIndex < 0) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	
	// 
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) 
	if (m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i] != 0) { 
		
		wsprintf(cTxt,"flag = %d %d %d %d", m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_cSide,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sX,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sY,
			                                m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_iEKCount);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}

	strcat(pData, "\n\n");

	return strlen(pData);
}


bool CGame::_bDecodeOccupyFlagSaveFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token;
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iFlagIndex = 0;
 int  iSide;
 class CStrTok * pStrTok;
 int dX, dY, iEKNum, iTotalFlags;

	if (m_iMiddlelandMapIndex < 0) {
		PutLogList("(!) This game server does not managing Middleland Map. OcuupyFlag data ignored.");
		return false;
	}

	iTotalFlags = 0;

	pContents = new char[dwMsgSize+10];
	ZeroMemory(pContents, dwMsgSize+10);
	memcpy(pContents, pData, dwMsgSize - 9);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != 0 ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Side
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
										
					iSide = atoi(token);
					cReadModeB = 2;
					break;
				
				case 2:
					// X ÁÂÇ¥ 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
										
					dX = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Y ÁÂÇ¥  
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}

					dY = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// EKNum
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					iEKNum = atoi(token);
					
					// µ¥ÀÌÅÍ¸¦ ¸ðµÎ ¸¸µé¾úÀ¸¹Ç·Î ±ê¹ßÀ» µî·ÏÇÑ´Ù. (!!! Master Flag·Î Ã³¸®ÇØ¾ß¸¸ ¼³Ä¡ÇÒ ¼ö ÀÖ´Ù)
					if (__bSetOccupyFlag(m_iMiddlelandMapIndex, dX, dY, iSide, iEKNum, -1, true) )
						iTotalFlags++;
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				
			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "flag", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file contents error!");
		return false;
	}

	wsprintf(G_cTxt, "(!) OccupyFlag save file decoding success! Total(%d)", iTotalFlags); 
	PutLogList(G_cTxt);

	return true;
}
//Hero Code by Zabuza
void CGame::GetHeroMantleHandler(int iClientH,int iItemID,char * pString) 
{ 
 int   i, iNum, iRet, iEraseReq; 
 char  * cp, cData[256], cItemName[21]; 
 class CItem * pItem; 
 DWORD * dwp; 
 short * sp; 
 WORD  * wp; 

	if (m_pClientList[iClientH] == 0) return; 
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return; 
	if (m_pClientList[iClientH]->m_cSide == 0) return; 
	if (_iGetItemSpaceLeft(iClientH) == 0) {
		SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
		return;
	}

	//Prevents a crash if item dosent exist
	if (m_pItemConfigList[iItemID] == 0)  return;
 
	switch(iItemID) { 
	// Hero Cape
	case 400: //Aresden HeroCape
	case 401: //Elvine HeroCape
		if(m_pClientList[iClientH]->m_iEnemyKillCount<300) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 300; 
		break; 

	// Hero Helm
	case 403: //Aresden HeroHelm(M)
	case 404: //Aresden HeroHelm(W)
	case 405: //Elvine HeroHelm(M)
	case 406: //Elvine HeroHelm(W)
		if(m_pClientList[iClientH]->m_iEnemyKillCount < 150) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 150; 
		if(m_pClientList[iClientH]->m_iContribution < 20) return; 
		m_pClientList[iClientH]->m_iContribution -= 20; 
		break; 

	// Hero Cap
	case 407: //Aresden HeroCap(M)
	case 408: //Aresden HeroCap(W)
	case 409: //Elvine HeroHelm(M)
	case 410: //Elvine HeroHelm(W)
		if(m_pClientList[iClientH]->m_iEnemyKillCount < 100) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 100; 
		if(m_pClientList[iClientH]->m_iContribution < 20) return; 
		m_pClientList[iClientH]->m_iContribution -= 20; 
		break;

	// Hero Armour
	case 411: //Aresden HeroArmour(M)
	case 412: //Aresden HeroArmour(W)
	case 413: //Elvine HeroArmour(M)
	case 414: //Elvine HeroArmour(W)
		if(m_pClientList[iClientH]->m_iEnemyKillCount < 300) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 300; 
		if(m_pClientList[iClientH]->m_iContribution < 30) return; 
		m_pClientList[iClientH]->m_iContribution -= 30; 
		break; 

	// Hero Robe
	case 415: //Aresden HeroRobe(M)
	case 416: //Aresden HeroRobe(W)
	case 417: //Elvine HeroRobe(M)
	case 418: //Elvine HeroRobe(W)
		if(m_pClientList[iClientH]->m_iEnemyKillCount < 200) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 200; 
		if(m_pClientList[iClientH]->m_iContribution < 20) return; 
		m_pClientList[iClientH]->m_iContribution -= 20; 
		break; 

	// Hero Hauberk
	case 419: //Aresden HeroHauberk(M)
	case 420: //Aresden HeroHauberk(W)
	case 421: //Elvine HeroHauberk(M)
	case 422: //Elvine HeroHauberk(W)
     if(m_pClientList[iClientH]->m_iEnemyKillCount < 100) return; 
     m_pClientList[iClientH]->m_iEnemyKillCount -= 100; 
     if(m_pClientList[iClientH]->m_iContribution < 10) return; 
     m_pClientList[iClientH]->m_iContribution -= 10; 
     break; 

  // Hero Leggings
  case 423: //Aresden HeroLeggings(M)
  case 424: //Aresden HeroLeggings(W)
  case 425: //Elvine HeroLeggings(M)
  case 426: //Elvine HeroLeggings(W)
     if(m_pClientList[iClientH]->m_iEnemyKillCount < 150) return; 
     m_pClientList[iClientH]->m_iEnemyKillCount -= 150; 
     if(m_pClientList[iClientH]->m_iContribution < 15) return; 
     m_pClientList[iClientH]->m_iContribution -= 15; 
     break; 

  default: 
     return; 
     break; 
  } 

  ZeroMemory(cItemName, sizeof(cItemName)); 
  memcpy(cItemName,m_pItemConfigList[iItemID]->m_cName,20); 
  // ReqPurchaseItemHandler
  iNum = 1; 
  for (i = 1; i <= iNum; i++) 
  { 
     pItem = new class CItem; 
     if (_bInitItemAttr(pItem, cItemName) == false) 
     { 
        delete pItem; 
     } 
     else { 
                                 
        if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) { 
           if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0; 
            
           wsprintf(G_cTxt, "(*) Get HeroItem : Char(%s) Player-EK(%d) Player-Contr(%d) Hero Obtained(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iEnemyKillCount, m_pClientList[iClientH]->m_iContribution,cItemName); 
           PutLogFileList(G_cTxt); 

           pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER; 
           pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1; 
           pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2; 
           pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3; 

           dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
           *dwp = MSGID_NOTIFY; 
           wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
           *wp  = DEF_NOTIFY_ITEMOBTAINED; 
           cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 

           *cp = 1; 
           cp++; 
            
           memcpy(cp, pItem->m_cName, 20); 
           cp += 20; 
            
           dwp  = (DWORD *)cp; 
           *dwp = pItem->m_dwCount; 
           cp += 4; 
            
           *cp = pItem->m_cItemType; 
           cp++; 
            
           *cp = pItem->m_cEquipPos; 
           cp++; 
            
           *cp = (char)0;
           cp++; 
            
           sp  = (short *)cp; 
           *sp = pItem->m_sLevelLimit; 
           cp += 2; 
            
           *cp = pItem->m_cGenderLimit; 
           cp++; 
            
           wp = (WORD *)cp; 
           *wp = pItem->m_wCurLifeSpan; 
           cp += 2; 
            
           wp = (WORD *)cp; 
           *wp = pItem->m_wWeight; 
           cp += 2; 
            
           sp  = (short *)cp; 
           *sp = pItem->m_sSprite; 
           cp += 2; 
            
           sp  = (short *)cp; 
           *sp = pItem->m_sSpriteFrame; 
           cp += 2; 

           *cp = pItem->m_cItemColor; 
           cp++; 

           *cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
           cp++; 
            
           dwp = (DWORD *)cp; 
           *dwp = pItem->m_dwAttribute; 
           cp += 4; 
           /* 
           *cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item??? ?? 
           cp++; 
           */ 
                                 
           if (iEraseReq == 1) delete pItem; 
            
           iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53); 
            
           iCalcTotalWeight(iClientH); 
            
           switch (iRet) { 
           case DEF_XSOCKEVENT_QUENEFULL: 
           case DEF_XSOCKEVENT_SOCKETERROR: 
           case DEF_XSOCKEVENT_CRITICALERROR: 
           case DEF_XSOCKEVENT_SOCKETCLOSED: 
              DeleteClient(iClientH, true, true); 
              return; 
           } 

           SendNotifyMsg(0, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, 0, 0, 0); 
        } 
        else 
        { 
           delete pItem; 

           iCalcTotalWeight(iClientH); 

           dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
           *dwp = MSGID_NOTIFY; 
           wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
           *wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM; 
            
           iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6); 
           switch (iRet) { 
           case DEF_XSOCKEVENT_QUENEFULL: 
           case DEF_XSOCKEVENT_SOCKETERROR: 
           case DEF_XSOCKEVENT_CRITICALERROR: 
           case DEF_XSOCKEVENT_SOCKETCLOSED: 

              DeleteClient(iClientH, true, true); 
              return; 
           } 
        } 
     } 
   } 
}

void CGame::_SetItemPos(int iClientH, char *pData)
{
 char * cp, cItemIndex;
 short * sp, sX, sY;

	if (m_pClientList[iClientH] == 0) return;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cItemIndex = *cp;
	cp++;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	// Àß¸øµÈ ÁÂÇ¥°ª º¸Á¤ 
	if (sY < -10) sY = -10; 

	if ((cItemIndex < 0) || (cItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemIndex] != 0) {
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].x = sX;
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].y = sY;
	}
}

void CGame::CheckUniqueItemEquipment(int iClientH)
{
 int i, iDamage;

	if (m_pClientList[iClientH] == 0) return;
	// v1.3 À¯´ÏÅ© ¾ÆÀÌÅÛÀÇ ÀåÂø »óÅÂ¸¦ ÆÇ´ÜÇÑ´Ù. Æ¯Á¤ÀÎ¸¸ÀÌ Âø¿ë °¡´ÉÇÑ ¾ÆÀÌÅÛÀ» ÀåÂøÇÑ °æ¿ì ¹þ°ÜÁø´Ù.

	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) &&
			 (m_pClientList[iClientH]->m_bIsItemEquipped[i] ) ) {
			// Touch Effect TypeÀÌ DEF_ITET_OWNERÀÌ¸é Touch Effect Value 1, 2, 3ÀÌ ÁÖÀÎ Ä³¸¯ÅÍÀÇ °íÀ¯°ªÀ» °®´Â´Ù. 
						
			if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3) ) {
				// ID °ªÀÌ ¸Â´Ù.
			}
			else {
				// ÀÚ½ÅÀÇ °ÍÀÌ ¾Æ´Ï¹Ç·Î Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, 0, 0);
				ReleaseItemHandler(iClientH, i, true);
				// v1.4 ´ë¹ÌÁö¸¦ ¾ò´Â´Ù. 
				iDamage = iDice(10, 10);
				m_pClientList[iClientH]->m_iHP -= iDamage;
				if (m_pClientList[iClientH]->m_iHP <= 0) {
					ClientKilledHandler(iClientH, 0, 0, iDamage);
				}
			}
		}
	}
}

void CGame::_BWM_Init(int iClientH, char *pData)
{
	if (m_pClientList[iClientH] == 0) return;

	m_pClientList[iClientH]->m_bIsBWMonitor = true;
	wsprintf(G_cTxt, "(*) BWMonitor(%d) registered.", iClientH);
	PutLogList(G_cTxt);
}

void CGame::_BWM_Command_Shutup(char *pData)
{
 char * cp, cName[11];
 int i;

	cp = (char *)(pData + 16);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);

	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != 0) {
		if (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0) {
			m_pClientList[i]->m_iTimeLeft_ShutUp = 20*3*10; // 1ÀÌ 3ÃÊ´Ù. 20ÀÌ¸é 1ºÐ ¿åÀ» ÇÏ¸é ¹«Á¶°Ç Æä³ÎÆ¼ 10ºÐ  
			SendNotifyMsg(0, i, DEF_NOTIFY_PLAYERSHUTUP, 20*3*10, 0, 0, cName);
			
			// Admin Log
			wsprintf(G_cTxt, "BWordMonitor shutup(%s %d)", cName, 20*3*10);
			PutAdminLogFileList(G_cTxt);

			return;
		}
	}
}


void CGame::ExchangeItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char *pItemName)
{
 short sOwnerH;
 char  cOwnerType;
 
	if (m_pClientList[iClientH] == 0) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if ((m_bAdminSecurity ) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount < iAmount) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange ) return;
	if (m_pClientList[iClientH]->m_bIsExchangeMode ) return;
	if (wObjectID >= DEF_MAXCLIENTS) return;

	//   ȯϰڴٴ ޽ ߴ. 濡 ˸   ȯâ  Ѵ. 
	// dX, dY ִ Ʈ Һ  ǳش. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	

	if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {

		if ((m_bAdminSecurity ) && (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0)){
			return;
		}

		// v1.4 ְ  ü ´ ǴѴ.
		if (wObjectID != 0) { 
			if (wObjectID < 10000) {
				// ÷̾ 
				if (m_pClientList[wObjectID] != 0) {
					if ((WORD)sOwnerH != wObjectID) sOwnerH = 0;
				}
			}
			else sOwnerH = 0;
		}
		
		if ((sOwnerH == 0) || (m_pClientList[sOwnerH] == 0)) {
			//¾ÆÀÌÅÛ ±³È¯À» ¿äÃ»ÇÑ ÇÃ·¹ÀÌ¾î¿¡°Ô ÇØ´ç À§Ä¡¿¡ ÇÃ·¹ÀÌ¾î°¡ ¾øÀ½À» ¾Ë¸°´Ù. 
			_ClearExchangeStatus(iClientH); 
		}
		else {
			if ((m_pClientList[sOwnerH]->m_bIsExchangeMode ) || (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) ||
				(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_bIsFightZone )) {
				// »ó´ë¹æÀÌ ÀÌ¹Ì ±³È¯ ÁßÀÌ°Å³ª ÀüÅõ¸ðµå, È¤Àº »çÅõÀåÀÌ´Ù. ±³È¯¸ðµå·Î µé¾î°¥ ¼ö ¾ø´Ù. 
				_ClearExchangeStatus(iClientH);
			}
			else {
				// ±³È¯¸ðµå°¡ ½ÃÀÛµÇ¾ú´Ù. ÀÎµ¦½º, ÀÌ¸§ ÀúÀå  
				m_pClientList[iClientH]->m_bIsExchangeMode = true;
				m_pClientList[iClientH]->m_iExchangeH = sOwnerH;
				ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
				strcpy(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[sOwnerH]->m_cCharName);


				//Clear items in the list
				m_pClientList[iClientH]->iExchangeCount = 0;
				m_pClientList[sOwnerH]->iExchangeCount = 0;
				for(int i=0; i<4 ; i++){
					//Clear the trader
					ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName[i], sizeof(m_pClientList[iClientH]->m_cExchangeItemName[i]));
					m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
					m_pClientList[iClientH]->m_iExchangeItemAmount[i] = 0;
					//Clear the guy we're trading with
					ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeItemName[i], sizeof(m_pClientList[sOwnerH]->m_cExchangeItemName[i]));
					m_pClientList[sOwnerH]->m_cExchangeItemIndex[i] = -1;
					m_pClientList[sOwnerH]->m_iExchangeItemAmount[i] = 0;
				}

				// ±³È¯ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛ ÀÎµ¦½º, ¼ö·® ÀúÀå 
				m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount]  = (char)sItemIndex;
				m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

				//ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
				memcpy(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->iExchangeCount], m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, 20);
				
				m_pClientList[sOwnerH]->m_bIsExchangeMode  = true;
				m_pClientList[sOwnerH]->m_iExchangeH = iClientH;
				ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeName, sizeof(m_pClientList[sOwnerH]->m_cExchangeName));
				strcpy(m_pClientList[sOwnerH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName);

				m_pClientList[iClientH]->iExchangeCount++;
				SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex+1000, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);

				SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);
			}
		}
	}
	else {
		// NPC¿Í´Â ¹°°ÇÀ» ±³È¯ÇÒ ¼ö ¾ø´Ù.
		_ClearExchangeStatus(iClientH);

	}
}

void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)
{
 int iExH;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange ) return;
	if (m_pClientList[iClientH]->iExchangeCount > 4) return;	//only 4 items trade

	//no admin trade
	if ((m_bAdminSecurity ) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)){
		_ClearExchangeStatus(m_pClientList[iClientH]->m_iExchangeH);
		_ClearExchangeStatus(iClientH);
	}


	if ((m_pClientList[iClientH]->m_bIsExchangeMode ) && (m_pClientList[iClientH]->m_iExchangeH != 0)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		if ( (m_pClientList[iExH] == 0) || (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ) {
			// ȯ  ų ȯϰ ߴ  ĳͰ ƴϴ. 	

		}
		else {
			// ȯϰ ϴ 濡  ˷ش. 
			// ش  ϴ,  ´ üũѴ. 
			if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount < iAmount) return;

			//No Duplicate items
			for(int i=0; i<m_pClientList[iClientH]->iExchangeCount;i++){
				if (m_pClientList[iClientH]->m_cExchangeItemIndex[i] == (char)iItemIndex) {
					_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(iClientH);
					return;
				}
			}

			// ȯϰ ϴ  ε,   
			m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount]  = (char)iItemIndex;
			m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

			//ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
			memcpy(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->iExchangeCount], m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);

			//m_pClientList[iClientH]->m_cExchangeItemIndex  = iItemIndex;
			//m_pClientList[iClientH]->m_iExchangeItemAmount = iAmount;
			//ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
			//memcpy(m_pClientList[iClientH]->m_cExchangeItemName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);
			
			m_pClientList[iClientH]->iExchangeCount++;
			SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex+1000, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute); 

			SendNotifyMsg(iClientH, iExH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
		}
	}
	else {
		// ȯ 尡 ƴϹǷ 
	}
}

void CGame::ConfirmExchangeItem(int iClientH)
{
 int iExH, i;
 int iItemWeightA, iItemWeightB, iWeightLeftA, iWeightLeftB, iAmountLeft;
 class CItem * pItemA[4], * pItemB[4], * pItemAcopy[4], * pItemBcopy[4];
 
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange ) return;
	if ((m_bAdminSecurity ) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
		

	if ((m_pClientList[iClientH]->m_bIsExchangeMode ) && (m_pClientList[iClientH]->m_iExchangeH != 0)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
	
		// v1.42  ̷ 찡?
		if (iClientH == iExH) return;

		if (m_pClientList[iExH] != 0) {
			if ( (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ||
			     (m_pClientList[iExH]->m_bIsExchangeMode != true) ||
				 (memcmp(m_pClientList[iExH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName, 10) != 0) ) {
				// ȯϰ ߴ  ĳͰ ƴϴ. ȯ ´ .
				_ClearExchangeStatus(iClientH);
				_ClearExchangeStatus(iExH);
				return;
			}
			else {
				m_pClientList[iClientH]->m_bIsExchangeConfirm = true;
				if (m_pClientList[iExH]->m_bIsExchangeConfirm ) {
					// 浵 ȯǻ縦 . ȯ   ִ Ѵ.  ,   Ǵ.
					
					//Check all items
					for(i=0; i<m_pClientList[iClientH]->iExchangeCount; i++){
						if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] == 0) ||
							(memcmp(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName, m_pClientList[iClientH]->m_cExchangeItemName[i], 20) != 0)) {
							_ClearExchangeStatus(iClientH);
							_ClearExchangeStatus(iExH);
							return;
						}
					}
					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++){
						if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] == 0) ||
							(memcmp(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName, m_pClientList[iExH]->m_cExchangeItemName[i], 20) != 0)) {
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
							}
					}

					iWeightLeftA = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
					iWeightLeftB = _iCalcMaxLoad(iExH) - iCalcTotalWeight(iExH);

					//Calculate weight for items
					iItemWeightA = 0;
					for(i=0; i<m_pClientList[iClientH]->iExchangeCount; i++){
						iItemWeightA = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]],
							m_pClientList[iClientH]->m_iExchangeItemAmount[i]);
					}
					iItemWeightB = 0;
					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++){
						iItemWeightB = iGetItemWeight(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]],
							m_pClientList[iExH]->m_iExchangeItemAmount[i]);
					}

					//See if the other person can take the item weightload
					if ((iWeightLeftA < iItemWeightB) || (iWeightLeftB < iItemWeightA)) {
						// ȯϰ ϴ   ԰ . ȯ Ұ. 
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}

					for(i=0; i<m_pClientList[iClientH]->iExchangeCount; i++){
						//  ִ     Ѿ  ִ.
						if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {

								if (m_pClientList[iClientH]->m_iExchangeItemAmount[i] > m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount) {
									// ȯϰ ߴ   . ׵ پ.
									_ClearExchangeStatus(iClientH);
									_ClearExchangeStatus(iExH);
									return;		
								}
								pItemA[i] = new class CItem;
								_bInitItemAttr(pItemA[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
								pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];

								// α׸    繰 
								pItemAcopy[i] = new class CItem;
								_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
								bCopyItemContents(pItemAcopy[i], pItemA[i]);
								pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
							}
						else {
							pItemA[i] = (class CItem *)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]];
							pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];

							// α׸    繰 
							pItemAcopy[i] = new class CItem;
							_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemAcopy[i], pItemA[i]);
							pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
						}
					}

					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++){
						if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {

								if (m_pClientList[iExH]->m_iExchangeItemAmount[i] > m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount) {
									// ȯϰ ߴ   . ׵ پ.
									_ClearExchangeStatus(iClientH);
									_ClearExchangeStatus(iExH);
									return;		
								}
								pItemB[i] = new class CItem;
								_bInitItemAttr(pItemB[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
								pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];

								// α׸    繰 
								pItemBcopy[i] = new class CItem;
								_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
								bCopyItemContents(pItemBcopy[i], pItemB[i]);
								pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
							}
						else {
							pItemB[i] = (class CItem *)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]];
							pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];

							// α׸    繰 
							pItemBcopy[i] = new class CItem;
							_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemBcopy[i], pItemB[i]);
							pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
						}
					}

					//     
					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++){
						bAddItem(iClientH, pItemB[i], 0);
						_bItemLog(DEF_ITEMLOG_EXCHANGE, iExH, iClientH, pItemBcopy[i]);
						delete pItemBcopy[i];
						pItemBcopy[i] = 0;
						if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
								//
								iAmountLeft = (int)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iExH]->m_iExchangeItemAmount[i];
								if (iAmountLeft < 0) iAmountLeft = 0;	  
								// v1.41 !!!
								SetItemCount(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], iAmountLeft);
								// m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
								//
							}
						else {
							//   ̶ Ѵ.
							ReleaseItemHandler(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], true);
							SendNotifyMsg(0, iExH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iExH]->m_cExchangeItemIndex[i], m_pClientList[iExH]->m_iExchangeItemAmount[i], 0, m_pClientList[iClientH]->m_cCharName);
							m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] = 0;
						}
					}

					for(i=0; i<m_pClientList[iClientH]->iExchangeCount; i++){
						bAddItem(iExH, pItemA[i], 0);
						_bItemLog(DEF_ITEMLOG_EXCHANGE, iClientH, iExH, pItemAcopy[i]);
						delete pItemAcopy[i];
						pItemAcopy[i] = 0;

						if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
								//
								iAmountLeft = (int)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iClientH]->m_iExchangeItemAmount[i];
								if (iAmountLeft < 0) iAmountLeft = 0;	 
								// v1.41 !!!
								SetItemCount(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], iAmountLeft);
								// m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
								//
							}
						else {
							//   ̶ Ѵ.
							ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], true);
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iClientH]->m_cExchangeItemIndex[i], m_pClientList[iClientH]->m_iExchangeItemAmount[i], 0, m_pClientList[iExH]->m_cCharName);
							m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] = 0;
						}
					}

					m_pClientList[iClientH]->m_bIsExchangeMode = false;
					m_pClientList[iClientH]->m_bIsExchangeConfirm = false;
					ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
					m_pClientList[iClientH]->m_iExchangeH = 0;
					m_pClientList[iClientH]->iExchangeCount = 0;

					m_pClientList[iExH]->m_bIsExchangeMode = false;
					m_pClientList[iExH]->m_bIsExchangeConfirm = false;
					ZeroMemory(m_pClientList[iExH]->m_cExchangeName, sizeof(m_pClientList[iExH]->m_cExchangeName));
					m_pClientList[iExH]->m_iExchangeH = 0;
					m_pClientList[iExH]->iExchangeCount = 0;

					for(i=0;i<4;i++){
						m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
						m_pClientList[iExH]->m_cExchangeItemIndex[i] = -1;
					}

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXCHANGEITEMCOMPLETE, 0, 0, 0, 0);
					SendNotifyMsg(0, iExH,     DEF_NOTIFY_EXCHANGEITEMCOMPLETE, 0, 0, 0, 0);

					//  缳
					iCalcTotalWeight(iClientH);
					iCalcTotalWeight(iExH);
					return;
				}
			}
		}
		else {
			// ȯ  . ȯ  ȴ.
			_ClearExchangeStatus(iClientH);
			return;
		}
	}
}

int CGame::_iGetItemSpaceLeft(int iClientH)
{
 int i, iTotalItem;

	iTotalItem = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != 0) iTotalItem++;

	return (DEF_MAXITEMS - iTotalItem);
}

bool CGame::bAddItem(int iClientH, CItem * pItem, char cMode)
{
 char * cp, cData[256];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int iRet, iEraseReq;


	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1°³ È¹µæÇß´Ù. Amount°¡ ¾Æ´Ï´Ù!
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	// ¼ö·®À» ÀÔ·Â 
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		cp++;
		*/
		
		if (iEraseReq == 1) {
			//testcode
			//wsprintf(G_cTxt, "AddItem: Delete (%s)", pItem->m_cName);
			//PutLogFileList(G_cTxt);
			delete pItem;
			pItem = 0;
		}
		
		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		
		return true;
	}
	else {
		// ¾ÆÀÌÅÛÀ» Àü´Þ¹ÞÀº Ä³¸¯ÅÍ°¡ ´õÀÌ»ó ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¼ö ¾ø´Â »óÅÂÀÌ´Ù.
		// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                         m_pClientList[iClientH]->m_sY, 
			                                                         pItem);
		
		// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
									pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4 color
		
		// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		
		return true;
	}

	return false;
}


int CGame::_iTalkToNpcResult_Cityhall(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int iQuest, iEraseReq;
 class CItem * pItem;
 DWORD iExp;

	if (m_pClientList[iClientH] == 0) return 0;

	if (m_pClientList[iClientH]->m_iQuest != 0) {
		if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest] == 0) return -4;
		else if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iFrom == 4) {
			if (m_pClientList[iClientH]->m_bIsQuestCompleted ) {
				if ( (m_pClientList[iClientH]->m_iQuestRewardType > 0) &&
					 (m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType] != 0) ) {
					pItem = new class CItem;
					_bInitItemAttr(pItem, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName);
					pItem->m_dwCount = m_pClientList[iClientH]->m_iQuestRewardAmount;
					if (_bCheckItemReceiveCondition(iClientH, pItem) ) {
						_bAddClientItemList(iClientH, pItem, &iEraseReq);
						SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
						if (iEraseReq == 1) delete pItem;
						
						m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

						SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);
						
						_ClearQuestStatus(iClientH);
						return -5;
					} 
					else {
						delete pItem;
						SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);

						SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 0, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

						return -5;
					}
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -1) {
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iQuestRewardAmount;
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							      "°æÇèÄ¡              ", m_pClientList[iClientH]->m_iContribution);
					
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -2) {
					iExp = iDice(1, (10*m_pClientList[iClientH]->m_iLevel));
					iExp = iExp * m_pClientList[iClientH]->m_iQuestRewardAmount;
					
					m_pClientList[iClientH]->m_iExpStock += iExp;
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, iExp, 
							      "°æÇèÄ¡              ", m_pClientList[iClientH]->m_iContribution);
					
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else {
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, 0, 
							      "                     ", m_pClientList[iClientH]->m_iContribution);
					
					_ClearQuestStatus(iClientH);
					return -5;
				}
			}
			else return -1;
		}
		
		return -4;
	}
	
	if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) == 0) {
		if (m_pClientList[iClientH]->m_iPKCount > 0) return -3;
		
		iQuest = __iSearchForQuest(iClientH, 4, pQuestType, pMode, pRewardType, pRewardAmount, pContribution, pTargetName, pTargetType, pTargetCount, pX, pY, pRange);
		if (iQuest <= 0) return -4;

		return iQuest;
	}
	else return -2;

	return -4;
}


int CGame::_iTalkToNpcResult_Guard(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
	if (m_pClientList[iClientH] == 0) return 0;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (200), 0, 0, 0, 0);
			return 1000;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (201), 0, 0, 0, 0);
			return 1001;
		}
	}
	else
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (202), 0, 0, 0, 0);
			return 1002;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (203), 0, 0, 0, 0);
			return 1003;
		}
	}
	else
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (204), 0, 0, 0, 0);
			return 1004;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (205), 0, 0, 0, 0);
			return 1005;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "default", 7) == 0) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (206), 0, 0, 0, 0);
			return 1006;
		}
	}

	return 0;
}


bool CGame::_bDecodeQuestConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iQuestConfigListIndex = 0;
 class CStrTok * pStrTok;

 char cData[50000] = {};
 DWORD lpNumberOfBytesRead;
 HANDLE hFile = CreateFile(pData, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
 DWORD dwFileSize = GetFileSize(hFile, 0);
 if (dwFileSize == -1) {
	 wsprintf(G_cTxt, "(X) CRITICAL ERROR! Cannot open configuration file(%s)!", pData);
	 PutLogList(pData);
	 return false;
 }

 SetFilePointer(hFile, 0, 0, FILE_BEGIN);

 ReadFile(hFile, cData, dwFileSize, &lpNumberOfBytesRead, 0);
 CloseHandle(hFile);

 pContents = new char[dwFileSize + 1];
 ZeroMemory(pContents, dwFileSize + 1);
 memcpy(pContents, cData, dwFileSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != 0 ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Äù½ºÆ® ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					if (m_pQuestConfigList[atoi(token)] != 0) {
						// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Duplicate quest number.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[atoi(token)] = new class CQuest;
					iQuestConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// Äù½ºÆ® »çÀÌµå  
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Äù½ºÆ® Á¾·ù  
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// TargetType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTargetType = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// MaxCount
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxCount= atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iFrom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMinLevel = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxLevel = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillNum = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillLevel = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTimeLimit = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iAssignType = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[1] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[1] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[2] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[2] = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[3] = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[3] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContribution = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContributionLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iResponseMode = atoi(token);
					cReadModeB = 22;
					break;

				case 22:
					ZeroMemory(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, sizeof(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName));
					strcpy(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, token);
					cReadModeB = 23;
					break;

				case 23:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sX = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sY = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRange = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iQuestID = atoi(token);
					cReadModeB = 27;
					break;

				case 27:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iReqContribution = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "quest", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) QUEST(Total:%d) configuration - success!", iQuestConfigListIndex);
	PutLogList(cTxt);

	return true;
}


int CGame::__iSearchForQuest(int iClientH, int iWho, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int i, iQuestList[DEF_MAXQUESTTYPE], iIndex, iQuest, iReward, iQuestIndex;

	if (m_pClientList[iClientH] == 0) return -1;
 
	// ÀûÇÕÇÑ ¹Ì¼Ç ¹è¿­ ÃÊ±âÈ­.
	iIndex = 0;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		iQuestList[i] = -1;

	for (i = 1; i < DEF_MAXQUESTTYPE; i++) 
	if (m_pQuestConfigList[i] != 0) {
		
		if (m_pQuestConfigList[i]->m_iFrom != iWho) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) {
			// °í·ÁÇØ¾ß ÇÒ ½ºÅ³ÀÌ ÀÖ´Ù. 
			if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] < 
				m_pQuestConfigList[i]->m_iRequiredSkillLevel) goto SFQ_SKIP;
		}
		
		// Å©·ç¼¼ÀÌµå ¸ðµåÀÏ¶§´Â ÇÒ´ç Å¸ÀÔÀÌ 1ÀÎ Äù½ºÆ®¸¸ ºÎ¿©µÈ´Ù.
		if ((m_bIsCrusadeMode ) && (m_pQuestConfigList[i]->m_iAssignType != 1)) goto SFQ_SKIP; 
		// Å©·ç¼¼ÀÌµå ¸ðµå°¡ ¾Æ´Ò¶§´Â ÇÒ´ç Å¸ÀÔÀÌ 1Àº ¼±ÅÃµÇÁö ¾Ê´Â´Ù.
		if ((m_bIsCrusadeMode == false) && (m_pQuestConfigList[i]->m_iAssignType == 1)) goto SFQ_SKIP; 

		if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		// ¿©±â±îÁö ¿À¸é Á¶°Ç¿¡ ÇÕ´çÇÑ Äù½ºÆ®´Ù. µî·ÏÇÑ´Ù. 
		iQuestList[iIndex] = i;
		iIndex++;

SFQ_SKIP:;
	}

	// iIndex°³ ¸¸Å­ÀÇ Á¶°Ç¿¡ ¸¸Á·ÇÏ´Â Äù½ºÆ®¸¦ Ã£¾Ò´Ù. ±× Áß¿¡¼­ ·£´ýÇÏ°Ô 1°³¸¦ ¼±ÅÃÇÑ´Ù.
	if (iIndex == 0) return -1;
	iQuest		 = (iDice(1, iIndex)) - 1;
	iQuestIndex  = iQuestList[iQuest];
	// Äù½ºÆ® ÀÎµ¦½º 
	iReward = iDice(1,3);
	*pMode = m_pQuestConfigList[iQuestIndex]->m_iResponseMode;					// Äù½ºÆ® ÀÀ´ä ¸ðµå 
	*pRewardType   = m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward];	// Äù½ºÆ® »óÇ° Á¾·ù 
	*pRewardAmount = m_pQuestConfigList[iQuestIndex]->m_iRewardAmount[iReward];	// Äù½ºÆ® »óÇ° °¹¼ö 
	*pContribution = m_pQuestConfigList[iQuestIndex]->m_iContribution;			// Äù½ºÆ® ÇØ°á½Ã ¿Ã¶ó°¡´Â °øÇåµµ 
	
	strcpy(pTargetName, m_pQuestConfigList[iQuestIndex]->m_cTargetName);			// Äù½ºÆ® ¸Ê ÀÌ¸§ ¼ö·Ï 
	*pX     = m_pQuestConfigList[iQuestIndex]->m_sX;
	*pY     = m_pQuestConfigList[iQuestIndex]->m_sY;
	*pRange = m_pQuestConfigList[iQuestIndex]->m_iRange;

	*pTargetType  = m_pQuestConfigList[iQuestIndex]->m_iTargetType;
	*pTargetCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
	*pQuestType   = m_pQuestConfigList[iQuestIndex]->m_iType;

	return iQuestIndex;
}

// New 14/05/2004
void CGame::QuestAcceptedHandler(int iClientH)
{
 int iIndex;

	if (m_pClientList[iClientH] == 0) return;
	
	// Does the quest exist ??
	if(m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest] == 0) return;

	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iAssignType == 1) {
		// Àü¸éÀü¿ë Äù½ºÆ®ÀÌ´Ù. 
		switch (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iType) {
		case 10: // ÅÚ·¹Æ÷Æ®¿ë 1È¸¼º Äù½ºÆ®. ÅÚ·¹Æ÷Æ®ÇÏ°í ³ª¸é ³¡ÀÌ´Ù. ´õÀÌ»óÀÇ Äù½ºÆ® ¿©ºÎ°¡ ¾øÀ½.
			_ClearQuestStatus(iClientH);
			RequestTeleportHandler(iClientH, "2   ", m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_cTargetName,
				                   m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sX, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sY);
			return;
		}
	}

	// ÇÃ·¹ÀÌ¾î°¡ Äù½ºÆ®¸¦ ¼ö¶ôÇß´Ù. Äù½ºÆ® ¹øÈ£, ID°ª ÇÒ´ç.
	m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iAskedQuest;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	m_pClientList[iClientH]->m_iQuestID = m_pQuestConfigList[iIndex]->m_iQuestID;
	m_pClientList[iClientH]->m_iCurQuestCount    = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = false;
	
	_CheckQuestEnvironment(iClientH);
	_SendQuestContents(iClientH);
}


void CGame::_SendQuestContents(int iClientH)
{
 int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted;
 char cTargetName[21];

	if (m_pClientList[iClientH] == 0) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == 0) {
		// ÇÒ´çµÈ Quest°¡ ¾ø´Ù. 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCONTENTS, 0, 0, 0, 0,  
		              0, 0, 0, 0, 0, 0, 0);
	}
	else {
		// ÇÒ´çµÈ Quest ³»¿ëÀ» º¸³»ÁØ´Ù.
		iWho          = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType    = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType   = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount  = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX            = m_pQuestConfigList[iIndex]->m_sX;
		iY            = m_pQuestConfigList[iIndex]->m_sY;
		iRange        = m_pQuestConfigList[iIndex]->m_iRange;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, 0,  
			          iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
	}
}

void CGame::_CheckQuestEnvironment(int iClientH)
{
 int iIndex;
 char cTargetName[21];

	if (m_pClientList[iClientH] == 0) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == 0) return;
	if (m_pQuestConfigList[iIndex] == 0) return;

	if (iIndex >= 35 && iIndex <= 40) {
		m_pClientList[iClientH]->m_iQuest = 0;
		m_pClientList[iClientH]->m_iQuestID = 0;
		m_pClientList[iClientH]->m_iQuestRewardAmount = 0;
		m_pClientList[iClientH]->m_iQuestRewardType   = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTABORTED, 0, 0, 0, 0);
		return;
	}

	if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) {
		// Äù½ºÆ® ID °ªÀÌ ´Ù¸£´Ù. ÇÒ´ç¹Þ¾Ò´ø ±× Äù½ºÆ®°¡ ¾Æ´Ï´Ù. Äù½ºÆ®´Â Ãë¼ÒµÈ´Ù.
		m_pClientList[iClientH]->m_iQuest   = 0;
		m_pClientList[iClientH]->m_iQuestID = 0;
		m_pClientList[iClientH]->m_iQuestRewardAmount = 0;
		m_pClientList[iClientH]->m_iQuestRewardType   = 0;
		
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTABORTED, 0, 0, 0, 0);
		return;
	}

	switch (m_pQuestConfigList[iIndex]->m_iType) {
	case DEF_QUESTTYPE_MONSTERHUNT:
	case DEF_QUESTTYPE_GOPLACE:
		// ¸ó½ºÅÍ »ç³ÉÀÇ °æ¿ì ¸Å¹ø ¸ó½ºÅÍ »ç³É½Ã ¸Ê ÀÌ¸§À» ºñ±³ÇÏ´Â °ÍÀº ºñÈ¿À²ÀûÀÌ¹Ç·Î ¹Ì¸® ¸Ê ÀÌ¸§À» ºñ±³, ÇÃ·¡±×¸¦ ¼³Á¤ÇØ ³õ´Â´Ù. 
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cTargetName, 10) == 0)
			 m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = true;
		else m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = false;
		break;
	}

}

bool CGame::_bCheckIsQuestCompleted(int iClientH)
{
 int iQuestIndex;

	// Äù½ºÆ®°¡ Á¾·áµÇ¾ú´ÂÁö ÆÇ´ÜÇÑ ÈÄ ¸Þ½ÃÁö Ã³¸®.
	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_bIsQuestCompleted ) return false;
	iQuestIndex = m_pClientList[iClientH]->m_iQuest;
	if (iQuestIndex == 0) return false;
		
	if (m_pQuestConfigList[iQuestIndex] != 0) {
		switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
		case DEF_QUESTTYPE_MONSTERHUNT:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc ) && 
				 (m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) ) {
				// ¸ó½ºÅÍ »ç³É Äù½ºÆ®°¡ ¿Ï·áµÇ¾ú´Ù. ¿Ï·áµÇ¾úÀ¸¸é ÀÇ·ÚÀÎ¿¡°Ô µ¹¾Æ°¡ ´ëÈ­¸¦ ÇÏ¸é Æ÷»ó¹Þ´Â´Ù. 
				m_pClientList[iClientH]->m_bIsQuestCompleted = true;					
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOMPLETED, 0, 0, 0, 0);
				return true;
			}
			break;

		case DEF_QUESTTYPE_GOPLACE:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc ) && // ¸ÊÀº ¸Â°í
				 (m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) && // ÁÂÇ¥µµ ÀÌ³»ÀÌ¸é 
				 (m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange) ) {
				// Æ¯Á¤ Àå¼Ò Ã£¾Æ°¡±â Äù½ºÆ® ¿Ï·á.
				m_pClientList[iClientH]->m_bIsQuestCompleted = true;					
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOMPLETED, 0, 0, 0, 0);
				return true;
			}
			break;
		}
	}

	return false;
}

int CGame::_iTalkToNpcResult_GuildHall(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_GShop(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_BSmith(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WHouse(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WTower(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

void CGame::SendItemNotifyMsg(int iClientH, WORD wMsgType, CItem *pItem, int iV1)
{
 char  * cp, cData[512];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;

	if (m_pClientList[iClientH] == 0) return;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	switch (wMsgType) {
	case DEF_NOTIFY_ITEMOBTAINED:
		*cp = 1; // 1°³ È¹µæÇß´Ù. <- ¿©±â¼­ 1°³¶õ ¼ö·® Ä«¿îÆ®¸¦ ¸»ÇÏ´Â °ÍÀÌ ¾Æ´Ï´Ù
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor; // v1.4
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		cp++;
		*/

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		break;
	
	case DEF_NOTIFY_ITEMPURCHASED:
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;
		
		wp  = (WORD *)cp;
		*wp = iV1; // (iCost - iDiscountCost);
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
		iRet =m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}
}

bool CGame::_bCheckItemReceiveCondition(int iClientH, CItem *pItem)
{
 int i;

	if (m_pClientList[iClientH] == 0) return false;

	if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount) > (DWORD)_iCalcMaxLoad(iClientH)) 
		return false;
		
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == 0) return true;

	return false;
}

void CGame::_ClearQuestStatus(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	m_pClientList[iClientH]->m_iQuest   = 0;
	m_pClientList[iClientH]->m_iQuestID = 0;
	m_pClientList[iClientH]->m_iQuestRewardType   = 0;
	m_pClientList[iClientH]->m_iQuestRewardAmount = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted  = false;
}

int CGame::iGetMaxHP(int iClientH)
{
 int iRet;

	if (m_pClientList[iClientH] == 0) return 0;

	iRet = m_pClientList[iClientH]->m_iVit*3 + m_pClientList[iClientH]->m_iLevel*2 + (m_pClientList[iClientH]->m_iStr+ m_pClientList[iClientH]->m_iAngelicStr)/2;
	
	if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
		iRet = iRet - (iRet/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

	return iRet;
}

int CGame::iGetMaxMP(int iClientH)
{
 int iRet;

	if (m_pClientList[iClientH] == 0) return 0;

	iRet = (2*(m_pClientList[iClientH]->m_iMag+ m_pClientList[iClientH]->m_iAngelicMag)) + (2*m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt+ m_pClientList[iClientH]->m_iAngelicInt)/2);
	
	return iRet;
}

int CGame::iGetMaxSP(int iClientH)
{
 int iRet;

	if (m_pClientList[iClientH] == 0) return 0;

	iRet = (2*(m_pClientList[iClientH]->m_iStr+ m_pClientList[iClientH]->m_iAngelicStr)) + (2*m_pClientList[iClientH]->m_iLevel);
	
	return iRet;
}

void CGame::GetMapInitialPoint(int iMapIndex, short *pX, short *pY, char * pPlayerLocation)
{
 int i, iTotalPoint;
 POINT  pList[DEF_MAXINITIALPOINT];

	if (m_pMapList[iMapIndex] == 0) return;

	// ¸®½ºÆ®¸¦ ÀÛ¼ºÇÑ´Ù.
	iTotalPoint = 0;
	for (i = 0; i < DEF_MAXINITIALPOINT; i++)
	if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) {
		pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
		pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
		iTotalPoint++;
	}

	if (iTotalPoint == 0) return;

	// v1.42 ¼Ò¼ÓÀÌ Áß¸³ÀÌ¸é ¹«Á¶°Ç Initial PointÀÇ Ã³À½À¸·Î °£´Ù.
	if ((pPlayerLocation != 0) && (memcmp(pPlayerLocation, "NONE", 4) == 0)) 
		 i = 0;
	else i = iDice(1, iTotalPoint) - 1;

	*pX = pList[i].x;
	*pY = pList[i].y;
}



void CGame::_CheckStrategicPointOccupyStatus(char cMapIndex)
{
 class CTile * pTile;
 int i, iX, iY, iSide, iValue;

	m_iStrategicStatus = 0;

	for (i = 0; i < DEF_MAXSTRATEGICPOINTS; i++)
	if (m_pMapList[cMapIndex]->m_pStrategicPointList[i] != 0) {
	
		iSide  = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iSide;
		iValue = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iValue;
		iX = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iX;
		iY = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iY;

		pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + iX + iY*m_pMapList[cMapIndex]->m_sSizeY);

		// Àü·«Àû ÁöÁ¡ÀÇ °¡ÁßÄ¡¸¦ °öÇØ¼­ ´õÇÑ´Ù. 
		m_iStrategicStatus += pTile->m_iOccupyStatus * iValue;
	}
}

void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 int iLogSockH, iRet;

	/*iTmp = (WM_ONLOGSOCKETEVENT + 1);
	iLogSockH = message - iTmp;*/

	 iTmp = WM_USER_BOT_ACCEPT;
	 iLogSockH = message - iTmp - 1;
	
	/*if (m_pSubLogSock[iLogSockH] == 0) return;

	iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);*/

	 auto p = _lclients[iLogSockH];
	 if (p == 0) return;

	 iRet = p->_sock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:

		/*wsprintf(G_cTxt, "(!!!) Log Socket Connection Established Log#(%d) Address:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);

		m_bIsSubLogSockAvailable[iLogSockH] = true;
		m_iSubLogSockActiveCount++;*/
		break;
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnClientLoginRead(iLogSockH); //OnSubLogRead(iLogSockH);
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		/*wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) BLOCKED!", iLogSockH);
		PutLogList(G_cTxt);*/
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		wsprintf(G_cTxt, "<%d> Confirmcode Login notmatch!", iLogSockH);
		PutLogList(G_cTxt);
		DeleteLoginClient(iLogSockH);
		break;
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		/*delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = 0;
		m_bIsSubLogSockAvailable[iLogSockH] = false;
		
		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;

		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connection lost!", iLogSockH);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
		
		m_pSubLogSock[iLogSockH] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[iLogSockH]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + iLogSockH + 1));
		m_pSubLogSock[iLogSockH]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!!!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);*/
		
		break;
	}
}

LoginClient::~LoginClient()
{
	if (_sock)
		delete _sock;
}

void CGame::OnClientLoginRead(int h)
{
	char* pData, cKey;
	DWORD  dwMsgSize;

	if (_lclients[h] == 0) return;

	pData = _lclients[h]->_sock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, h, cKey) == false) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}

void CGame::DeleteLoginClient(int h)
{
	if (!_lclients[h])
		return;

	_lclients[h]->_timeout_tm = timeGetTime();
	_lclients_disconn.push_back(_lclients[h]);
	//delete _lclients[h];
	_lclients[h] = nullptr;
}

void CGame::OnSubLogRead(int iIndex)
{
 /*DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, 0, cKey) == false) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}*/	
}

void CGame::_CheckGateSockConnection()
{
	/*if (m_bIsServerShutdowned ) return;

	if (m_iGateSockConnRetryTimes != 0) {
		wsprintf(G_cTxt, "(!!!) Gate-socket connection counting...%d", m_iGateSockConnRetryTimes); 
		PutLogList(G_cTxt);
		m_iGateSockConnRetryTimes++;
	}

	if (m_iGateSockConnRetryTimes > 20) {
		if (m_bOnExitProcess == false) {
			m_iFinalShutdownCount = 1;
			m_bOnExitProcess     = true;
			m_dwExitProcessTime  = timeGetTime();
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by gate-server connection Lost)!!!");
		}
	}*/
}

bool CGame::_bCheckSubLogSocketIndex()
{
 /*int  iCnt;
 bool bLoopFlag;

	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;

	iCnt = 0;
	bLoopFlag = false;
	while (bLoopFlag == false) {
		if ((m_pSubLogSock[m_iCurSubLogSockIndex] != 0) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] )) 
			 bLoopFlag = true;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			if (m_bOnExitProcess == false) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = true;
				m_dwExitProcessTime  = timeGetTime();
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Log-server connection Lost)!!!");
			}
			return false;
		}
	}*/

	return true;
}

bool CGame::_bDecodeBuildItemConfigFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  i, iIndex = 0;
 class CStrTok * pStrTok;
 class CItem * pItem;

 char cData[50000] = {};
 DWORD lpNumberOfBytesRead;
 HANDLE hFile = CreateFile(pData, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
 DWORD dwFileSize = GetFileSize(hFile, 0);
 if (dwFileSize == -1) {
	 wsprintf(G_cTxt, "(X) CRITICAL ERROR! Cannot open configuration file(%s)!", pData);
	 PutLogList(pData);
	 return false;
 }

 SetFilePointer(hFile, 0, 0, FILE_BEGIN);

 ReadFile(hFile, cData, dwFileSize, &lpNumberOfBytesRead, 0);
 CloseHandle(hFile);

 pContents = new char[dwFileSize + 1];
 ZeroMemory(pContents, dwFileSize + 1);
 memcpy(pContents, cData, dwFileSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != 0 ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ¾ÆÀÌÅÛ ÀÌ¸§ 
					ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
					memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));
										
					cReadModeB = 2;
					break;

				case 2:
					// ½ºÅ³ Á¦ÇÑÄ¡ 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format(1).");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[0] = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[0] = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[0] = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[1] = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[1] = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[1] = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[2] = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[2] = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[2] = atoi(token);
					cReadModeB = 12;
					break;


				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[3] = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[3] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[3] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[4] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[4] = atoi(token);
					
					cReadModeB = 17;
					break;

				case 17:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[4] = atoi(token);
					
					cReadModeB = 18;
					break;

				
				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[5] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[5] = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[5] = atoi(token);
					
					cReadModeB = 21;
					break;



				case 21:
					// m_iAverageValue
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iAverageValue = atoi(token);
					
					cReadModeB = 22;
					break;

				case 22:
					// m_iMaxSkill
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);
					
					cReadModeB = 23;
					break;

				case 23:
					// m_wAttribute
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					m_pBuildItemList[iIndex]->m_wAttribute = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					
					pItem = new class CItem;
					if (_bInitItemAttr(pItem, m_pBuildItemList[iIndex]->m_cName) ) {
						// ¾ÆÀÌÅÛÀÇ Á¸Àç°¡ È®ÀÎµÇ¾ú´Ù.
						m_pBuildItemList[iIndex]->m_sItemID = pItem->m_sIDnum;

						// ÃÖ´ë °¡ÁßÄ¡°ª °è»ê
						for (i = 0; i < 6; i++)
							m_pBuildItemList[iIndex]->m_iMaxValue += (m_pBuildItemList[iIndex]->m_iMaterialItemValue[i]*100);

						iIndex++;	
					}
					else {
						// ÀÌ·± ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛÀÌ Á¸ÀçÇÏÁö ¾Ê´Â´Ù. ¿¡·¯ 
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! BuildItem configuration file error - Not Existing Item(%s)", m_pBuildItemList[iIndex]->m_cName);
						PutLogList(G_cTxt);
						
						delete m_pBuildItemList[iIndex];
						m_pBuildItemList[iIndex] = 0;
						
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					delete pItem;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "BuildItem", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) BuildItem(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);

	return true;
}


void CGame::BuildItemHandler(int iClientH, char *pData)
{
 char * cp, cName[21], cElementItemID[6];
 int    i, x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[DEF_MAXITEMS];
 class  CItem * pItem;
 bool   bFlag, bItemFlag[6];
 double dV1, dV2, dV3;
 DWORD  dwTemp, dwTemp2;
 WORD   wTemp;

	// ڰ   ûߴ. 
	if (m_pClientList[iClientH] == 0) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	cp = (char *)(pData + 11);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	//testcode
	//PutLogList(cName);

	ZeroMemory(cElementItemID, sizeof(cElementItemID));
	cElementItemID[0] = *cp;
	cp++;
	cElementItemID[1] = *cp;
	cp++;
	cElementItemID[2] = *cp;
	cp++;
	cElementItemID[3] = *cp;
	cp++;
	cElementItemID[4] = *cp;
	cp++;
	cElementItemID[5] = *cp;
	cp++;
	
	// պκ  ش.
	bFlag = true;
	while (bFlag ) {
		bFlag = false;
		for (i = 0; i <= 4; i++) 
		if ((cElementItemID[i] == -1) && (cElementItemID[i+1] != -1)) {
			cElementItemID[i] = cElementItemID[i+1];
			cElementItemID[i+1] = -1;
			bFlag = true;
		}
	}

	for (i = 0; i < 6; i++) bItemFlag[i] = false;

	//testcode
	//wsprintf(G_cTxt, "%d %d %d %d %d %d", cElementItemID[0], cElementItemID[1], cElementItemID[2],
	//	     cElementItemID[3], cElementItemID[4], cElementItemID[5]);
	//PutLogList(G_cTxt);

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[13];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		// д. 
		//  ۿ Ͽ.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_BUILDITEMFAIL, 0, 0, 0, 0);
		return;
	}

	//    ϴ ˻.
	for (i = 0; i < 6; i++)
	if (cElementItemID[i] != -1) {
		// ߸ Item ID̴. 
		if ((cElementItemID[i] < 0) || (cElementItemID[i] > DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] == 0) return;		
	}

	// ش ̸     Ʈ ã´.
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pBuildItemList[i] != 0) {
		if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {
			//  ãҴ.  ǰ  ġϴ ˻.
			
			// ų Ƽ  Ұ.  Ŭ̾Ʈ ɷ . 
			if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;
						
			for (x = 0; x < DEF_MAXITEMS; x++) 
			if (m_pClientList[iClientH]->m_pItemList[x] != 0) 
				 iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
			else iItemCount[x] = 0;
			
			// ش   ᰡ  ˻Ѵ. Ҿ   ġ  .
			iMatch = 0;
			iTotalValue = 0;
			
			for (x = 0; x < 6; x++) {
				if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
					iMatch++;
				}
				else {
					for (z = 0; z < 6; z++) 
					if ((cElementItemID[z] != -1) && (bItemFlag[z] == false)) {
												
						if ((m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
							(m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
							(iItemCount[cElementItemID[z]] > 0)) {
							//  ϳ ãҴ. 
							iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
							if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[13]) {
								//    ų  ȸѴٸ  . 
								iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[13])/2;
							}

							iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
							iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
							iMatch++;
							bItemFlag[z] = true;
						
							goto BIH_LOOPBREAK;
						}
					}
BIH_LOOPBREAK:;
				}
			}

			// ⼭ iMatch 6̸     ̴. 
			if (iMatch != 6) {
				//  .   Ұ 
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_BUILDITEMFAIL, 0, 0, 0, 0);
				return;
			}

			//   
			dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
			if (iTotalValue <= 0) 
				 dV3 = 1.0f;
			else dV3 = (double)iTotalValue;
			dV1 = (double)(dV3/dV2)*100.0f;

			// з ٲ .
			iTotalValue = (int)dV1;

			//   
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == false) {
				delete pItem;
				return;
			}

			//  Custom-Made Ÿ ÷׸ Է 
			dwTemp = pItem->m_dwAttribute;
			dwTemp = dwTemp & 0xFFFFFFFE;
			dwTemp = dwTemp | 0x00000001;
			pItem->m_dwAttribute = dwTemp;

			if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) {
				//     (װ)̶  ؿ   ԷѴ. 
				iTemp = iDice(1, (iPlayerSkillLevel/2)+1) -1;
				pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel/2) + iTemp;
				// v2.15  ۿ  ȣ ߰ 
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				pItem->m_sTouchEffectValue3 = timeGetTime();

			}
			else {
				//   ᰡ ƴϰ ⳪  
				//  Ӽ Է 
				dwTemp = pItem->m_dwAttribute;
				dwTemp = dwTemp & 0x0000FFFF;

				dwTemp2 = (WORD)m_pBuildItemList[i]->m_wAttribute;
				dwTemp2 = dwTemp2 << 16;

				dwTemp  = dwTemp | dwTemp2;
				pItem->m_dwAttribute = dwTemp;

				iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
				//    Է: SpecEffectValue1 , SpecEffectValue2  ġ 
				
				// 1.  ġ ()
				if (iResultValue > 0) {
					dV2 = (double)iResultValue;
					dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else if (iResultValue < 0) {
					dV2 = (double)(iResultValue);
					dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else pItem->m_sItemSpecEffectValue2 = 0;

				// 2. ο ִ   
				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				// v2.15  ۿ  ȣ ߰ 
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				pItem->m_sTouchEffectValue3 = timeGetTime();

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					//   ʹ     
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				}
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
				
				//Custom-Item  2. 
				pItem->m_cItemColor = 2;
			}

			//testcode
			wsprintf(G_cTxt, "Custom-Item(%s) Value(%d) Life(%d/%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2, pItem->m_wCurLifeSpan, pItem->m_wMaxLifeSpan);
			PutLogList(G_cTxt);
		
			//   
			bAddItem(iClientH, pItem, 0);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, 0, 0); // Integer ϱ  

#ifdef DEF_TAIWANLOG
			// v1.41  ̶ α׸ . 
			_bItemLog(DEF_ITEMLOG_MAKE, iClientH, (int) -1, pItem);
#endif	

			//  ᰡ Ǵ  ش. 
			for (x = 0; x < 6; x++)
			if (cElementItemID[x] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == 0) {
					// ### BUG POINT!!!
					//   .
					wsprintf(G_cTxt, "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
					PutLogFileList(G_cTxt);
				}
				else {
					iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
					if (iCount < 0) iCount = 0;
					SetItemCount(iClientH, cElementItemID[x], iCount);
				}
			}

			//  ų īƮ Ѵ.   ִ  ų ѵ  ϴ.  
			if (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[13])
				CalculateSSN_SkillIndex(iClientH, 13, 1);

			// v1.41 ҷ ġ  
			GetExp(iClientH, iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4))); //m_pClientList[iClientH]->m_iExpStock += iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4));

			return;
		}
	}

}


void CGame::AdminOrder_SetAttackMode(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;
 int    i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;
	
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetAttackMode) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	

	if (token != 0) {
		if (token[0] == '1') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = true;
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete ) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(0, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, 0, 0, 0);	
		}
		else if (token[0] == '0') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = false;
			
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete ) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(0, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, 0, 0, 0);	
		}
	}

	delete pStrTok;
}


void CGame::AdminOrder_UnsummonAll(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelUnsummonAll) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != 0) {
		if ((m_pNpcList[i]->m_bIsSummoned ) && (m_pNpcList[i]->m_bIsKilled == false)) 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
	}
}


void CGame::AdminOrder_UnsummonDemon(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelUnsummonDemon) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != 0) {
		if ((m_pNpcList[i]->m_sType == 31) && (m_pNpcList[i]->m_bIsKilled == false)) 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
	}
}

// 3.51 - 05/17/2004 - Hypnotoad/[KLKS] - Monster Special Abilities
char CGame::_cGetSpecialAbility(int iKindSA)
{
	char cSA;

	switch (iKindSA) {
	case 1: 
		// Slime, Orc, Orge, WereWolf, YB-, Rabbit, Mountain-Giant, Stalker, Hellclaw, 
		// Wyvern, Fire-Wyvern, Barlog, Tentocle, Centaurus, Giant-Lizard, Minotaurus,
		// Abaddon, Claw-Turtle, Giant-Cray-Fish, Giant-Plant, MasterMage-Orc, Nizie,
		// Tigerworm
		switch (iDice(1,2)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
		}
		break;

	case 2: 
		// Giant-Ant, Cat, Giant-Frog, 
		switch (iDice(1,3)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 5; break; // Poisonous
		}
		break;

	case 3: 
		// Zombie, Scorpion, Amphis, Troll, Dark-Elf
		switch (iDice(1,4)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 5; break; // Poisonous
			case 4: cSA = 6; break; // Critical Poisonous
		}
		break;

	case 4: 
		// no linked Npc
		switch (iDice(1,3)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 7; break; // Explosive
		}
		break;

	case 5: 
		// Stone-Golem, Clay-Golem, Beholder, Cannibal-Plant, Rudolph, DireBoar
		switch (iDice(1,4)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 7; break; // Explosive
			case 4: cSA = 8; break; // Critical-Explosive
		}
		break;

	case 6: 
		// no linked Npc
		switch (iDice(1,3)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 5; break; // Poisonous
		}
		break;

	case 7: 
		// Orc-Mage, Unicorn
		switch (iDice(1,3)) {
			case 1: cSA = 1; break; // Clairvoyant
			case 2: cSA = 2; break; // Distruction of Magic Protection
			case 3: cSA = 4; break; // Anti-Magic Damage
		}
		break;

	case 8: 
		// Frost, Ice-Golem, Ettin, Gagoyle, Demon, Liche, Hellbound, Cyclops, 
		// Skeleton
		switch (iDice(1,5)) {
			case 1: cSA = 1; break; // Clairvoyant
			case 2: cSA = 2; break; // Distruction of Magic Protection
			case 3: cSA = 4; break; // Anti-Magic Damage
			case 4: cSA = 3; break; // Anti-Physical Damage
			case 5: cSA = 8; break; // Critical-Explosive
		}
		break;

	case 9:
		// no linked Npc
		cSA = iDice(1,8); // All abilities available
		break;
	}

	return cSA;
}

void CGame::AdminOrder_Summon(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA; 
 int    pX, pY, j, iNum, iNamingValue;
 class  CStrTok * pStrTok;
 bool   bMaster;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == false) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummon) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == 0) {
		delete pStrTok;
		return;
	}

	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, token);

	token = pStrTok->pGet();
	
	if (token != 0) 
		 iNum = atoi(token);
	else iNum = 1;

	if (iNum <= 0)  iNum = 1;
	if (iNum >= 50)  iNum = 50;
		
	cSA = 0;
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;

	// ¸Þ½ÃÁö Ãâ·Â 
	wsprintf(G_cTxt, "(!) Admin Order: Summon(%s)-(%d)", cNpcName, iNum);
	PutLogList(G_cTxt);

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {
		// Master MobÀ» »ý¼ºÇÑ´Ù.
		ZeroMemory(cName_Master, sizeof(cName_Master));
		wsprintf(cName_Master, "XX%d", iNamingValue);
		cName_Master[0] = '_';
		cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
		if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false, true)) == false) {
			// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
	}		

	for (j = 0; j < (iNum - 1); j++) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// Slave MobµéÀ» »ý¼ºÇÑ´Ù.
			ZeroMemory(cName_Slave, sizeof(cName_Slave));
			wsprintf(cName_Slave, "XX%d", iNamingValue);
			cName_Slave[0] = '_';
			cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
			// v1.411 ¸ó½ºÅÍÀÇ Æ¯¼ö Æ¯¼ºÄ¡¸¦ ÀÔ·ÂÇÑ´Ù. 
				
			if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false) == false) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				// Slave¸ðµå·Î ÀüÈ¯.
				bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
			}
		}
	}

	delete pStrTok;
}

void CGame::AdminOrder_SummonAll(int iClientH, char *pData, DWORD dwMsgSize)
{

 char   seps[] = "= \t\n";
 char   * token, * cp, cBuff[256], cLocation[11], cMapName[11];
 WORD   *wp;
 int    pX, pY, i;
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize) <= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == false) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonAll) {
		 // Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		 SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		 return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == 0) {
		 delete pStrTok;
		 return;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;


	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

	if (strlen(token) > 10)
	memcpy(cLocation, token, 10);
	else memcpy(cLocation, token, strlen(token));

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		 if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cLocation, token) == 0)) {
			  RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
		 }

	wsprintf(G_cTxt,"GM Order(%s): PC(%s) Summoned to (%s)", m_pClientList[iClientH]->m_cLocation,
	   cLocation, cMapName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, G_cTxt);

	/*ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONALL;
	cp++;

	memcpy(cp, cLocation, 10);
	cp += 10;

	memcpy(cp, cMapName, 10);
	cp += 10;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;

	bStockMsgToGateServer(cBuff, 25);*/

	delete pStrTok;
}

void CGame::AdminOrder_SummonPlayer(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, * cp, cBuff[256], cMapName[11], cName[11]; 
	WORD   *wp;
	int    pX, pY, i;
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonPlayer) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	ZeroMemory(cName, sizeof(cName));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == 0) {
		delete pStrTok;
		return;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;
	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

	if (strlen(token) > 10)
		memcpy(cName, token, 10);
	else memcpy(cName, token, strlen(token));

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			if (i == iClientH) {
				delete pStrTok;
				return;
			}
			RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
			delete pStrTok;
			return;
		}//m_pClientList[i]->m_cCharName

	// find char on other hg's
	wsprintf(G_cTxt,"GM Order(%s): PC(%s) Summoned to (%s)", m_pClientList[iClientH]->m_cCharName,
				cName, cMapName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, G_cTxt);

	/*ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONPLAYER;
	cp++;

	memcpy(cp, cName, 10);
	cp += 10;

	memcpy(cp, cMapName, 10);
	cp += 10;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;

	bStockMsgToGateServer(cBuff, 25);*/

	delete pStrTok;
}

void CGame::CheckSpecialEvent(int iClientH)
{
 class CItem * pItem;
 char  cItemName[21];
 int   iEraseReq;

	if (m_pClientList[iClientH] == 0) return;

	//v1.42 ÀÌº¥Æ® ¾ÆÀÌÅÛÀ» ÁØ´Ù. 2000.8.1ÀÏ 1ÁÖ³â ¹ÝÁö ¼ö¿© 
	if (m_pClientList[iClientH]->m_iSpecialEventID == 200081) {
		
		// Àú·¾Àº ÁÖÁö ¾Ê´Â´Ù.
		if (m_pClientList[iClientH]->m_iLevel < 11) {
			m_pClientList[iClientH]->m_iSpecialEventID = 0;
			return;
		}

		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, "MemorialRing"); 
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == false) {
			// ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ±¸ÀÔÀÌ ºÒ°¡´ÉÇÏ´Ù.
			delete pItem;
		}
		else {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				//testcode ·Î±×ÆÄÀÏ¿¡ ±â·ÏÇÑ´Ù.
				wsprintf(G_cTxt, "(*) Get MemorialRing  : Char(%s)", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);

				// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 9;

				// ¾ÆÀÌÅÛ ¹Þ¾ÒÀ¸¹Ç·Î Å¬¸®¾î.
				m_pClientList[iClientH]->m_iSpecialEventID = 0;
			}
		}
	}
}



void CGame::AdminOrder_DisconnectAll(int iClientH, char *pData, DWORD dwMsgSize)
{

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == false) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelDisconnectAll) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	_iForcePlayerDisconect(DEF_MAXCLIENTS);
}

bool CGame::_bDecodeDupItemIDFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iIndex = 0;
 class CStrTok * pStrTok;

 char cData[50000] = {};
 DWORD lpNumberOfBytesRead;
 HANDLE hFile = CreateFile(pData, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
 DWORD dwFileSize = GetFileSize(hFile, 0);
 if (dwFileSize == -1) {
	 wsprintf(G_cTxt, "(X) CRITICAL ERROR! Cannot open configuration file(%s)!", pData);
	 PutLogList(pData);
	 return false;
 }

 SetFilePointer(hFile, 0, 0, FILE_BEGIN);

 ReadFile(hFile, cData, dwFileSize, &lpNumberOfBytesRead, 0);
 CloseHandle(hFile);

 pContents = new char[dwFileSize + 1];
 ZeroMemory(pContents, dwFileSize + 1);
 memcpy(pContents, cData, dwFileSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != 0 ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ų ȣ 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					
					if (m_pDupItemIDList[atoi(token)] != 0) {
						// ̹ Ҵ ȣ ִ. ̴.
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Duplicate magic number.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pDupItemIDList[atoi(token)] = new class CItem;
					iIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 4;
					break;
				
				case 4:
					// m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete[] pContents;
						delete pStrTok;
						return false;
					}
					m_pDupItemIDList[iIndex]->m_wPrice = (WORD)atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

					//testcode
					//wsprintf(G_cTxt, "(%d) %d %d %d %d", iIndex, m_pDupItemIDList[iIndex]->m_sTouchEffectType, m_pDupItemIDList[iIndex]->m_sTouchEffectValue1, m_pDupItemIDList[iIndex]->m_sTouchEffectValue2, m_pDupItemIDList[iIndex]->m_sTouchEffectValue3); 
					//PutLogList(G_cTxt);
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "DupItemID", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) ERROR! DupItemID configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) DupItemID(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);
	
	return true;
}

bool CGame::_bCheckDupItemID(CItem *pItem)
{
 int i;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != 0) {
		if ((pItem->m_sTouchEffectType   == m_pDupItemIDList[i]->m_sTouchEffectType) &&
			(pItem->m_sTouchEffectValue1 == m_pDupItemIDList[i]->m_sTouchEffectValue1) &&
			(pItem->m_sTouchEffectValue2 == m_pDupItemIDList[i]->m_sTouchEffectValue2) &&
			(pItem->m_sTouchEffectValue3 == m_pDupItemIDList[i]->m_sTouchEffectValue3) ) {
			// °¡°Ý Á¤º¸¸¦ °»½ÅÇÏ°í ¸®ÅÏ.
			pItem->m_wPrice = m_pDupItemIDList[i]->m_wPrice;
			return true;
		}
	}
	
	return false;
}

void CGame::_AdjustRareItemValue(CItem *pItem)
{
 DWORD dwSWEType, dwSWEValue;
 double dV1, dV2, dV3;

	if ((pItem->m_dwAttribute & 0x00F00000) != 0) {
		dwSWEType  = (pItem->m_dwAttribute & 0x00F00000) >> 20;  
		dwSWEValue = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
		// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 
		// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ
		switch (dwSWEType) {
		case 0: break;
		
		case 5: // ¹ÎÃ¸ÀÇ 
			pItem->m_cSpeed--;
			if (pItem->m_cSpeed < 0) pItem->m_cSpeed = 0;
			break;

		case 6: // °¡º­¿î 
			dV2 = (double)pItem->m_wWeight;
			dV3 = (double)(dwSWEValue*4);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wWeight -= (int)dV1;

			if (pItem->m_wWeight < 1) pItem->m_wWeight = 1;
			break;

		case 8: // °­È­µÈ 
		case 9: // °í´ë¹®¸íÀÇ 
			dV2 = (double)pItem->m_wMaxLifeSpan;
			dV3 = (double)(dwSWEValue*7);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wMaxLifeSpan += (int)dV1;
			break;
		}
	}
}

void CGame::RequestNoticementHandler(int iClientH, char * pData)
{
 char * cp, cData[120];
 int  * ip, iRet, iClientSize;
 DWORD * dwp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == 0) return;
	if (m_dwNoticementDataSize < 10) return;

	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	iClientSize = *ip;

	if (iClientSize != m_dwNoticementDataSize) {
		// Å¬¶óÀÌ¾ðÆ®°¡ °®°í ÀÖ´Â ÆÄÀÏ »çÀÌÁî¿Í ´Ù¸£¸é ³»¿ëÀ» ¸ðµÎ º¸³½´Ù.
		cp = new char[m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2];
		ZeroMemory(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
		memcpy((cp + DEF_INDEX2_MSGTYPE + 2), m_pNoticementData, m_dwNoticementDataSize);
		
		dwp  = (DWORD *)(cp + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cp + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
	
		delete cp;
	}
	else {
		ZeroMemory(cData, sizeof(cData));
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	}
	// ¿¡·¯ ¹ß»ýÇØµµ ²÷Áö ¾Ê´Â´Ù.	
}

void CGame::RequestNoticementHandler(int iClientH)
{
	DWORD* dwp, lpNumberOfBytesRead;
	WORD* wp;

	if (m_pClientList[iClientH] == 0) return;

	HANDLE hFile = CreateFile("GameConfigs\\Noticement.txt", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	DWORD dwFileSize = GetFileSize(hFile, 0);
	if (dwFileSize == -1) {
		return;
	}

	ZeroMemory(G_cData50000, sizeof(G_cData50000));

	SetFilePointer(hFile, 0, 0, FILE_BEGIN);

	ReadFile(hFile, G_cData50000 + 6, dwFileSize, &lpNumberOfBytesRead, 0);
	CloseHandle(hFile);

	dwp = (DWORD*)(G_cData50000);
	*dwp = MSGID_RESPONSE_NOTICEMENT;

	wp = (WORD*)(G_cData50000 + DEF_INDEX2_MSGTYPE);
	*wp = DEF_MSGTYPE_CONFIRM;

	int iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(G_cData50000, dwFileSize + 8);

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		return;
	}
}

void CGame::_bDecodeNoticementFileContents(char *pData, DWORD dwMsgSize)
{
 char * cp;	
	
	cp = (pData);
	
	if (m_pNoticementData != 0) {
		delete m_pNoticementData;
		m_pNoticementData = 0;
	}

	m_pNoticementData = new char[strlen(cp) + 2];
	ZeroMemory(m_pNoticementData, strlen(cp) + 2);

	memcpy(m_pNoticementData, cp, strlen(cp));
	m_dwNoticementDataSize = strlen(cp);

	wsprintf(G_cTxt, "(!) Noticement Data Size: %d", m_dwNoticementDataSize);
	PutLogList(G_cTxt);
}

void CGame::RequestCheckAccountPasswordHandler(char *pData, DWORD dwMsgSize)
{
 int * ip, i, iLevel;
 char * cp, cAccountName[11], cAccountPassword[11];

	cp = (char *)(pData + 6);

	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	memcpy(cAccountName, cp, 10);
	cp += 10;

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ip = (int *)cp;
	iLevel = *ip;
	cp += 4;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cAccountName, cAccountName) == 0)) {
		// °°Àº °èÁ¤À» Ã£¾Ò´Ù. ¸¸¾à ÆÐ½º¿öµå³ª ·¹º§ÀÌ ´Ù¸£¸é µ¥ÀÌÅÍ ÀúÀåÀ» ÇÏÁö ¾Ê°í Á¢¼ÓÀ» ²÷´Â´Ù. 
		if ((strcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword) != 0) || (m_pClientList[i]->m_iLevel != iLevel)) {
			wsprintf(G_cTxt, "(TestLog) Error! Account(%s)-Level(%d) password(or level) mismatch! Disconnect.", cAccountName, iLevel);
			PutLogList(G_cTxt);
			// µ¥ÀÌÅÍ ÀúÀåÀ» ÇÏÁö ¾Ê°í ²÷´Â´Ù.
			DeleteClient(i, false, true);
			return;
		}
	}
}

void CGame::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{
 int iSkillLevel, iRange, iTamingLevel, iResult, iX, iY;
 short sOwnerH;
 char  cOwnerType;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pMapList[cMapIndex] == 0) return;
	
	iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
	iRange = iSkillLevel / 12; // ÃÖ´ë ¹üÀ§´Â 8

	for (iX = dX - iRange; iX <= dX + iRange; iX++)
	for (iY = dY - iRange; iY <= dY + iRange; iY++) {
		sOwnerH = 0;
		if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
			m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);

		if (sOwnerH != 0) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == 0) break;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == 0) break;
				// ¸ó½ºÅÍÀÇ Á¾·ù¿¡ µû¶ó ±æµé¿©Áú °ÍÀÎÁö¸¦ °áÁ¤ÇÑ´Ù.
				iTamingLevel = 10;
				switch (m_pNpcList[sOwnerH]->m_sType) {
				case 10:							// ½½¶óÀÓ  
				case 16: iTamingLevel = 1; break;	// °³¹Ì
				case 22: iTamingLevel = 2; break;	// ¹ì
				case 17:							// Àü°¥
				case 14: iTamingLevel = 3; break;	// ¿ÀÅ©
				case 18: iTamingLevel = 4; break;   // Á»ºñ
				case 11: iTamingLevel = 5; break;	// ½ºÄÌ·¹Åæ
				case 23:
				case 12: iTamingLevel = 6; break;	// °ñ·½
				case 28: iTamingLevel = 7; break;	// Æ®·Ñ
				case 13:							// ½ÎÀÌÅ¬·Ó½º
				case 27: iTamingLevel = 8; break;	// ÇïÇÏ¿îµå
				case 29: iTamingLevel = 9; break;	// ¿À¿ì°Å
				case 33: iTamingLevel = 9; break;	// ¿þ¾î¿ïÇÁ
				case 30: iTamingLevel = 9; break;  // ¸®Ä¡
				case 31:
				case 32: iTamingLevel = 10; break;  // µ¥¸ó, À¯´ÏÄÜ
				}
				
				iResult = (iSkillLevel/10);
				
				// ½ºÅ³ÀÇ µî±Þ¿¡ µû¶ó ±æµéÀÏ ¼ö ÀÖ´Â °¹¼ö°¡ ´Þ¶óÁø´Ù.
				if (iResult < iTamingLevel) break;

				break;
			}
		}
	}
}

void CGame::GetMagicAbilityHandler(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] != 0) return;

	// ¸¶¹ý ´É·Â ½ºÅ³À» 20À¸·Î º¯°æÈÄ ¾Ë·ÁÁÜ
	m_pClientList[iClientH]->m_cSkillMastery[4] = 20;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], 0, 0);
	// v1.4311 ½ºÅ³ÀÇ ÃÑ ÇÕÀ» Ã¼Å©
	bCheckTotalSkillMasteryPoints(iClientH, 4);
}

int CGame::iRequestPanningMapDataRequest(int iClientH, char * pData)
{
 char  * cp, cDir, cData[3000];
 DWORD * dwp;
 WORD  * wp;
 short * sp, dX, dY;
 int   iRet, iSize;

	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsObserverMode == false) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled ) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	cDir = *(pData + DEF_INDEX2_MSGTYPE +2);
	if ((cDir <= 0) || (cDir > 8)) return 0;
		
	switch (cDir) {
	case 1:	dY--; break; // responding when mouse is placed north
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break; // responding when mouse placed at west side of screen
	case 8:	dX--; dY--;	break; // responding when mouse is placed north west
/*
player is in the center, and is trying to pan,
directions not responding or causing a break will be kept as X, 
others are the cDir case... 
		8	1	X

		7	_	X

		X	X	X
*/
	}

	m_pClientList[iClientH]->m_sX   = dX;
	m_pClientList[iClientH]->m_sY   = dY;
	m_pClientList[iClientH]->m_cDir = cDir;
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_PANNING;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOVE_CONFIRM;
		
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
		
	sp  = (short *)cp;
	*sp = (short)(dX - 12); 
	cp += 2;
		
	sp  = (short *)cp;
	*sp = (short)(dY - 9); 
	cp += 2;

	*cp = cDir;
	cp++;
		
	iSize = iComposeMoveMapData((short)(dX - 12), (short)(dY - 9), iClientH, cDir, cp);
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

void CGame::AdminOrder_SetObserverMode(int iClientH)
{

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_bIsObserverMode ) {
		// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);		
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_OBSERVERMODE, 0, 0, 0, 0);
		m_pClientList[iClientH]->m_bIsObserverMode = false;
	}
	else {
		// ÇöÀç À§Ä¡¿¡¼­ Áö¿î´Ù. ¾ø¾îÁø ÇàÀ§¸¦ ¾Ë·ÁÁà¾ß ÇÑ´Ù. ¾ÆÁ÷ ¹Ì±¸Çö
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, 0, 0, 0);
		//iRequestPanningMapDataRequest(iClientH, pData)
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_OBSERVERMODE, 1, 0, 0, 0);
		m_pClientList[iClientH]->m_bIsObserverMode = true;
	}
}

void CGame::RequestRestartHandler(int iClientH)
{
 char  cTmpMap[32];

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_bIsKilled ) {
		
		strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		
		if (strcmp(m_pClientList[iClientH]->m_cLocation, "NONE") == 0) {
			// ڶ  default .
			strcpy(m_pClientList[iClientH]->m_cMapName, "default");
		}
		else {
			// Ҽ ִٸ Ҽ  Ȱ .
			if ((strcmp(m_pClientList[iClientH]->m_cLocation, "aresden") == 0) || (strcmp(m_pClientList[iClientH]->m_cLocation, "arehunter") == 0)) {
				if (m_bIsCrusadeMode ) {
					// ũ缼̵ 忡  :  ʿ ð   .
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04 10 ȿ    .
					}
				}
				// v2.16 2002-5-31
				if (strcmp(cTmpMap, "elvine") == 0){
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ; // 3 
				}else if (m_pClientList[iClientH]->m_iLevel > 80)
					 memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
			}
			else {
				if (m_bIsCrusadeMode ) {
					// ũ缼̵ 忡  :  ʿ ð   .
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04 10 ȿ    .
					}
				}
				if (strcmp(cTmpMap, "aresden") == 0){
					memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ; // 3 

				}else if (m_pClientList[iClientH]->m_iLevel > 80)
					 memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
			}
		}
		
		// v2.04 ٽ 츮 ó Ѵ. HP,   
		m_pClientList[iClientH]->m_bIsKilled = false;
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
		m_pClientList[iClientH]->m_iHungerStatus = 100;

		ZeroMemory(cTmpMap, sizeof(cTmpMap));
		strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);
		// !!! RequestTeleportHandler m_cMapName   ״ Ķͷ Ѱָ 
		RequestTeleportHandler(iClientH, "2   ", cTmpMap, -1, -1);
	}
}


void CGame::AdminOrder_EnableAdminCommand(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   * token, cBuff[256], len;
 char   seps[] = "= \t\n";
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != 0) {
		len = strlen(token);
		if(len > 10) len = 10;
		if (memcmp(token, m_cSecurityNumber, len) == 0) {
			m_pClientList[iClientH]->m_bIsAdminCommandEnabled = true;
		}
		else {
			try
			{
				wsprintf(G_cTxt, "(%s) Player(%s) attempts to access /enableadmincommand with %s", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, token);
				PutHackLogFileList(G_cTxt);
			}
			catch(...)
			{
			}
			return;
		}
	}
}

void CGame::AdminOrder_CreateItem(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * cp, * token, cBuff[256], cItemName[256], cData[256], cTemp[256], cAttribute[256], cValue[256];
 SYSTEMTIME SysTime;
 class  CStrTok * pStrTok;
 class  CItem * pItem;
 short  * sp;
 int    iRet, iTemp, iEraseReq, iValue;
 DWORD * dwp;
 WORD  * wp, wTemp;
 double dV1, dV2, dV3;
 
	// if the client doesnt exist than no effect.
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == false) return;

	// if the command is just "/createitem " than no effect.
	if ((dwMsgSize)	<= 0) return;

	// if client's admin level is less than 4 no effect.
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCreateItem) {
		// if the admin user level is not 0 and less than 4 send message 
		if (m_pClientList[iClientH]->m_iAdminUserLevel !=  0)	
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	} // close if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {

	// IP address not able to create item 
	// DISABLED: if (memcmp(m_pClientList[iClientH]->m_cIPaddress, "192.168.1.", 12) != 0) return;

	// check if the client has typed "/enableadmincreateitem"
	//if (m_pClientList[iClientH]->m_bIsAdminCreateItemEnabled == false) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	// if the token is something it is an item name
	if (token != 0) {
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, token);
	} // close if (token != 0) {

	// if the 2nd token is true it is the item attribute
	ZeroMemory(cAttribute, sizeof(cAttribute));
	token = pStrTok->pGet();
	if (token != 0) {
		ZeroMemory(cAttribute, sizeof(cAttribute));
		strcpy(cAttribute, token);
	} // close if (token != 0) {

	// if the 3rd token is true it is the item value
	ZeroMemory(cValue, sizeof(cValue));
	iValue = 0;
	token = pStrTok->pGet();
	if (token != 0) {
		ZeroMemory(cValue, sizeof(cValue));
		strcpy(cValue, token);
		iValue = atoi(cValue);
	} // close if (token != 0) {

	pItem = new class CItem;
	// if the given itemname doesnt exist delete item
	if (_bInitItemAttr(pItem, cItemName) == false) {
		delete pItem;
		return;	
	} //close if (_bInitItemAttr(pItem, cItemName) == false) {

	if (strlen(cAttribute) != 0) {
		pItem->m_dwAttribute = atoi(cAttribute);
		if (pItem->m_dwAttribute == 1) {
			if ((iValue >= 1) && (iValue <= 200)) {
				pItem->m_cItemColor = 2;
				pItem->m_sItemSpecEffectValue2 = iValue - 100;
								
				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				} // close if (wTemp <= pItem->m_wMaxLifeSpan*2) {
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
			} // close if ((iValue >= 1) && (iValue <= 200)) {
			else pItem->m_dwAttribute = 0;
		} // close if (pItem->m_dwAttribute == 1) {
		else {
			if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
				switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 6:	pItem->m_cItemColor = 2; break;
				case 8: pItem->m_cItemColor = 3; break;
				case 1:	pItem->m_cItemColor = 5; break;
				case 5:	pItem->m_cItemColor = 1; break;
				case 3:	pItem->m_cItemColor = 7; break;
				case 2:	pItem->m_cItemColor = 4; break;
				case 7:	pItem->m_cItemColor = 6; break;
				case 9:	pItem->m_cItemColor = 8; break;
				} // close switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
			} // close if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
			else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
				switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 10: pItem->m_cItemColor = 5; break;
				} // close switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
			} // close else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
		} // close else {
	} // close if (strlen(cAttribute) != 0) {

	// if the item id is
	switch (pItem->m_sIDnum) {
	case 511: // ArenaTicket
	case 513: // ArenaTicket(2)
	case 515: // ArenaTicket(3)
	case 517: // ArenaTicket(4)
	case 530: // ArenaTicket(5)
	case 531: // ArenaTicket(6)
	case 532: // ArenaTicket(7)
	case 533: // ArenaTicket(8)
	case 534: // ArenaTicket(9)
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		// v1.4311-3  ڰ ߱  ׳ ׻   ..
		pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
		pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
		pItem->m_sTouchEffectValue3 = 24 ;
		break;

	default:
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		//  ڴ   , 	
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);
		break;
	}
	
	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {
		//  ȹߴ.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1 ȹߴ. Amount ƴϴ!
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	//  Է 
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; //  ̹Ƿ  ʾҴ.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// v2.15 α  
		if (iEraseReq == 1) {
			delete pItem;
			pItem = 0 ;
		}
		
		//    
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		

		// v2.14 Admin Log
		wsprintf(G_cTxt, "(%s) GM Order(%s): Create ItemName(%s)",m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cItemName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, 0,G_cTxt);

		return;
	}
	else {
		//     Ȳ̴.		
		delete pItem;
		return;
	}
}

void CGame::RequestSellItemListHandler(int iClientH, char * pData)
{
 int i, * ip, iAmount;
 char * cp, cIndex;
 struct {
	char cIndex;
	int  iAmount;
 } stTemp[12];

	if (m_pClientList[iClientH] == 0) return;

	cp = (char *)(pData + 6);
	for (i = 0; i < 12; i++) {
		stTemp[i].cIndex = *cp;
		cp++;

		ip = (int *)cp;
		stTemp[i].iAmount = *ip;
		cp += 4;
	}

	// ³»¿ëÀ» ´Ù ÀÐ¾ú´Ù. ¼ø¼­´ë·Î ÆÈ¾ÆÄ¡¿î´Ù.
	for (i = 0; i < 12; i++) {
		cIndex = stTemp[i].cIndex;
		iAmount = stTemp[i].iAmount;

		if ((cIndex == -1) || (cIndex < 0) || (cIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cIndex] == 0) return;

		// cIndex¿¡ ÇØ´çÇÏ´Â ¾ÆÀÌÅÛÀ» ÆÇ´Ù.
		ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, 0);
		// ÀÌ ·çÆ¾À» ¼öÇàÇÑ ´ÙÀ½ Å¬¶óÀÌ¾ðÆ®°¡ »èÁ¦µÇ¾úÀ» ¼ö ÀÖÀ¸´Ï ÁÖÀÇ!
		if (m_pClientList[iClientH] == 0) return;
	}
}

void CGame::_DeleteRandomOccupyFlag(int iMapIndex)
{
 int i, iCount, iTotalFlags, iTargetFlag, iDynamicObjectIndex;
 int tx, ty, fx, fy, iLocalSide, iLocalEKNum, iPrevStatus;
 class CTile * pTile;
 DWORD dwTime;

	if (m_pMapList[iMapIndex] == 0) return;

	dwTime = timeGetTime();

	// ÃÑ ±ê¹ß °¹¼ö¸¦ ±¸ÇÑ´Ù.
	iTotalFlags = 0;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != 0) {
		iTotalFlags++;
	}

	// ·£´ýÇÏ°Ô ÇÏ³ª Á¤ÇÑ´Ù.
	iTargetFlag = iDice(1, iTotalFlags);

	iCount = 0;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != 0) {
		iCount++;
		if ((iCount == iTotalFlags) && (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != 0)) {
			// m_pMapList[iMapIndex]->m_pOccupyFlag[i] : ÀÌ ±ê¹ßÀ» ¾ø¾Ø´Ù.	

			//testcode
			wsprintf(G_cTxt, "(*)Delete OccupyFlag: Side(%d) XY(%d, %d)", m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_cSide, m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX, m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY);
			PutLogList(G_cTxt);

			fx = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
			fy = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
			iLocalSide  = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_cSide;
			iLocalEKNum = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iEKCount;
			
			pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX + 
				                    m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY*m_pMapList[iMapIndex]->m_sSizeY);
			// ±ê¹ß °´Ã¼ °¨¼Ò 
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;
						
			iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
			// Å¬¶óÀÌ¾ðÆ®¿¡°Ô ±ê¹ßÀÌ »ç¶óÁüÀ» ¾Ë¸®°í 
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
										m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
										m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, 0, (short)0);
			// ¸Ê¿¡¼­ ±ê¹ß µ¿Àû °´Ã¼¸¦ »èÁ¦ÇÑ´Ù.
			m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);
						
			// ±ê¹ß °´Ã¼¸¦ »èÁ¦ 
			delete m_pMapList[iMapIndex]->m_pOccupyFlag[i];
			m_pMapList[iMapIndex]->m_pOccupyFlag[i] = 0;

			// Å¸ÀÏ »óÀÇ ±ê¹ß ÀÎµ¦½º¸¦ »èÁ¦
			pTile->m_iOccupyFlagIndex = 0;

			// µ¿Àû °´Ã¼ »èÁ¦ 
			delete m_pDynamicObjectList[iDynamicObjectIndex];
			m_pDynamicObjectList[iDynamicObjectIndex] = 0;

			// ÀÌ ±ê¹ßÀ» »èÁ¦ÇÏ¹Ç·Î ¿µÇâ±Ç ³»ÀÇ °ªÀ» º¯°æ½ÃÄÑ¾ß ÇÑ´Ù. *** ¸Ç ¸¶Áö¸·¿¡ Ã³¸®ÇØ¾ß ÇÑ´Ù.
			for (tx = fx - 12; tx <= fx + 12; tx++)
			for (ty = fy - 10; ty <= fy + 10; ty++) {	
				if ((tx < 0) || (tx >= m_pMapList[iMapIndex]->m_sSizeX) || 
					(ty < 0) || (ty >= m_pMapList[iMapIndex]->m_sSizeY)) {
					// ¹«½ÃÇØ¾ß ÇÏ´Â ÁÂÇ¥ 
				}
				else {
					pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + tx + ty*m_pMapList[iMapIndex]->m_sSizeY);
					iPrevStatus = pTile->m_iOccupyStatus;
					// Side: ¾Æ·¹½ºµ§(1)  ¿¤¹ÙÀÎ(2)
					switch (iLocalSide) {
					case 1: 
						pTile->m_iOccupyStatus += iLocalEKNum;
						if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
						break;
					case 2:
						pTile->m_iOccupyStatus -= iLocalEKNum;
						if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
						break;
					}
				}
			}
			//
			return;
		}
	}
}


void CGame::CreateNewPartyHandler(int iClientH)
{
 bool bFlag;

	if (m_pClientList[iClientH] == 0) return;

	bFlag = m_pClientList[iClientH]->bCreateNewParty();
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_RESPONSE_CREATENEWPARTY, (int)bFlag, 0, 0, 0);
}

void CGame::JoinPartyHandler(int iClientH, int iV1, char *pMemberName)
{
	char * cp, cData[120];
	short sAppr2;
	DWORD * dwp;
	WORD * wp;
	int i;

	if (m_pClientList[iClientH] == 0) return;
	if ((m_bAdminSecurity ) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;

	switch (iV1) {
	case 0: // ÆÄÆ¼ Å»Åð ½ÅÃ»
		RequestDeletePartyHandler(iClientH);
		break;

	case 1: // ÆÄÆ¼ °¡ÀÔ ½ÅÃ»
		//testcode
		wsprintf(G_cTxt, "Join Party Req: %s(%d) ID(%d) Stat(%d) ReqJoinH(%d) ReqJoinName(%s)", m_pClientList[iClientH]->m_cCharName, iClientH, 
			m_pClientList[iClientH]->m_iPartyID, m_pClientList[iClientH]->m_iPartyStatus, m_pClientList[iClientH]->m_iReqJoinPartyClientH,
			m_pClientList[iClientH]->m_cReqJoinPartyName);
		PutLogList(G_cTxt);

		if ((m_pClientList[iClientH]->m_iPartyID != 0) || (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL)) {
			// ÀÌ¹Ì ÆÄÆ¼¿¡ °¡ÀÔÇØ ÀÖ´Ù¸é ÆÄÆ¼ °¡ÀÔ ½ÅÃ»À» ÇÒ ¼ö ¾ø´Ù.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			//testcode
			PutLogList("Join Party Reject (1)");
			return;
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)) {
				// °°Àº ÀÌ¸§À» °¡Áø ÇÃ·¹ÀÌ¾î¸¦ Ã£¾Ò´Ù.
				sAppr2 = (short)((m_pClientList[i]->m_sAppr2 & 0xF000) >> 12);
				if (sAppr2 != 0) {
					// ÀüÅõ ¸ðµå »óÅÂÀÇ »ó´ë¿¡°Ô´Â ÆÄÆ¼ °¡ÀÔ ½ÅÃ»À» ÇÒ ¼ö ¾ø´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
					//testcode
					PutLogList("Join Party Reject (2)");
				}
				else if (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) {
					// ÆíÀÌ ´Ù¸£¸é ÆÄÆ¼¿¡ µé ¼ö ¾ø´Ù.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
					//testcode
					PutLogList("Join Party Reject (3)");
				}
				else if (m_pClientList[i]->m_iPartyStatus == DEF_PARTYSTATUS_PROCESSING) {
					// ÆÄÆ¼ °¡ÀÔÀ» ½ÅÃ»ÇÑ ´ë»óÀÌ ÀÌ¹Ì ´Ù¸¥ ÆÄÆ¼ °¡ÀÔ °ü·Ã Ã³¸®¸¦ ÇÏ°í ÀÖ´Ù. ½ÅÃ» ºÒ°¡.
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
					//testcode
					PutLogList("Join Party Reject (4)");
					//testcode
					wsprintf(G_cTxt, "Party join reject(2) ClientH:%d ID:%d JoinName:%d", i, m_pClientList[i]->m_iPartyID, m_pClientList[i]->m_cReqJoinPartyName);
					PutLogList(G_cTxt);

					m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
					ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				}
				else {
					// °¡ÀÔ ½ÂÀÎ ¿©ºÎ¸¦ ¹¯´Â´Ù.
					m_pClientList[i]->m_iReqJoinPartyClientH = iClientH;
					ZeroMemory(m_pClientList[i]->m_cReqJoinPartyName, sizeof(m_pClientList[i]->m_cReqJoinPartyName));
					strcpy(m_pClientList[i]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName);
					SendNotifyMsg(0, i, DEF_NOTIFY_QUERY_JOINPARTY, 0, 0, 0, m_pClientList[iClientH]->m_cCharName);

					// ½ÅÃ»ÇÑ Ãø¿¡´Â ÆÄÆ¼ ¸¶½ºÅÍ°¡ µÉ Ä³¸¯ÅÍÀÇ ÀÎµ¦½º¸¦ ³Ö¾îÁÜ. Ãë¼ÒÇÒ¶§ Ã³¸®ÇÏ±â À§ÇÔÀÓ.
					m_pClientList[iClientH]->m_iReqJoinPartyClientH = i;
					ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					strcpy(m_pClientList[iClientH]->m_cReqJoinPartyName, m_pClientList[i]->m_cCharName);
					// ÆÄÆ¼ »óÅÂ ¼¼Æ®
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
				}
				return;
			}
			break;

	case 2: // ÆÄÆ¼ ¸â¹ö È®ÀÎ ¸í·É 
		if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) {
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 6; // ÆÄÆ¼ ¸â¹ö ¸®½ºÆ® ¿äÃ»
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		break;
	}
}



bool CGame::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{
 int i, sX,sY, dX, dY, iGoalMapIndex;
 char cResult;

	if (m_pNpcList[iNpcH] == 0) return false;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex == -1) return false;

	if (m_pNpcList[iNpcH]->m_cMapIndex != m_iMiddlelandMapIndex) {
		// »çÅõÀåÀÇ ¿¡³ÊÁö ½ºÇÇ¾î
		iGoalMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;
		
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) {
			// ¾Æ·¹½ºµ§ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
					// Å¬¶óÀÌ¾ðÆ®¿ÍÀÇ ¸Þ½ÃÁö Âø¿À·Î 
					SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return true;
		}

		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) {
			// ¿¤¹ÙÀÎ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Elvine Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
					//
					SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
		}
		return false;
	}
	else {
		// ¹Ìµé·£µå ¿¡³ÊÁö ½ºÇÇ¾î.

		// ¿¡³ÊÁö ½ºÇÇ¾îÀÇ ÇöÀç À§Ä¡°¡ °ñ°ú °ÅÀÇ À¯»çÇÏ¸é 
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-4) && (sX <= dX+4) && (sY >= dY-4) && (sY <= dY+4)) {
			// ¾Æ·¹½ºµ§ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
					// Å¬¶óÀÌ¾ðÆ®¿ÍÀÇ ¸Þ½ÃÁö Âø¿À·Î 
					SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return true;
		}

		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-4) && (sX <= dX+4) && (sY >= dY-4) && (sY <= dY+4)) {
			// ¿¤¹ÙÀÎ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
					//
					SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return true;
		}
		return false;
	}
}

void CGame::EnergySphereProcessor(bool bIsAdminCreate, int iClientH)
{
 int i, iNamingValue, iCIndex, iTemp, pX, pY;
 char cSA, cName_Internal[31], cWaypoint[31];

	if (bIsAdminCreate != true) {
		
		if (m_iMiddlelandMapIndex < 0) return;
		if (m_pMapList[m_iMiddlelandMapIndex] == 0) return;
		// ¿¡³ÊÁö ½ºÇÇ¾î°¡ ¸¸µé¾îÁú È®·üÀº 3ÃÊ¸¶´Ù 2000ºÐÀÇ 1
		if (iDice(1,2000) != 123) return; 
		// ¿¡³ÊÁö ½ºÇÇ¾î´Â ÃÑ »ç¿ëÀÚ 500¸í ÀÌ»óÀÏ¶§¸¸ ¸¸µé¾î Áø´Ù.
		if (m_iTotalGameServerClients < 500) return;
	
		// ¸¸¾à ÀÌ¹Ì ¿¡³ÊÁö ½ºÇÇ¾îÀÇ °ñÀÌ ÇÒ´çµÇ¾î ÀÖÀ¸¸é ¸¸µé¸é ¾ÈµÈ´Ù.
		if (m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// ¿¡³ÊÁö ½ºÇÇ¾î¸¦ ¸¸µé À§Ä¡¸¦ °áÁ¤ 
		iCIndex = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereCreationPoint);

		// ¿¡³ÊÁö ½ºÇÇ¾î ½ÃÀÛ À§Ä¡°¡ ÃÊ±âÈ­°¡ ¾ÈµÈ »óÅÂ¶ó¸é 
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == 0) return;
		
		// ¿©±â¼­ ¿¡³ÊÁö ½ºÇÇ¾î »ý¼º 
		cSA = 0;
 		pX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[m_iMiddlelandMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_iMiddlelandMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_iMiddlelandMapIndex]->m_cName, (rand() % 5), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false)) == false) {
				m_pMapList[m_iMiddlelandMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		// ¿¡³ÊÁö ½ºÇÇ¾î °ñ »ý¼º 
		iTemp  = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == 0) return;
	
		// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
		m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// ¿¡³ÊÁö ½ºÇÇ¾î°¡ ¸¸µé¾î Á³À½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
			SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, 0, 0);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
	else {
		// ¸¸¾à ÀÌ¹Ì ¿¡³ÊÁö ½ºÇÇ¾îÀÇ °ñÀÌ ÇÒ´çµÇ¾î ÀÖÀ¸¸é ¸¸µé¸é ¾ÈµÈ´Ù.
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// ¿¡³ÊÁö ½ºÇÇ¾î¸¦ ¸¸µé À§Ä¡¸¦ °áÁ¤ 
		iCIndex = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereCreationPoint);

		// ¿¡³ÊÁö ½ºÇÇ¾î ½ÃÀÛ À§Ä¡°¡ ÃÊ±âÈ­°¡ ¾ÈµÈ »óÅÂ¶ó¸é 
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == 0) return;
		
		// ¿©±â¼­ ¿¡³ÊÁö ½ºÇÇ¾î »ý¼º 
		cSA = 0;
 		pX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 5), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false)) == false) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		// ¿¡³ÊÁö ½ºÇÇ¾î °ñ »ý¼º 
		iTemp  = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == 0) return;
	
		// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// ¿¡³ÊÁö ½ºÇÇ¾î°¡ ¸¸µé¾î Á³À½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
			SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, 0, 0);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Admin Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
}


void CGame::ActivateSpecialAbilityHandler(int iClientH)
{
 DWORD dwTime = timeGetTime();
 short sTemp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled ) return;

	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled  = true;
	m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;

	m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;

	sTemp = m_pClientList[iClientH]->m_sAppr4;
	sTemp = sTemp & 0xFF0F;
	switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		sTemp = sTemp | 0x0010;
		break;
	case 50:
	case 51:
	case 52:
	case 53:
	case 54:
		sTemp = sTemp | 0x0020;
		break;
	}
	m_pClientList[iClientH]->m_sAppr4 = sTemp;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, 0);
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}

void CGame::CancelQuestHandler(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	// Äù½ºÆ® »óÅÂ¸¦ Å¬¸®¾îÇÑ´Ù.
	_ClearQuestStatus(iClientH);
	// Äù½ºÆ®°¡ Ãë¼ÒµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù.
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTABORTED, 0, 0, 0, 0);
}

int CGame::iGetItemWeight(CItem *pItem, int iCount)
{
 int iWeight;

	// ¾ÆÀÌÅÛÀÇ ¼ö·®¿¡ µû¸¥ ¹«°Ô¸¦ °è»êÇÑ´Ù. GoldÀÎ °æ¿ì ¹«°Ô¸¦ 20ºÐÀÇ 1·Î º¯°æ 
	iWeight = (pItem->m_wWeight);
	if (iCount < 0) iCount = 1;
	iWeight = iWeight * iCount;
	if (pItem->m_sIDnum == 90) iWeight = iWeight / 20;
	if (iWeight <= 0) iWeight = 1;

	return iWeight;
}

void CGame::UpdateMapSectorInfo()
{
 int i, ix, iy;
 int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity;
	
	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != 0) {
	
		iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = 0;	
		m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
		m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
		m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;

		// ±×µ¿¾È ÀúÀåÇß´ø TempSectorInfo¿¡¼­ Á¤º¸¸¦ ¾ò¾î SectorInfo¿¡ ÀúÀåÇÑ ´ÙÀ½ TempSectorInfo´Â Áö¿î´Ù.
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) {
				iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
				m_pMapList[i]->m_iMaxNx = ix;
				m_pMapList[i]->m_iMaxNy = iy;
			}
			
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) {
				iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
				m_pMapList[i]->m_iMaxAx = ix;
				m_pMapList[i]->m_iMaxAy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) {
				iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
				m_pMapList[i]->m_iMaxEx = ix;
				m_pMapList[i]->m_iMaxEy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) {
				iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
				m_pMapList[i]->m_iMaxMx = ix;
				m_pMapList[i]->m_iMaxMy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) {
				iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
				m_pMapList[i]->m_iMaxPx = ix;
				m_pMapList[i]->m_iMaxPy = iy;
			}
		}
	
		// TempSectorInfo ³¯¸°´Ù.
		m_pMapList[i]->ClearTempSectorInfo();

		// Sector Info¿¡ ÀúÀå
		if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
		if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
		if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
		if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
		if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
	}
}


void CGame::AgingMapSectorInfo()
{
 int i, ix, iy;

	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != 0) {
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;
			
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity   = 0;
		}
	}
}


bool CGame::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{
 int iNamingValue, ix, iy, tX, tY;
 char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
 short sOwnerH;

	// Å©·ç¼¼ÀÌµå ¸ðµå°¡ ¾Æ´Ï°Å³ª °Ç¼³ÇÑ »ç¶÷ÀÌ °øº´ÀÌ ¾Æ´Ï¸é ¹«½Ã.
	if ((m_bIsCrusadeMode == false) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return false;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= DEF_MAXCRUSADESTRUCTURES) {
		// ÇØ´ç ¸Ê¿¡ Å©·ç¼¼ÀÌµå °Ç¹° °³¼ö Á¦ÇÑ¿¡ °É¸®Áö ¾Ê´Â´Ù¸é
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOMORECRUSADESTRUCTURE, 0, 0, 0, 0);
		return false;
	}

	// ÇØ´ç À§Ä¡¿¡ °ÇÃà¹° NPC¸¦ »ý¼º.
	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
	}
	else {

		// ¸ÕÀú ¼³Ä¡ÇÏ°íÀÚ ÇÏ´Â ±ÙÃ³¿¡ ±¸Á¶¹°ÀÌ ¾ø³ª È®ÀÎÇÑ´Ù.
		for (ix = dX -3; ix <= dX +5; ix++)
		for (iy = dY -3; iy <= dX +5; iy++) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) return false;
		}

		// NPC¸¦ »ý¼ºÇÑ´Ù.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		if (m_pClientList[iClientH]->m_cSide == 1) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Aresden"); break;
			case 2: strcpy(cNpcName, "CGT-Aresen"); break;
			case 3: strcpy(cNpcName, "MS-Aresden"); break;
			case 4: strcpy(cNpcName, "DT-Aresden"); break;
			}
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Elvine"); break;
			case 2: strcpy(cNpcName, "CGT-Elvine"); break;
			case 3: strcpy(cNpcName, "MS-Elvine"); break;
			case 4: strcpy(cNpcName, "DT-Elvine"); break;
			}
		}
		else return false;
	
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)dX;
		tY = (int)dY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, 0, 0, -1, false, false) == false) {
			// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// ¼º°ø
			wsprintf(G_cTxt, "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
			PutLogList(G_cTxt);
			return true;
		}
	}

	return false;
}

void CGame::LocalStartCrusadeMode(DWORD dwCrusadeGUID)
{
 int i;

	if (m_bIsCrusadeMode ) return;
	m_bIsCrusadeMode = true;
	m_iCrusadeWinnerSide = 0;

	if (dwCrusadeGUID != 0) {
		// Å©·ç¼¼ÀÌµå GUID ÆÄÀÏÀ» ¸¸µç´Ù.
		_CreateCrusadeGUID(dwCrusadeGUID, 0);
		m_dwCrusadeGUID = dwCrusadeGUID;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
		// ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¸éÀü ¸ðµå°¡ ½ÃÀÛµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù. ¸ÃÀº ÀÓ¹« Å¬¸®¾î ÈÄ Åëº¸ÇÔ.
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		m_pClientList[i]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		SendNotifyMsg(0, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[i]->m_iCrusadeDuty, 0, 0);
	}

	// ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ® HP ÃÊ±âÈ­.
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != 0) m_pMapList[i]->RestoreStrikePoints();

	// °¢°¢ÀÇ ¸Ê¿¡ ÃÊ±â °Ç¹° ¼³Ä¡. (¸¶³ª ½ºÅæ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ, ±×·¹ÀÌÆ® ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, °¡µåÅ¸¿öµîµî)
	CreateCrusadeStructures();
	
	PutLogList("(!)Crusade Mode ON.");
	_bCrusadeLog(DEF_CRUSADELOG_STARTCRUSADE, 0, 0, 0);
}

void CGame::LocalEndCrusadeMode(int iWinnerSide)
{
 int i;

	//testcode
	wsprintf(G_cTxt, "LocalEndCrusadeMode(%d)", iWinnerSide);
	PutLogList(G_cTxt);

	if (m_bIsCrusadeMode == false) return;
	m_bIsCrusadeMode = false;

	PutLogList("(!)Crusade Mode OFF.");

	// ¼³Ä¡µÇ¾ú´ø Å©·ç¼¼ÀÌµå °ÇÃà¹° Á¦°Å.
	RemoveCrusadeStructures();

	RemoveCrusadeNpcs();

	// ÀÌ±äÂÊ »çÀÌµå¸¦ ÀÔ·Â.
	_CreateCrusadeGUID(m_dwCrusadeGUID, iWinnerSide);
	m_iCrusadeWinnerSide = iWinnerSide;
	m_iLastCrusadeWinner = iWinnerSide;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
		// ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¸éÀü ¸ðµå°¡ ³¡³µÀ½À» ¾Ë·ÁÁØ´Ù. ¸ÃÀº ÀÓ¹« Å¬¸®¾î ÈÄ Åëº¸ÇÔ.
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		SendNotifyMsg(0, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, m_iCrusadeWinnerSide);
	}
	RemoveCrusadeRecallTime();

	if (iWinnerSide == 2) {
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, false, false, "Elvine Win!");
	}
	else if (iWinnerSide == 1) {
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, false, false, "Aresden Win!");
	}
	else{
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, false, false, "Drawn!");
	}

	if (m_iMiddlelandMapIndex != -1) {
		//bSendMsgToLS(0x3D00123C, 0, true, 0);
	}
}


void CGame::SaveOccupyFlagData()
{
 char * pData;
 int iSize;
 FILE * pFile;

	PutLogList("(!) Middleland OccupyFlag data saved.");
		
	pData = new char[1000000+1];
	if (pData == 0) return;
	ZeroMemory(pData, 1000000);
			
	iSize = _iComposeFlagStatusContents(pData);
	
	_mkdir("GameData");

	pFile = fopen("GameData\\OccupyFlag.txt", "wt");
	if (pFile == 0) return;

	fwrite(pData, 1, iSize, pFile);

	delete pData;
	fclose(pFile);
}


void CGame::CreateCrusadeStructures()
{
 int i, z, tX, tY, iNamingValue;
 char cName[6], cNpcName[21], cNpcWayPoint[11];

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
	if (m_stCrusadeStructures[i].cType != 0) {
		for (z = 0; z < DEF_MAXMAPS; z++)
		if ((m_pMapList[z] != 0) && (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) == 0)) {
			// À§Ä¡°¡ ÀÏÄ¡ÇÏ´Â ¸Ê¿¡ °ÇÃà¹°À» À§Ä¡½ÃÅ²´Ù.
			iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
				// ÀÌ·± ÀÏÀÌ?
			}
			else {
				// NPC¸¦ »ý¼ºÇÑ´Ù.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = z+65;
				
				switch (m_stCrusadeStructures[i].cType) {
				case 36:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "AGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "AGT-Elvine");
					break;

				case 37: 
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "CGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "CGT-Elvine");
					break;

				case 40:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "ESG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "ESG-Elvine");
					break;

				case 41:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "GMG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "GMG-Elvine");
					break;

				case 42:
					strcpy(cNpcName, "ManaStone");
					break;

				default: 
					strcpy(cNpcName, m_pNpcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName); 
					break;
				}

				tX = (int)m_stCrusadeStructures[i].dX;
				tY = (int)m_stCrusadeStructures[i].dY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWayPoint, 0, 0, -1, false) == false) {
					// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
					m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					wsprintf(G_cTxt, "(!) Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
					PutLogList(G_cTxt);
				}
			}
		}
	}
}

void CGame::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange ) return;

	// °ÔÀÌÆ® ¼­¹ö ¸Þ½ÃÁö ÀÛ¼º 
	/*ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDCONSTRUCTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;*/
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// ¸ÕÀú °°Àº GUID¸¦ °¡Áø ±æµå ÄÁ½ºÆ®·°Æ® ÁÂÇ¥°¡ ¼³Á¤µÇ¾î ÀÖ´ÂÁö Ã£´Â´Ù. 
	// ÅÚ·¹Æ÷Æ® À§Ä¡ÀÇ 2¹ø º¯¼öµéÀ» »ç¿ëÇÑ´Ù.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// ÀÌ¹Ì ±æµå°¡ ÀÖ´Ù.
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			// ³»¿ëÀÌ ÀÏÄ¡ÇÑ´Ù. Å¸ÀÓ ÀÔ·ÂÈÄ ½ºÅµ.
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// ³»¿ë °»½ÅÈÄ 
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				
			//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û
			//bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	// ¼³Á¤µÈ ³»¿ëÀÌ ¾ø´Ù. »õ·Î ¼³Á¤ÇÑ´Ù.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == 0) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

			//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û  
			//bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			// °¡Àå ¿À·§µ¿¾È ÂüÁ¶µÇÁö ¾ÊÀº ¸®½ºÆ®ÀÇ ÀÎµ¦½º¸¦ Ã£´Â´Ù.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// Ä³½Ã °ø°£ÀÌ ´Ù Ã¡´Ù. ÀÌ·± °æ¿ì ¸®½ºÆ® Áß °¡Àå ¿À·§µ¿¾È »ç¿ëÇÏÁö ¾ÊÀº ¸®½ºÆ®(iIndex)¸¦ »èÁ¦ÇÏ°í ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstructLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

	//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û
	//bStockMsgToGateServer(cData, 23);
}

// New 14/05/2004 Changed
void CGame::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{
 char cName[6], cNpcName[21], cMapName[11], cNpcWayPoint[11], cOwnerType;
 int i, x;
 int iNamingValue, tX, tY, ix, iy;
 bool bRet;
 short sOwnerH;
 DWORD dwTime = timeGetTime();
 
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	//hbest - crusade units summon mapcheck
	if (((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "toh3") == 0) || (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "icebound") == 0)) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
		return ;
	}
	
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cMapName, sizeof(cMapName));
		
	// ¿¡·¯ Ã¼Å©¿ë 
	if (cType < 0) return;
	if (cType >= DEF_MAXNPCTYPES) return;
	if (cNum  >  10) return;

	// °Ç¼³ÇÏ±â¿¡ Æ÷ÀÎÆ®°¡ ¸ðÀÚ¶õ´Ù.
	if (m_pClientList[iClientH]->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
	// °Ç¹° ³»ºÎ¸é ÀüÀï À¯´ÏÆ® ¼ÒÈ¯ ºÒ°¡.
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode )) return; 

	// ÀÏ´Ü ¿¡·¯¹æÁö¿ë
	cNum = 1;

	// ConstructionPoint Á¦ÇÑÀ» °è»êÇÏ°í À¯´ÏÆ® °³¼ö¸¸Å­ ÁÙÀÎ´Ù.
	for (x = 1; x <= cNum; x++) {
		// °³¼ö¸¸Å­  ÀüÀï À¯´ÏÆ® »ý¼º 
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {
			// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
			// ÀÌ·± ÀÏÀÌ?
		}
		else {
			// NPC¸¦ »ý¼ºÇÑ´Ù.
			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
			
			// µ¿ÀÏÇÑ Å¸ÀÔÀ» °®Áö¸¸ ´Ù¸¥ »çÀÌµå¸¦ °®´Â °æ¿ì 

			switch (cType) {
			case 43: // Light War Beetle
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "LWB-Aresden"); break;
				case 2: strcpy(cNpcName, "LWB-Elvine"); break;
				}
				break;

			case 36: // Arrow Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "AGT-Aresden"); break;
				case 2: strcpy(cNpcName, "AGT-Elvine"); break;
				}
				break;

			case 37: // Cannon Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CGT-Aresden"); break;
				case 2: strcpy(cNpcName, "CGT-Elvine"); break;
				}
				break;

			case 38: // Mana Collector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "MS-Aresden"); break;
				case 2: strcpy(cNpcName, "MS-Elvine"); break;
				}
				break;

			case 39: // Detector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "DT-Aresden"); break;
				case 2: strcpy(cNpcName, "DT-Elvine"); break;
				}
				break;

			case 51: // Catapult
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CP-Aresden"); break;
				case 2: strcpy(cNpcName, "CP-Elvine"); break;
				}
				break;

			case 44:
				strcpy(cNpcName, "GHK");
				break;

			case 45:
				strcpy(cNpcName, "GHKABS");
				break;

			case 46:
				strcpy(cNpcName, "TK");
				break;

			case 47:
				strcpy(cNpcName, "BG");
				break;

			case 82:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "Sor-Aresden"); break;
					case 2: strcpy(cNpcName, "Sor-Elvine"); break;
				}
				break;

			case 83:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "ATK-Aresden"); break;
					case 2: strcpy(cNpcName, "ATK-Elvine"); break;
				}
				break;

			case 84:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "Elf-Aresden"); break;
					case 2: strcpy(cNpcName, "Elf-Elvine"); break;
				}
				break;

			case 85:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "DSK-Aresden"); break;
					case 2: strcpy(cNpcName, "DSK-Elvine"); break;
				}
				break;

			case 86:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "HBT-Aresden"); break;
					case 2: strcpy(cNpcName, "HBT-Elvine"); break;
				}
				break;

			case 87:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "CT-Aresden"); break;
					case 2: strcpy(cNpcName, "CT-Elvine"); break;
				}
				break;

			case 88:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "Bar-Aresden"); break;
					case 2: strcpy(cNpcName, "Bar-Elvine"); break;
				}
				break;

			case 89:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "AGC-Aresden"); break;
					case 2: strcpy(cNpcName, "AGC-Elvine"); break;
				}
				break;
			}

			//testcode
			wsprintf(G_cTxt, "(!) Request Summon War Unit (%d) (%s)", cType, cNpcName);
			PutLogList(G_cTxt);
			
			tX = (int)dX;
			tY = (int)dY;
						
			// ¸¸¾à ÀüÀï °ÇÃà¹°ÀÌ¶ó¸é °ÇÃà À§Ä¡·ÎºÎÅÍ ÀÎÁ¢ÇØ¾ß ÇÑ´Ù.
			bRet = false;
			switch (cType) {
			case 36:
			case 37:
			case 38:
			case 39:
				// °Ç¼³ À§Ä¡¸¦ ºñ±³
				if (strcmp(m_pClientList[iClientH]->m_cConstructMapName, m_pClientList[iClientH]->m_cMapName) != 0) bRet = true;
				if (abs(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->m_iConstructLocX) > 10) bRet = true;
				if (abs(m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->m_iConstructLocY) > 10) bRet = true;

				if (bRet ) {
					// °Ç¼³ À§Ä¡¿Í ³Ê¹« ¸Ö¸® ¹þ¾î³ª ÀÖÀ¸¸é °ÇÃà ºÒ°¡.
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 2, 0, 0, 0);
					return;
				}

				// ±æµå¿¡¼­ °Ç¼³ÇÑ °ÇÃà¹°ÀÇ °¹¼ö¸¦ Ä«¿îÆ®ÇÑ´Ù. ÀÏÁ¤ °¹¼ö ÀÌ»óÀº ÁöÀ» ¼ö ¾ø´Ù.
				/////
				for (i = 0; i < DEF_MAXGUILDS; i++) 
				if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					if (m_pGuildTeleportLoc[i].m_iV2 >= DEF_MAXCONSTRUCTNUM) {
						// ±æµå °Ç¼³ °³¼ö ÃÊ°ú. ÁöÀ»¼ö ¾ø´Ù.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, 0, 0, 0);		
						return;
					}
					else {
						// °Ç¼³µÈ °Ç¹° °¹¼ö Áõ°¡.
						m_pGuildTeleportLoc[i].m_iV2++;
						goto RSWU_LOOPBREAK;
					}
				}

				// ±æµå ¼³Á¤µÇ¾î ÀÖÁö ¾ÊÀ½. ÁöÀ»¼ö ¾ø´Ù.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, 0, 0, 0);
				return;
				/////
				break;
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 51:
				break;

			case 40:
			case 41:
			case 42:
			case 48:
			case 49:
			case 50:
				break;
			}
			
RSWU_LOOPBREAK:

			// ¸¸¾à ÀüÀï °ÇÃà¹°Áß °¡µåÅ¸¿ö°°ÀÌ °ø°ÝÇüÀÌ¶ó¸é ³Ê¹« ÀÎÁ¢ÇØ¼­ °Ç¼³ÇÒ ¼ö ¾ø´Ù.
			bRet = false;
			switch (cType) {
			case 36:
			case 37:
				for (ix = tX-2; ix <= tX+2; ix++)
				for (iy = tY-2; iy <= tY+2; iy++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_NPC)) {
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 36:
						case 37:
							bRet = true;
							break;
						}
					}
				}

				// ÁöÀ» ¼ö ¾ø´Â »óÀ§ÁÂÇ¥
				if ((dY <= 32) || (dY >= 783)) bRet = true;
				break;
			}

			if (bRet ) {
				// ±ÙÃ³¿¡ °¡µåÅ¸¿öµéÀÌ ÀÖ¾î¼­ °ÇÃàºÒ°¡.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 1, 0, 0, 0);
				return;
			}

			// °¡µå ¸ðµåÀÎ°¡ ÃßÁ¾ ¸ðµåÀÎ°¡ ¼±ÅÃ 
			if (cMode == 0) {
				bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, 0, 0, -1, false, false, false, false, m_pClientList[iClientH]->m_iGuildGUID);
				bSetNpcFollowMode(cName, m_pClientList[iClientH]->m_cCharName, DEF_OWNERTYPE_PLAYER);
			}
			else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, 0, 0, -1, false, false, false, false, m_pClientList[iClientH]->m_iGuildGUID);
				
			if (bRet == false) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			} 
			else {
				// °Ç¼³¿¡ ¼º°øÇßÀ¸¹Ç·Î °Ç¼³ Æ÷ÀÎÆ® °¨¼Ò ½ÃÅ²´Ù.
				m_pClientList[iClientH]->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
				if (m_pClientList[iClientH]->m_iConstructionPoint < 0) m_pClientList[iClientH]->m_iConstructionPoint = 0;
				// ÁöÈÖ°ü¿¡°Ô ¹Ù·Î Åëº¸.
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, 0);
			}
		}
	}
}

void CGame::CheckConnectionHandler(int iClientH, char *pData)
{
 char * cp;
 DWORD * dwp, dwTimeRcv, dwTime, dwTimeGapClient, dwTimeGapServer;

	if (m_pClientList[iClientH] == 0) return;
	//m_pClientList[iClientH]->m_cConnectionCheck = 0;

	dwTime = timeGetTime();
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
	dwTimeRcv = *dwp;

	if (m_pClientList[iClientH]->m_dwInitCCTimeRcv == 0) {
		m_pClientList[iClientH]->m_dwInitCCTimeRcv = dwTimeRcv;
		m_pClientList[iClientH]->m_dwInitCCTime = dwTime;
	}
	else {
		dwTimeGapClient = (dwTimeRcv - m_pClientList[iClientH]->m_dwInitCCTimeRcv);
		dwTimeGapServer = (dwTime - m_pClientList[iClientH]->m_dwInitCCTime);
		
		if (dwTimeGapClient < dwTimeGapServer) return;
		if ((dwTimeGapClient - dwTimeGapServer) >= (DEF_CLIENTTIMEOUT)) {
			DeleteClient(iClientH, true, true);
			return;
		}
	}
}

void CGame::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{

	if (m_pClientList[iClientH] == 0) return;
	if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (iDuty == 3)) return;

	if (m_iLastCrusadeWinner == m_pClientList[iClientH]->m_cSide &&
		m_pClientList[iClientH]->m_dwCrusadeGUID == 0 && iDuty == 3) {
			m_pClientList[iClientH]->m_iConstructionPoint = 3000;
	}
	m_pClientList[iClientH]->m_iCrusadeDuty = iDuty;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, 0);
	if (iDuty == 1) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,0,"Fighter");
	else if (iDuty == 2) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,0,"Constructor");
	else
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,0,"Commander");
}

void CGame::MapStatusHandler(int iClientH, int iMode, char * pMapName)
{
 int i;

	if (m_pClientList[iClientH] == 0) return;

	switch (iMode) {
	case 1:
		if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) return;

		for (i = 0; i < DEF_MAXGUILDS; i++) 
		if ((m_pGuildTeleportLoc[i].m_iV1 != 0) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
				          0, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
						  0, 0, 0, 0, m_pGuildTeleportLoc[i].m_cDestMapName2);	
			// Ǽ ġ  ´.
			ZeroMemory(m_pClientList[iClientH]->m_cConstructMapName, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
			memcpy(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
			m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
			m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
			return;
		}

		//  Ҽ ƴ  û̴.
		break;

	case 3:
		//if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) return;
		//  ĳ ü ʱȭ 
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = 0;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = 0;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = 0;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = 0;
		}
		m_pClientList[iClientH]->m_iCSIsendPoint = 0;
		ZeroMemory(m_pClientList[iClientH]->m_cSendingMapName, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

		if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) {
			//  ڰ ġ   䱸ߴ.
			//  ͸ û   ״ īѴ.
			for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) {
				// v2.15 ڰ Commander  ƴϾ ǹ ġ ش.
				if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
				else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType == 42) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
			}
			memcpy(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
		}
		else {
			// ٸ  Ȳ ûߴ. ̵鷣   
			if (strcmp(pMapName, "middleland") == 0) {
				for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				// v2.15 ڰ Commander  ƴϾ ǹ ġ ش.
					if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}								
					else if (m_stMiddleCrusadeStructureInfo[i].cType == 42)
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}
				}
				strcpy(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
			}
			else {
				//   ʴ ̴.
			}
		}
	
		_SendMapStatus(iClientH);
		break;
	}
}

void CGame::_SendMapStatus(int iClientH)
{
 int i, iDataSize;
 char *cp, cData[DEF_MAXCRUSADESTRUCTURES*6];
 short * sp;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);

	memcpy(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
	cp += 10;
	
	sp = (short *)cp;
	*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
	cp += 2;

	// ÃÑ ¸î°³ÀÇ µ¥ÀÌÅÍ°¡ ÀÖ´ÂÁö ¾Ë¸®´Â °÷ ¶ç¿ò.
	cp++;

	if (m_pClientList[iClientH]->m_iCSIsendPoint == 0)
		m_pClientList[iClientH]->m_bIsSendingMapStatus = true;

	// 100°³¾¿ Á¤º¸¸¦ º¸³½´Ù.
	iDataSize = 0;
	for (i = 0 ; i < 100; i++) {
		if (m_pClientList[iClientH]->m_iCSIsendPoint >= DEF_MAXCRUSADESTRUCTURES) goto SMS_ENDOFDATA;
		if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == 0) goto SMS_ENDOFDATA;
		
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
		cp++;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
		cp += 2;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
		cp++;

		iDataSize += 6;
		m_pClientList[iClientH]->m_iCSIsendPoint++;
	}

	// ¿©±â±îÁö ¿Ô´Ù¸é ´õ º¸³¾ ¸Þ½ÃÁö°¡ ÀÖ´Ù´Â ÀÇ¹Ì.
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAPSTATUSNEXT, iDataSize +13, 0, 0, cData);
	return;

SMS_ENDOFDATA:

	// µ¥ÀÌÅÍ°¡ ´Ù Àü¼Û µÇ¾úÀ½À» ÀÇ¹Ì.
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAPSTATUSLAST, iDataSize +13, 0, 0, cData);
	m_pClientList[iClientH]->m_bIsSendingMapStatus = false;

	return;
}


void CGame::RemoveCrusadeStructures()
{
 int i;

	for (i = 0 ; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != 0) {
		switch (m_pNpcList[i]->m_sType) {
		case 36:
		case 37:
		case 38:
		case 39:
		case 40:
		case 41:
		case 42:
			DeleteNpc(i);
			break;
		}
	}
}

void CGame::RequestHelpHandler(int iClientH)
{
 // ÇïÇÁ ¿äÃ»ÀÌ´Ù. ±æµå ¸¶½ºÅÍ¿¡°Ô ÁÂÇ¥¸¦ Àü´ÞÇØ ÁØ´Ù.
 int i;	

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iGuildRank == -1) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 1) return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iGuildRank == 0) && 
		(m_pClientList[i]->m_iCrusadeDuty == 3) && (m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
		// °°Àº ±æµå ¸¶½ºÅÍÀÌ°í ÁöÈÖ°ü ¿ªÈ°À» ¸ÃÀº »óÅÂÀÌ´Ù.
		SendNotifyMsg(0, i, DEF_NOTIFY_HELP, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_cCharName);
		return;
	}

	// ÇöÀç ¸Ê¿¡ ÁöÈÖ°üÀÌ ¾øÀ½À» Åëº¸ÇØ ÁØ´Ù.
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELPFAILED, 0, 0, 0, 0);
}


bool CGame::bStockMsgToGateServer(char *pData, DWORD dwSize)
{
 //char * cp;

	////testcode
	////wsprintf(G_cTxt, "StockMsg(%d) Size(%d)", *pData, dwSize);
	////PutLogList(G_cTxt);

	//if ((m_iIndexGSS + dwSize) >= DEF_MAXGATESERVERSTOCKMSGSIZE-10) return false;

	//cp = (char *)(m_cGateServerStockMsg + m_iIndexGSS);	
	//memcpy(cp, pData, dwSize);

	//m_iIndexGSS += dwSize;

	return true;
}


void CGame::SendStockMsgToGateServer()
{
 //DWORD * dwp;
 //WORD * wp;
 //char * cp;

	//// ±×µ¿¾È ¸ð¾Æ³õ¾Ò´ø ¸Þ½ÃÁö¸¦ °ÔÀÌÆ® ¼­¹ö·Î Àü¼Û.
	//if (m_iIndexGSS > 6) {
	//	//testcode
	//	//wsprintf(G_cTxt, "(!) Sending Gate Server Stock Msg(%d)", m_iIndexGSS);
	//	//PutLogList(G_cTxt);

	//	SendMsgToGateServer(MSGID_SERVERSTOCKMSG, 0, m_cGateServerStockMsg);
	//
	//	// ¹öÆÛ Å¬¸®¾î
	//	ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
	//	// ¸Ç ¾ÕºÎºÐ¿¡ ¸Þ½ÃÁö »ðÀÔ
	//	cp = (char *)m_cGateServerStockMsg;
	//	dwp = (DWORD *)cp;
	//	*dwp = MSGID_SERVERSTOCKMSG;
	//	cp += 4;
	//	wp = (WORD *)cp;
	//	*wp = DEF_MSGTYPE_CONFIRM;
	//	cp += 2;

	//	m_iIndexGSS = 6;
	//}
}

void CGame::ServerStockMsgHandler(char *pData)
{
// char * cp, * cp2, cTemp[120], cLocation[10], cGuildName[20], cName[11], cTemp2[120], cTemp3[120], cMapName[11], cBuffer[256]; short * sp;
// WORD * wp, wServerID, wClientH, wV1, wV2, wV3, wV4, wV5;
// DWORD * dwp;
// bool bFlag = false;
// int * ip, i, iTotal, iV1, iV2, iV3, iRet;
// short sX, sY;
//
//	iTotal = 0;
//	cp = (char *)(pData + 6);
//	while (bFlag == false) {
//		iTotal++;
//		switch (*cp) {
//		
//// SUMMONGUILD Deleted
//		case GSM_REQUEST_SUMMONGUILD:
//			cp++;
//			ZeroMemory(cGuildName, sizeof(cGuildName));
//			memcpy(cGuildName, cp, 20);
//			cp += 20;
//
//			ZeroMemory(cTemp, sizeof(cTemp));
//			memcpy(cTemp, cp, 10);
//			cp += 10;
//
//			cp2 = (char *) cTemp + 10;
//			wp = (WORD *)cp;
//			wV1 = *wp;
//			cp += 2;
//
//			wp = (WORD *)cp;
//			wV2 = *wp;
//			cp += 2;
//
//			for (i = 0; i < DEF_MAXCLIENTS; i++)
//			if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cGuildName, cGuildName) == 0)) {
//			RequestTeleportHandler(i, "2   ", cTemp, wV1, wV2);
//			}
//			break;
//
//		// v2.14 ¼ºÈÄ´Ï Ãß°¡ À¯Àú ¼ÒÈ¯ 
//		case GSM_REQUEST_SUMMONPLAYER:
//			cp++;
//			ZeroMemory(cName, sizeof(cName));
//			memcpy(cName, cp, 10);
//			cp += 10;
//
//			ZeroMemory(cTemp, sizeof(cTemp));
//			memcpy(cTemp, cp, 10);
//			cp += 10;
//
//			cp2 = (char *) cTemp + 10 ;
//			
//			wp = (WORD *)cp;
//			wV1 = *wp;
//			cp += 2;
//
//			wp = (WORD *)cp;
//			wV2 = *wp;
//			cp += 2;
//			
//			for (i = 1; i < DEF_MAXCLIENTS; i++)
//				if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
//					//wsprintf(G_cTxt, "%s %d %d", cTemp, wV1, wV2);
//					//PutLogFileList(G_cTxt);					
//					RequestTeleportHandler(i, "2   ", cTemp ,wV1, wV2);
//					break;
//				}
//			break;
//		
//		case GSM_REQUEST_SUMMONALL:
//			cp++;
//			ZeroMemory(cLocation, sizeof(cLocation));
//			memcpy(cLocation, cp, 10);
//			cp += 10;
//
//			ZeroMemory(cTemp, sizeof(cTemp));
//			memcpy(cTemp, cp, 10);
//			cp += 10;
//
//			cp2 = (char *) cTemp + 10;
//			
//			wp = (WORD *)cp;
//			wV1 = *wp;
//			cp += 2;
//
//			wp = (WORD *)cp;
//			wV2 = *wp;
//			cp += 2;
//			
//			for (i = 0; i < DEF_MAXCLIENTS; i++)
//			if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cLocation, cLocation) == 0)) {
//			RequestTeleportHandler(i, "2   ", cTemp, wV1, wV2);
//		}
//		break;
//
//		case GSM_CHATMSG:
//			cp++;
//			ZeroMemory(cTemp, sizeof(cTemp));
//			ZeroMemory(cName, sizeof(cName));
//			iV1 = *cp;
//			cp++;
//			ip = (int *)cp;
//			iV2 = *ip;
//			cp += 4;
//			memcpy(cName, cp, 10);
//			cp += 10;;
//			sp = (short *)cp;
//			wV1 = (WORD)*sp;
//			cp += 2;
//			ChatMsgHandlerGSM(iV1, iV2, cName, cp, wV1);
//			cp += wV1;
//			break;
//		
//		case GSM_CONSTRUCTIONPOINT:
//			cp++;
//			ip = (int *)cp;
//			iV1 = *ip;
//			cp += 4;
//			ip = (int *)cp;
//			iV2 = *ip;
//			cp += 4;
//			GSM_ConstructionPoint(iV1, iV2);
//			break;
//
//		case GSM_SETGUILDTELEPORTLOC:
//			cp++;
//			ip = (int *)cp;
//			iV1 = *ip;
//			cp += 4;
//			ip = (int *)cp;
//			iV2 = *ip;
//			cp += 4;
//			ip = (int *)cp;
//			iV3 = *ip;
//			cp += 4;
//			ZeroMemory(cTemp, sizeof(cTemp));
//			memcpy(cTemp, cp, 10);
//			cp += 10;
//			GSM_SetGuildTeleportLoc(iV1, iV2, iV3, cTemp);
//			break;
//
//		case GSM_SETGUILDCONSTRUCTLOC:
//			cp++;
//			ip = (int *)cp;
//			iV1 = *ip;
//			cp += 4;
//			ip = (int *)cp;
//			iV2 = *ip;
//			cp += 4;
//			ip = (int *)cp;
//			iV3 = *ip;
//			cp += 4;
//			ZeroMemory(cTemp, sizeof(cTemp));
//			memcpy(cTemp, cp, 10);
//			cp += 10;
//			GSM_SetGuildConstructLoc(iV1, iV2, iV3, cTemp);
//			break;
//
//		case GSM_REQUEST_SETFORCERECALLTIME:
//			cp++;
//			wp = (WORD *)cp;
//			m_sForceRecallTime = *wp;
//			cp += 2;
//
//			wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
//			PutLogList(G_cTxt) ;
//			break;
//
//		case GSM_MIDDLEMAPSTATUS:
//			cp++;
//			// ±¸Á¶Ã¼ Å¬¸®¾î
//			for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
//				m_stMiddleCrusadeStructureInfo[i].cType = 0;
//				m_stMiddleCrusadeStructureInfo[i].cSide = 0;
//				m_stMiddleCrusadeStructureInfo[i].sX    = 0;
//				m_stMiddleCrusadeStructureInfo[i].sY    = 0;
//			}
//			sp = (short *)cp;
//			m_iTotalMiddleCrusadeStructures = *sp;
//			cp += 2;
//			// Á¤º¸ ÀÐ¾îµéÀÎ´Ù.
//			for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
//				m_stMiddleCrusadeStructureInfo[i].cType = *cp;
//				cp++;
//				m_stMiddleCrusadeStructureInfo[i].cSide = *cp;
//				cp++;
//				sp = (short *)cp;
//				m_stMiddleCrusadeStructureInfo[i].sX = *sp;
//				cp += 2;
//				sp = (short *)cp;
//				m_stMiddleCrusadeStructureInfo[i].sY = *sp;
//				cp += 2;	
//			}
//			break;
//		
//		case GSM_BEGINCRUSADE:
//			cp++;
//			dwp = (DWORD *)cp;
//			cp += 4;
//			LocalStartCrusadeMode(*dwp);
//			break;
//
//		case GSM_BEGINAPOCALYPSE:
//			cp++;
//			dwp = (DWORD *)cp;
//			cp += 4;
//			LocalStartApocalypse(*dwp);
//			break;
//
//		case GSM_STARTHELDENIAN:
//			cp++;
//			wp  = (WORD *)cp;
//			wV1 = *wp;
//			cp += 2;
//			wp  = (WORD *)cp;
//			wV2 = *wp;
//			cp += 2;
//			dwp = (DWORD *)cp;
//			cp += 4;
//			LocalStartHeldenianMode(wV1, wV2, *dwp);
//			break;
//
//		case GSM_ENDHELDENIAN:
//			cp++;
//			LocalEndHeldenianMode();
//			break;
//			
//			/*case GSM_BEGINHELDENIEN:
//			cp++;
//			dwp = (DWORD *)cp;
//			cp += 4;
//			LocalStartHeldenian(*dwp);
//			break;
//		
//		case GSM_ENDHeldenian:
//			cp++;
//			LocalEndHeldenian(*dwp)//sub_4ABCD0(*dwp);
//			break;*/
//
//		case GSM_UPDATECONFIGS:
//			cp++;
//			LocalUpdateConfigs(*cp);
//			cp += 16;
//			break;
//
//		case GSM_ENDAPOCALYPSE:
//			cp++;
//			LocalEndApocalypse();
//			break;
//
//		case GSM_ENDCRUSADE:
//			cp++;
//			LocalEndCrusadeMode(*cp);
//			cp += 16;
//			break;
//
//		case GSM_COLLECTEDMANA:
//			cp++;
//			wp  = (WORD *)cp;
//			wV1 = *wp;
//			cp += 2;
//
//			wp  = (WORD *)cp;
//			wV2 = *wp;
//			cp += 2;
//			CollectedManaHandler(wV1, wV2);
//			break;
//
//		case GSM_GRANDMAGICLAUNCH:
//			cp++;
//			wp  = (WORD *)cp;
//			wV1 = *wp;
//			cp += 2;
//
//			wp  = (WORD *)cp;
//			wV2 = *wp;
//			cp += 2;
//
//			switch (wV1) {
//			case 1: // ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© 
//				MeteorStrikeMsgHandler((char)wV2);
//				break;
//			}
//			break;
//		
//		case  GSM_GRANDMAGICRESULT:
//			cp++;
//			ZeroMemory(cTemp, sizeof(cTemp));
//			memcpy(cTemp, cp, 10);
//			cp += 10;
//			wp  = (WORD *)cp;
//			wV1 = *wp;
//			cp += 2;
//			wp  = (WORD *)cp;
//			wV2 = *wp;
//			cp += 2;
//			wp  = (WORD *)cp;
//			wV3 = *wp;
//			cp += 2;
//			wp  = (WORD *)cp;
//			wV4 = *wp;
//			cp += 2;
//
//			wp  = (WORD *)cp;
//			wV5 = *wp;
//
//			GrandMagicResultHandler(cTemp, wV1, wV2, wV3, wV4, wV5, cp);
//			break;
//		
//			// v2.15 2002-5-21
//		case GSM_REQUEST_SHUTUPPLAYER:
//			cp++;
//			wp = (WORD *)cp;
//			wServerID = *wp;
//			cp += 2;
//			wp = (WORD *)cp;
//			wClientH = *wp;
//			cp += 2;
//
//			ZeroMemory(cName, sizeof(cName));
//			memcpy(cName, cp, 10);
//			cp += 10;
//
//			wp  = (WORD *)cp;
//			wV1 = *wp;
//			cp += 2;
//
//			ZeroMemory(cTemp, sizeof(cTemp));
//			memcpy(cTemp, cp, 10);
//			cp += 10;
//
//			GSM_RequestShutupPlayer(cTemp,wServerID,wClientH, wV1, cName);
//			break ;
//
//		case GSM_RESPONSE_SHUTUPPLAYER:
//			cp++;
//			wp = (WORD *)cp;
//			wServerID = *wp;
//			cp += 2;
//			wp = (WORD *)cp;
//			wClientH = *wp;
//			cp += 2;
//
//			ZeroMemory(cName, sizeof(cName));
//			memcpy(cName, cp, 10);
//			cp += 10;
//
//			wp  = (WORD *)cp;
//			wV1 = *wp;
//			cp += 2;
//
//			ZeroMemory(cTemp, sizeof(cTemp));
//			memcpy(cTemp, cp, 10);
//			cp += 10;
//
//
//			if (wServerID == m_wServerID_GSS) {
//				if ((m_pClientList[wClientH] != 0)&& (strcmp(m_pClientList[wClientH]->m_cCharName, cName) == 0)&&(m_pClientList[wClientH]->m_iAdminUserLevel > 0)) {
//					SendNotifyMsg(0, wClientH, DEF_NOTIFY_PLAYERSHUTUP, wV1, 0, 0, cTemp);
//
//				}
//			}
//			break;
//
//		// New 16/05/2004
//		case GSM_WHISFERMSG:
//			ZeroMemory(cName, sizeof(cName));
//			ZeroMemory(cBuffer, sizeof(cBuffer));
//			cp++;
//			memcpy(cName, cp, 10);
//			cp += 10;
//			wp = (WORD *)cp;
//			wV1 = *wp;
//			cp += 2;
//
//			memcpy(cBuffer, cp, wV1);
//			cp += wV1;
//
//			for (i = 1; i < DEF_MAXCLIENTS; i++)
//				if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
//					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cBuffer, wV1);
//					if(	m_pClientList[i]->m_iAdminUserLevel > 0) {
//						char cTxt[200],cTmpName[12] ;
//						ZeroMemory(cTxt,sizeof(cTxt)) ;
//						ZeroMemory(cTmpName,sizeof(cTmpName)) ;
//
//						memcpy(cTmpName,cBuffer+10,10) ;
//						wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",cTmpName,cBuffer+21,m_pClientList[i]->m_cCharName) ;
//						bSendMsgToLS(MSGID_GAMEMASTERLOG, i, 0, cTxt);
//					}
//					break;
//				}
//		break;
//
//		// New 16/05/2004 Changed
//		case GSM_REQUEST_FINDCHARACTER:
//			cp++;
//
//			wp = (WORD *)cp;
//			wServerID = *wp;
//			cp += 2;
//
//			wp = (WORD *)cp;
//			wClientH = *wp;
//			cp += 2;
//
//			ZeroMemory(cTemp, sizeof(cTemp));
//			memcpy(cTemp, cp, 10);
//			cp += 10;
//
//			ZeroMemory(cTemp2, sizeof(cTemp2));
//			memcpy(cTemp2, cp, 10);
//			cp += 10;
//
//			GSM_RequestFindCharacter(wServerID, wClientH, cTemp, cTemp2);
//			break;
//
//		case GSM_RESPONSE_FINDCHARACTER:
//			sX = -1;
//			sY = -1;
//			cp++;
//			wp = (WORD *)cp;
//			wServerID = *wp;
//			cp += 2;
//			wp = (WORD *)cp;
//			wClientH = *wp;
//			cp += 2;
//			ZeroMemory(cTemp, sizeof(cTemp));
//			memcpy(cTemp, cp, 10);
//			cp += 10;
//
//			ZeroMemory(cTemp2, sizeof(cTemp2));
//			memcpy(cTemp2, cp, 10);
//			cp += 10;
//
//			ZeroMemory(cTemp3, sizeof(cTemp3));
//			memcpy(cTemp3, cp, 14);
//
//			if ((wServerID == m_wServerID_GSS) && m_pClientList[wClientH] != 0) {
//				if (m_pClientList[wClientH]->m_bIsAdminOrderGoto ) {
//					m_pClientList[wClientH]->m_bIsAdminOrderGoto = false;
//					ZeroMemory(cMapName, sizeof(cMapName));
//					memcpy(cMapName, cp, 10);
//					cp += 10;
//
//					wp = (WORD *)cp;
//					sX = *wp;
//					cp += 2;
//
//					wp = (WORD *)cp;
//					sY = *wp;
//					cp += 2;
//
//					if (m_pClientList[wClientH]->m_iAdminUserLevel > 0) {
//						if(sX == -1 && sY == -1){
//							wsprintf(G_cTxt,"GM Order(%s): GoTo MapName(%s)",m_pClientList[wClientH]->m_cCharName, cMapName);
//						}
//						else{
//							wsprintf(G_cTxt,"GM Order(%s): GoTo MapName(%s)(%d %d)",m_pClientList[wClientH]->m_cCharName,
//								cMapName, sX, sY);
//						}
//						bSendMsgToLS(MSGID_GAMEMASTERLOG, wClientH, false, G_cTxt);
//						RequestTeleportHandler(wClientH,"2   ", cMapName, sX, sY);
//					}
//				}
//				else{
//					if ((m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer ) && (strcmp(m_pClientList[wClientH]->m_cWhisperPlayerName, cTemp) == 0)) {
//						m_pClientList[wClientH]->m_iWhisperPlayerIndex = 10000;
//						SendNotifyMsg(0, wClientH, DEF_NOTIFY_WHISPERMODEON, 0, 0, 0, m_pClientList[wClientH]->m_cWhisperPlayerName);
//					}
//					else{
//						if (m_pClientList[wClientH]->m_iAdminUserLevel == 0) {
//							ZeroMemory(cTemp3, sizeof(cTemp3));
//						}
//						if (strcmp(m_pClientList[wClientH]->m_cCharName, cTemp2) == 0) {
//							SendNotifyMsg(0, wClientH, DEF_NOTIFY_PLAYERONGAME, 0, 0, 0, cTemp,
//								0, 0, 0, 0, 0, 0, cTemp3);
//						}
//					}
//				}
//			}
//			break;
//
//		default:
//			bFlag = true;
//			break;
//		}
//	}

	//testcode
	//wsprintf(G_cTxt, "(!) Total %d GSM Messages.", iTotal-1);
	//PutLogList(G_cTxt);
}

void CGame::GSM_RequestFindCharacter(WORD wReqServerID, WORD wReqClientH, char *pName, char * pFinder)
{
 //char * cp, cTemp[120];
 //WORD * wp;
 //int i;

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	//if ((m_pClientList[i] != 0)  && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
	//	// Ã£¾Ò´Ù.
	//	ZeroMemory(cTemp, sizeof(cTemp));
	//	cp = (char *)(cTemp);
	//	*cp = GSM_RESPONSE_FINDCHARACTER;
	//	cp++;

	//	wp = (WORD *)cp;
	//	*wp = wReqServerID;
	//	cp += 2;

	//	wp = (WORD *)cp;
	//	*wp = wReqClientH;
	//	cp += 2;
	//	
	//	memcpy(cp, pName, 10);
	//	cp += 10;

	//	memcpy(cp, pFinder, 10);
	//	cp += 10;

	//	memcpy(cp, m_pClientList[i]->m_cMapName, 10);
	//	cp += 10;

	//	wp = (WORD *)cp;
	//	*wp = m_pClientList[i]->m_sX;
	//	cp += 2;

	//	wp = (WORD *)cp;
	//	*wp = m_pClientList[i]->m_sY;
	//	cp += 2;

	//	bStockMsgToGateServer(cTemp, 39);
	//	return;	
	//}
}

// New 11/05/2004 Changed
void CGame::DoMeteorStrikeDamageHandler(int iMapIndex)
{
 int i, iDamage;

	// ÇØ´ç ¸ÊÀÇ ÇÃ·¹ÀÌ¾îµéÀÇ HP¸¦ ÀÏ°ý »è°¨
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_cSide != 0) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
		if (m_pClientList[i]->m_iLevel < 80) 
			 iDamage = m_pClientList[i]->m_iLevel   +iDice(1,10);
		else iDamage = m_pClientList[i]->m_iLevel*2 +iDice(1,10);
		iDamage = iDice(1, m_pClientList[i]->m_iLevel) + m_pClientList[i]->m_iLevel;
		// ÃÖ´ë 255ÀÌ»óÀÇ ´ë¹ÌÁö´Â ¹ÞÁö ¾Ê´Â´Ù.
		if (iDamage > 255) iDamage = 255;
	
		if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) { //magic cut in half
			iDamage = (iDamage/2) - 2;
		}

		if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 5) { 
			iDamage = 0;
		}
		
		if (m_pClientList[i]->m_iAdminUserLevel > 0) { // Admins get no damage
			iDamage = 0;
		}

		m_pClientList[i]->m_iHP -= iDamage;
		if (m_pClientList[i]->m_iHP <= 0) {
			// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
			ClientKilledHandler(i, 0, 0, iDamage);	
			m_stMeteorStrikeResult.iCasualties++;
		}
		else {
			if (iDamage > 0) {
				// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
				SendNotifyMsg(0, i, DEF_NOTIFY_HP, 0, 0, 0, 0);
				// Ãæ°ÝÀ» ¹Þ¾Ò´Ù¸é Ãæ°Ýµ¿ÀÛ Àü¼Û 
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

				// v1.4 Á×ÀºÃ´ÇÏ°í ÀÖ´Â °æ¿ì´Â Owner À§Ä¡¸¦ ¿Å±ä´Ù. 
				if (m_pClientList[i]->m_bSkillUsingStatus[19] != true) {
					m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				}
			
				if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. ¸¶¹ý°ø°Ý ÆÐ·²¶óÀÌÁî µÈ °Íµµ Ç®¸°´Ù.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(0, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], 0, 0);
							
					m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
					bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}		
	}
}

void CGame::SyncMiddlelandMapInfo()
{
 int i;
 char * cp;
 short * sp;

	// ̵鷣    ũŲ. ̵鷣带   ٷ ü Ʈ ϰ  鿡  .
	if (m_iMiddlelandMapIndex != -1) {
		// ü Ŭ
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = 0;
			m_stMiddleCrusadeStructureInfo[i].cSide = 0;
			m_stMiddleCrusadeStructureInfo[i].sX    = 0;
			m_stMiddleCrusadeStructureInfo[i].sY    = 0;
		}
		// ü    ޽ ۼ 
		m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		/*ZeroMemory(G_cData50000, sizeof(G_cData50000));
		cp = (char *)G_cData50000;
		*cp = GSM_MIDDLEMAPSTATUS;
		cp++;

		sp = (short *)cp;
		*sp = (short)m_iTotalMiddleCrusadeStructures;
		cp += 2;*/
				
		for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cType;
			m_stMiddleCrusadeStructureInfo[i].cSide = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cSide;
			m_stMiddleCrusadeStructureInfo[i].sX    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sX;
			m_stMiddleCrusadeStructureInfo[i].sY    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sY;
			
			/**cp = m_stMiddleCrusadeStructureInfo[i].cType;
			cp++;
			*cp = m_stMiddleCrusadeStructureInfo[i].cSide;
			cp++;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sY;
			cp += 2;*/
		}
		
		// ޽ .
		if (m_iTotalMiddleCrusadeStructures != 0) {
			//testcode
			//wsprintf(G_cTxt, "m_iTotalMiddleCrusadeStructures: %d", m_iTotalMiddleCrusadeStructures);
			//PutLogList(G_cTxt);
			//bStockMsgToGateServer(G_cData50000, 3 + m_iTotalMiddleCrusadeStructures*6);
		}
	}
}

void CGame::GSM_SetGuildConstructLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int i, iIndex;
 DWORD dwTemp, dwTime;

	// Å¬¶óÀÌ¾ðÆ®·ÎºÎÅÍÀÇ ¿äÃ»ÀÌ ¾Æ´Ï¶ó ´Ù¸¥ ¼­¹ö·ÎºÎÅÍÀÇ ÅÚ·¹Æ÷Æ® ÁÂÇ¥ ¼³Á¤ ¿äÃ»ÀÓ. ÀÀ´äÇÒ ÇÊ¿ä ¾øÀ½.
	
	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	// ¸ÕÀú °°Àº GUID¸¦ °¡Áø ±æµå ÅÚ·¹Æ÷Æ® ÁÂÇ¥°¡ ¼³Á¤µÇ¾î ÀÖ´ÂÁö Ã£´Â´Ù.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// ÀÌ¹Ì ±æµå°¡ ÀÖ´Ù.
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			// ³»¿ëÀÌ ÀÏÄ¡ÇÑ´Ù. Å¸ÀÓ ÀÔ·ÂÈÄ ½ºÅµ.
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// ³»¿ë °»½Å
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
	}
	
	// ¼³Á¤µÈ ³»¿ëÀÌ ¾ø´Ù. »õ·Î ¼³Á¤ÇÑ´Ù.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == 0) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// °¡Àå ¿À·§µ¿¾È ÂüÁ¶µÇÁö ¾ÊÀº ¸®½ºÆ®ÀÇ ÀÎµ¦½º¸¦ Ã£´Â´Ù.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// Ä³½Ã °ø°£ÀÌ ´Ù Ã¡´Ù. ÀÌ·± °æ¿ì ¸®½ºÆ® Áß °¡Àå ¿À·§µ¿¾È »ç¿ëÇÏÁö ¾ÊÀº ¸®½ºÆ®(iIndex)¸¦ »èÁ¦ÇÏ°í ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstLocuct Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
}

void CGame::CheckCommanderConstructionPoint(int iClientH)
{
 char * cp, cData[120];
 int  * ip, i;

	if (m_pClientList[iClientH] == 0) return;
	if (m_bIsCrusadeMode == false) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

	switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
	case 1: // ÆÄÀÌÅÍ
	case 2: // °Ç¼³ÀÚ: ¸ð¾Æ ³õÀº Æ÷ÀÎÆ®¸¦ ±æµå¸¶½ºÅÍ ÁöÈÖ°ü¿¡°Ô Àü´ÞÇÑ´Ù.
		for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
			(m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
			// ÇöÀç ¼­¹ö ³»¿¡ ±æµå¸¶½ºÅÍ ÁöÈÖ°üÀÌ ÀÖ´Ù. ÁöÈÖ°üÀÇ Æ÷ÀÎÆ®¸¦ ³ôÀÎ ÈÄ 
			m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;
			m_pClientList[i]->m_iWarContribution   += (m_pClientList[iClientH]->m_iConstructionPoint / 10);

			if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
				m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
			if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
				m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

			SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, 0);
			m_pClientList[iClientH]->m_iConstructionPoint = 0; // °ª ÃÊ±âÈ­ 
			return;
		}

		// ´Ù¸¥ ¼­¹öÀÇ ÁöÈÖ°ü¿¡°Ô ¾Ë·Á¾ß ÇÑ´Ù.
		/*ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_CONSTRUCTIONPOINT;
		cp++;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iConstructionPoint;
		cp += 4;
		bStockMsgToGateServer(cData, 9);*/

		m_pClientList[iClientH]->m_iConstructionPoint = 0; // °ª ÃÊ±âÈ­ 
		break;

	case 3: // ÁöÈÖ°ü: º¸³¾ ÇÊ¿ä ¾øÀ½ 
		
		break;
	}
}

void CGame::GSM_ConstructionPoint(int iGuildGUID, int iPoint)
{
 int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
		(m_pClientList[i]->m_iGuildGUID == iGuildGUID)) {
		// ÇØ´ç ±æµå¸¶½ºÅÍ ÁöÈÖ°üÀ» Ã£¾Ò´Ù.
		m_pClientList[i]->m_iConstructionPoint += iPoint;
		m_pClientList[i]->m_iWarContribution   += iPoint/10;
		
		if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
			m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
		if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
			m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

		SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, 0);
		//testcode
		wsprintf(G_cTxt, "GSM_ConstructionPoint: %d %d", iGuildGUID, iPoint);
		PutLogList(G_cTxt);
		return;
	}
}

bool CGame::bAddClientShortCut(int iClientH)
{
 int i; 

	// ¸ÕÀú µ¿ÀÏÇÑ ¹øÈ£°¡ Á¸ÀçÇÏ´ÂÁö °Ë»ö

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == iClientH) return false;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == 0) {
		m_iClientShortCut[i] = iClientH;
		return true;
	}

	return false;
}

void CGame::RemoveClientShortCut(int iClientH)
{
 int i;

	for (i = 0; i < DEF_MAXCLIENTS+1; i++)
	if (m_iClientShortCut[i] == iClientH) {
		m_iClientShortCut[i] = 0;
		goto RCSC_LOOPBREAK;
	}

RCSC_LOOPBREAK:

	// ºó ¿©¹éÀ» ¸Þ²Û´Ù.
	//m_iClientShortCut[i] = m_iClientShortCut[m_iTotalClients+1];
	//m_iClientShortCut[m_iTotalClients+1] = 0;
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i+1] != 0)) {
		m_iClientShortCut[i] = m_iClientShortCut[i+1];
		m_iClientShortCut[i+1] = 0;
	}
}

void CGame::_CreateCrusadeGUID(DWORD dwCrusadeGUID, int iWinnerSide)
{
 char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;
		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"CrusadeGUID.Txt");
		
	pFile = fopen(cFn, "wt");
	if (pFile == 0) {
		// ÆÄÀÏÀ» ¸¸µé ¼ö ¾ø°Å³ª »çÀÌÁî°¡ Áö³ªÄ¡°Ô ÀÛÀº °æ¿ì´Â . 
		wsprintf(cTxt, "(!) Cannot create CrusadeGUID(%d) file", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "CrusadeGUID = %d\n", dwCrusadeGUID);
		strcat(cTemp, cTxt);

		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) CrusadeGUID(%d) file created", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	if (pFile != 0) fclose(pFile);
}


bool CGame::bReadCrusadeGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open CrusadeGUID file.");
		return false;
	}
	else {
		PutLogList("(!) Reading CrusadeGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != 0 )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwCrusadeGUID = atoi(token);
					wsprintf(G_cTxt, "CrusadeGUID = %d", m_dwCrusadeGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;

				case 2:
					// New 13/05/2004 Changed
					m_iLastCrusadeWinner = atoi(token);
					wsprintf(G_cTxt, "CrusadeWinnerSide = %d", m_iLastCrusadeWinner);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "CrusadeGUID", 11) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

void CGame::ManualEndCrusadeMode(int iWinnerSide)
{
 char * cp, cData[256];
 WORD * wp;

	// ¸Å´º¾ó·Î Å©·ç¼¼ÀÌµå ¸ðµå¸¦ Á¾·á½ÃÅ²´Ù. ºñ±ä »óÅÂ·Î Á¾·á½ÃÅ²´Ù.
	if (m_bIsCrusadeMode == false) return;

	LocalEndCrusadeMode(iWinnerSide);

	// ´Ù¸¥ ¼­¹ö¿¡ Å©·ç¼¼ÀÌµå Á¾·á¸¦ ¾Ë¸².
	/*ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp =  GSM_ENDCRUSADE;
	cp++;

	*cp = (char)iWinnerSide;
	cp++;			

	wp  = (WORD *)cp;
	*wp = 0;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = 0;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = 0;
	cp += 2;
		
	cp += 10;

	bStockMsgToGateServer(cData, 18);*/
}

int CGame::iGetMapLocationSide(char *pMapName)
{

	if (strcmp(pMapName, "aresden") == 0) return 3;
	if (strcmp(pMapName, "elvine") == 0) return 4;
	if (strcmp(pMapName, "arebrk11") == 0) return 3;
	if (strcmp(pMapName, "elvbrk11") == 0) return 4;

	if (strcmp(pMapName, "cityhall_1") == 0) return 1;
	if (strcmp(pMapName, "cityhall_2") == 0) return 2;
	if (strcmp(pMapName, "cath_1") == 0) return 1;
	if (strcmp(pMapName, "cath_2") == 0) return 2;
	if (strcmp(pMapName, "gshop_1") == 0) return 1;
	if (strcmp(pMapName, "gshop_2") == 0) return 2;
	if (strcmp(pMapName, "bsmith_1") == 0) return 1;
	if (strcmp(pMapName, "bsmith_2") == 0) return 2;
	if (strcmp(pMapName, "wrhus_1") == 0) return 1;
	if (strcmp(pMapName, "wrhus_2") == 0) return 2;
	if (strcmp(pMapName, "gldhall_1") == 0) return 1;
	if (strcmp(pMapName, "gldhall_2") == 0) return 2;
	if (strcmp(pMapName, "wzdtwr_1") == 0) return 1;
	if (strcmp(pMapName, "wzdtwr_2") == 0) return 2;
	if (strcmp(pMapName, "arefarm") == 0) return 1;
	if (strcmp(pMapName, "elvfarm") == 0) return 2;
	if (strcmp(pMapName, "arewrhus") == 0) return 1;
	if (strcmp(pMapName, "elvwrhus") == 0) return 2;
	if (strcmp(pMapName, "cmdhall_1") == 0) return 1;
	if (strcmp(pMapName, "Cmdhall_2") == 0) return 2;

	return 0;
}

bool CGame::bCopyItemContents(CItem * pCopy, CItem *pOriginal)
{
	if (pOriginal == 0) return false;
	if (pCopy == 0) return false;
	
	pCopy->m_sIDnum = pOriginal->m_sIDnum;					// ¾ÆÀÌÅÛÀÇ °íÀ¯ ¹øÈ£ 
	pCopy->m_cItemType = pOriginal->m_cItemType;
	pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
	pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;     
	pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
	pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
	pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3; 
	pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
	pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
	pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6; 
	pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
	pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;
	
	//short m_sSM_HitRatio, m_sL_HitRatio;
	//v1.432 ¸íÁß·ü °¡°¨ »ç¿ë ¾ÈÇÑ´Ù. ´ë½Å Æ¯¼ö ´É·Â ¼öÄ¡°¡ µé¾î°£´Ù.
	pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
	pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2; 

	pCopy->m_sSprite = pOriginal->m_sSprite;
	pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;

	pCopy->m_cApprValue = pOriginal->m_cApprValue;
	pCopy->m_cSpeed = pOriginal->m_cSpeed;

	pCopy->m_wPrice = pOriginal->m_wPrice; 
	pCopy->m_wWeight = pOriginal->m_wWeight;
	pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;	
	pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;

	pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;
	
	pCopy->m_cCategory = pOriginal->m_cCategory;
	pCopy->m_bIsForSale = pOriginal->m_bIsForSale;
	// 

	pCopy->m_dwCount = pOriginal->m_dwCount;
	pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
	pCopy->m_sTouchEffectValue1 =pOriginal->m_sTouchEffectValue1;
	pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
	pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
	pCopy->m_cItemColor = pOriginal->m_cItemColor;
	pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
	pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
	pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
	pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
	pCopy->m_dwAttribute = pOriginal->m_dwAttribute;			

	return true;
}


void CGame::AdminOrder_SummonStorm(int iClientH, char* pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n"; 
	char   * token, cBuff[256], cOwnerType;
	int    i; 
	class  CStrTok * pStrTok; 
	short  sOwnerH,sType,sX,sY;
	int    dX1,dY1,iWhetherBonus,iResult = 0,tX,tY,iErr,ix,iy;
	int    iStormCount,iMagicAttr;

	if (m_pClientList[iClientH] == 0) return; 
	if ((dwMsgSize)   <= 0) return; 
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == false) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelStorm) { 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0); 
		return; 
	} 

	ZeroMemory(cBuff, sizeof(cBuff)); 
	memcpy(cBuff, pData, dwMsgSize); 

	pStrTok = new class CStrTok(cBuff, seps); 
	token = pStrTok->pGet(); 
	token = pStrTok->pGet(); 

	//No Storm Specified
	if (token == 0) { 
		delete pStrTok; 
		return; 
	} 
	
	sType = atoi(token);

	//Only 100 Magic Spells
	if (sType <= 0)	sType = 1;
	if (sType > 100) sType = 100;

	//No Count Specified
	token = pStrTok->pGet(); 
	if (token == 0) { 
		delete pStrTok; 
		return; 
	} 
	iStormCount = atoi(token);

	if (iStormCount < 0)
		iStormCount = 0;
	if (iStormCount > 30)
		iStormCount = 30;//Original : 30

try{
	//Whether Bouns
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);
	
	//Magic Attribute
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	//Calculate Area Coords
	//Gives Right
	dX1= m_pClientList[iClientH]->m_sX;
	dX1-=10;
	//Gives Top
	dY1= m_pClientList[iClientH]->m_sY;
	dY1-=7;

	while (iStormCount != 0) {
		int randX,randY;
		randX = (rand() % 20) + dX1;
		randY = (rand() % 13) + dY1;

		switch (m_pMagicConfigList[sType]->m_sType) {
			case DEF_MAGICTYPE_DAMAGE_SPOT:
				//Calculate Damage
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, randX, randY);
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, randX, randY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);
				}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;

			case DEF_MAGICTYPE_DAMAGE_LINEAR:
				// ÀÏÁ÷¼± »ó¿¡ ÀÖ´Â ¸ñÇ¥¸¦ ¸ðµÎ °ø°ÝÇÑ´Ù.
				sX = m_pClientList[iClientH]->m_sX;
				sY = m_pClientList[iClientH]->m_sY;

				for (i = 2; i < 10; i++) {
					iErr = 0;
					m_Misc.GetPoint2(sX, sY, randX, randY, &tX, &tY, &iErr, i);

					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {
							// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						}

						// tx-1, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
							}

							// tx+1, ty
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
								}

							// tx, ty-1
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
									}

							// tx, ty+1
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
									if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
										(m_pClientList[sOwnerH]->m_iHP > 0) ) {
											// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
										}

									if ( (abs(tX - randX) <= 1) && (abs(tY - randY) <= 1)) break;
					}

					// ÁÖº¯ °ø°Ý È¿°ú 
					for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
								}
						}

						// dX, dY
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, randX, randY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr); // v1.41 false

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, randX, randY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {
						// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr); // v1.41 false
					}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;

			case DEF_MAGICTYPE_DAMAGE_AREA:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, randX, randY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, randX, randY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0) ) {
						// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);
					}

				// ÁÖº¯ °ø°Ý È¿°ú 
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, randX, randY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, randX, randY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
							}
					}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;
		default:
			goto Skip_Storm;
	}
		Sleep(rand() % 10);
		iStormCount--;
	}
}
catch(...){}
Skip_Storm:
	delete pStrTok;
}

void CGame::SendMsg(short sOwnerH, char cOwnerType, bool bStatus, long lPass) { 
	if (m_pClientList[sOwnerH] == 0) return; 
	//SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_LEVELUP, 0, 0, 0, 0);

	SendNotifyMsg(0, sOwnerH, lPass, 0, 0, 0, 0);

}

//ArchAngel Function
void CGame::AdminOrder_Weather(int iClientH, char * pData, DWORD dwMsgSize) 
{ 
char   seps[] = "= \t\n"; 
char   * token, cBuff[256]; 
class  CStrTok * pStrTok; 
char cPrevMode; 
int i, j, sType, sTime; 
DWORD dwTime; 

  dwTime = timeGetTime(); 

  if (m_pClientList[iClientH] == 0) return; 
  if ((dwMsgSize)   <= 0) return; 

  if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelWeather) { 
     SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0); 
     return; 
  } 
   
  ZeroMemory(cBuff, sizeof(cBuff)); 
  memcpy(cBuff, pData, dwMsgSize); 

  pStrTok = new class CStrTok(cBuff, seps); 
  token = pStrTok->pGet(); 
  token = pStrTok->pGet(); 
   
  if (token == 0) { 
     delete pStrTok; 
     return; 
  } 

     sType = atoi(token); 

  token = pStrTok->pGet(); 

  if (token == 0) { 
     delete pStrTok; 
     return; 
  } 

  sTime = atoi(token); 

  delete pStrTok; 
   
  for (i = 0; i < DEF_MAXMAPS; i++) { 
     if ((m_pMapList[i] != 0) && (m_pMapList[i]->m_bIsFixedDayMode == false)) { 
        cPrevMode = m_pMapList[i]->m_cWhetherStatus; 
        if (m_pMapList[i]->m_cWhetherStatus != 0) { 
           if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
              m_pMapList[i]->m_cWhetherStatus = 0; 
        } 
        else { 
           sTime *= 1000; 
           m_pMapList[i]->m_cWhetherStatus = sType; 
           m_pMapList[i]->m_dwWhetherStartTime = dwTime; 
           m_pMapList[i]->m_dwWhetherLastTime  = sTime; 
        } 
        if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) { 
           for (j = 1; j < DEF_MAXCLIENTS; j++) 
           if ((m_pClientList[j] != 0) && (m_pClientList[j]->m_bIsInitComplete ) && (m_pClientList[j]->m_cMapIndex == i)) 
              SendNotifyMsg(0, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, 0, 0, 0);    
        } 
     } 
  } 
}

void CGame::RequestChangePlayMode(int iClientH)
{

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPKCount > 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if (memcmp(m_pClientList[iClientH]->m_cMapName,"cityhall",8) != 0) return;

	if (m_pClientList[iClientH]->m_iLevel < 100||
		m_pClientList[iClientH]->m_bIsPlayerCivil ) {
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden",7) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"arehunter");
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine",6) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"elvhunter");
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter",9) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"aresden");
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter",9) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"elvine");

			if (m_pClientList[iClientH]->m_bIsPlayerCivil )
				m_pClientList[iClientH]->m_bIsPlayerCivil = false;
			else m_pClientList[iClientH]->m_bIsPlayerCivil = true;

			SendNotifyMsg(0,iClientH,DEF_NOTIFY_CHANGEPLAYMODE,0,0,0,m_pClientList[iClientH]->m_cLocation);
			SendEventToNearClient_TypeA(iClientH,DEF_OWNERTYPE_PLAYER,MSGID_EVENT_MOTION,100,0,0,0);
		}

	g_login->LocalSavePlayerData(iClientH);
}

void CGame::AdminOrder_SetStatus(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, * token2, cBuff[256];
	int    iPass;
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetStatus) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token2 = pStrTok->pGet();

	iPass = (int)token;
	if (token != 0) {
		// ÀÌ °ªÀÌ ¹®ÀÚ '1'ÀÌ¸é Åõ¸íÀ¸·Î ¼¼Æ®. '0'ÀÌ¸é ÇØÁ¦ 

		if (token[0]=='0') {
			SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
			SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
			SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
			SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
			SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
			SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
			SetInhibitionCastingFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
			SetHeroFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
		}
		if (token[0]=='1') {
			SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
		}
		if (token[0]=='2') {
			SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
		}
		if (token[0]=='3') {
			SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
		}
		if (token[0]=='4') {
			SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
		}
		if (token[0]=='5') {
			SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
		}
		if (token[0]=='6') {
			SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
		}
		if (token[0]=='7') {
			SetInhibitionCastingFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
		}
		if (token[0]=='8') {
			SetHeroFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
		}
	}
	delete pStrTok;
}

/*********************************************************************************************************************
**  void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show invisibility aura								**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus ) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000010;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFEF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus ) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000010;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFEF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, bool bStatus)								**
**  description			:: changes the status of the player to show inhibit casting aura							**
**  last updated		:: November 20, 2004; 9:33 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus ) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus ) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show berserk aura									**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus ) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000020;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFDF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus ) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000020;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFDF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

void CGame::SetHasteFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_iStatus |= 0x00040000;
		else m_pClientList[sOwnerH]->m_iStatus ^= 0x00040000;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetIceFlag(short sOwnerH, char cOwnerType, bool bStatus)										**
**  description			:: changes the status of the player to show frozen aura										**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIceFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus ) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000040;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFBF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus ) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000040;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFBF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show poison aura										**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, bool bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000080;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFF7F;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000080;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFF7F;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show illusion aura									**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, bool bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x01000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x01000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, bool bStatus)										**
**  description			:: changes the status of the player to show hero item aura									**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, bool bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00020000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFDFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00020000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFDFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, bool bStatus)								**
**  description			:: changes the status of the player to show defense aura									**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, bool bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x02000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFDFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x02000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFDFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, bool bStatus)							**
**  description			:: changes the status of the player to show magic protect aura								**
**  last updated		:: November 20, 2004; 9:38 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, bool bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x04000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFBFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x04000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFBFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, bool bStatus)						**
**  description			:: changes the status of the player to show arrow protect aura								**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, bool bStatus) 
{ 
 	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x08000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xF7FFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x08000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xF7FFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, bool bStatus)							**
**  description			:: changes the status of the player to show illusion movement aura							**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, bool bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == 0) return;
			if (bStatus ) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00200000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFDFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;
	}    
}

// New 07/05/2004
void CGame::RequestGuildNameHandler(int iClientH, int iObjectID, int iIndex)
{
	if (m_pClientList[iClientH] == 0) return;
	if ((iObjectID <= 0) || (iObjectID >= DEF_MAXCLIENTS)) return;

	if (m_pClientList[iObjectID] == 0) {
		// ¿äÃ» ¹ÞÀº Object°¡ ¾ø´Ù.

	}
	else {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, 0, m_pClientList[iObjectID]->m_cGuildName);	
	}
}

// Item Logging
bool CGame::_bItemLog(int iAction,int iGiveH, int iRecvH, class CItem * pItem,bool bForceItemLog)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];
	int iItemCount ;
	if (pItem == 0) return false;

	// !!ÁÖÀÇ ÇÑ±¹¿¡ Àû¿ëÇÒ¶§  New Item ÀÌ »ý±æ¶§´Â  iGive°¡ ³ÎÀÏ¼ö ÀÖ´Ù.
	if (m_pClientList[iGiveH]->m_cCharName == 0) return false;

	if (iAction == DEF_ITEMLOG_DUPITEMID) {
		// º¹»çµÈ ¾ÆÀÌÅÛ ÀúÀå ¿äÃ»ÀÌ´Ù. 
		if (m_pClientList[iGiveH] == 0) return false;
		if (m_pClientList[iGiveH]->m_cCharName == 0) return false;
		wsprintf(G_cTxt, "(!) Delete-DupItem(%s %d %d %d %d) Owner(%s)", pItem->m_cName, pItem->m_dwCount, pItem->m_sTouchEffectValue1,
			pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3,
			m_pClientList[iGiveH]->m_cCharName);
		//	PutItemLogFileList(iGiveH,G_cTxt);
		bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, 0,G_cTxt);
		return true;
	}

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	switch (iAction) {
		
		case DEF_ITEMLOG_EXCHANGE:
			if (m_pClientList[iRecvH]->m_cCharName == 0) return false;
			wsprintf(cTxt, "(%s) PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_GIVE:	
			if (m_pClientList[iRecvH]->m_cCharName == 0) return false;
			wsprintf(cTxt, "(%s) PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_DROP:
			wsprintf(cTxt, "(%s) PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_GET:
			wsprintf(cTxt, "(%s) PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_MAKE:
			wsprintf(cTxt, "(%s) PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_DEPLETE:	
			wsprintf(cTxt, "(%s) PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			PutItemLogFileList(cTxt);		
			break;

		case DEF_ITEMLOG_BUY:
			iItemCount = iRecvH ;
			wsprintf(cTxt, "(%s) PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, iItemCount , 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			PutItemLogFileList(cTxt);		
			break;

		case DEF_ITEMLOG_SELL:
			wsprintf(cTxt, "(%s) PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			PutItemLogFileList(cTxt);		
			break;

		case DEF_ITEMLOG_RETRIEVE:
			wsprintf(cTxt, "(%s) PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			PutItemLogFileList(cTxt);		
			break;

		case DEF_ITEMLOG_DEPOSIT:
			wsprintf(cTxt, "(%s) PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)",m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_UPGRADEFAIL:
			wsprintf(cTxt, "(%s) PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_UPGRADESUCCESS:
			wsprintf(cTxt, "(%s) PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			PutItemLogFileList(cTxt);
			break;
		default:
			return false ;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, 0,cTxt);
	return true;
}

bool CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
{
	if(pItem == 0) return false;
	if(_bCheckGoodItem( pItem ) == false) return false;
	if(iAction != DEF_ITEMLOG_NEWGENDROP)
	{
		if( m_pClientList[iClientH] == 0 ) return false;
	}
	char  cTxt[200], cTemp1[120];
	//  ·Î±× ³²±ä´Ù. 
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	if( m_pClientList[iClientH] != 0 ) m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {
		
	case DEF_ITEMLOG_NEWGENDROP:
		if (pItem == 0) return false;
		wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d)",cName, pItem->m_cName, pItem->m_dwCount,  
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);
		PutItemLogFileList(cTxt);
		break;
	case DEF_ITEMLOG_SKILLLEARN:
	case DEF_ITEMLOG_MAGICLEARN:
		if (cName == 0) return false; 
		if (m_pClientList[iClientH] == 0) return false;
		wsprintf(cTxt, "PC(%s)\tLearn\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		PutItemLogFileList(cTxt);
		break; 
	case DEF_ITEMLOG_SUMMONMONSTER:
		if (cName == 0) return false;
		if (m_pClientList[iClientH] == 0) return false;
		wsprintf(cTxt,"PC(%s)\tSummon\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break ;
	case DEF_ITEMLOG_POISONED:
		if (m_pClientList[iClientH] == 0) return false;
		wsprintf(cTxt,"PC(%s)\tBe Poisoned\t \t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, 
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	case DEF_ITEMLOG_REPAIR:
		if (cName == 0) return false;
		if (m_pClientList[iClientH] == 0) return false;
		wsprintf(cTxt,"PC(%s)\tRepair\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	default:
		return false;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, 0,cTxt);
	return true ;
}

bool CGame::_bCheckGoodItem( class CItem * pItem )
{
	if( pItem == 0 ) return false;

	if( pItem->m_sIDnum == 90 )
	{
		if( pItem->m_dwCount > 10000 ) return true;  //Gold¿¡ ÇÑÇØ 10000¿ø ÀÌ»ó¸¸ ·Î±×¿¡ ³²±ä´Ù.
		else return false;
	}
	switch (pItem->m_sIDnum) {
		//	case 90: // Gold Ãß°¡ 
	case 259:
	case 290:
	case 291:
	case 292:
	case 300:
	case 305:
	case 308:
	case 311:
	case 334:
	case 335:
	case 336:
	case 338:
	case 380:
	case 381:
	case 382:
	case 391:
	case 400:
	case 401:
	case 490:
	case 491:
	case 492:
	case 508:
	case 581:
	case 610:
	case 611:
	case 612:
	case 613:
	case 614:
	case 616:  // µ¥¸ó-½½·¹ÀÌ¾î
	case 618:  // ´ÙÅ©¿¤ÇÁ-º¸¿ì

	case 620:
	case 621:
	case 622:
	case 623:

	case 630:
	case 631:

	case 632:
	case 633:
	case 634:
	case 635:
	case 636:
	case 637:
	case 638:
	case 639:
	case 640:
	case 641:

	case 642:
	case 643:

	case 644:
	case 645:
	case 646:
	case 647:

	case 650:
	case 654:
	case 655:
	case 656:
	case 657:

	case 700: 	// v2.03 »ó¾î ¾ÆÀÌÅÛ 
	case 701:
	case 702:
	case 703:
	case 704:
	case 705:
	case 706:
	case 707:
	case 708:
	case 709:
	case 710:
	case 711:
	case 712:
	case 713:
	case 714:
	case 715:

	case 720:
	case 721:
	case 722:
	case 723:

	case 724:
	case 725:
	case 726:
	case 727:
	case 728:
	case 729:
	case 730:
	case 731:
	case 732:
	case 733:

	case 734:
	case 735:

	case 736:  // »õ·Î¿î »ó¾îÀÇ ÀÚÀÌ¾ðÆ® ¼Òµå
	case 737:  // »õ·Î¿î Èæ±â»çÀÇ ÀÚÀÌ¾ðÆ® ¼Òµå
	case 738:  // »õ·Î¿î Èæ¸¶¹ý»çÀÇ¸ÅÁ÷¿øµå
	case 924:

		return true;  //Æ¯º°ÇÑ ¾ÆÀÌÅÛÀÌ±â ¶«½Ã ±â·Ï...
		break;
	default:
		// v2.17 2002-7-31 Á¦ÀÛ ¾ÆÀÌÅÛµµ ·Î±×¿¡ ³²°Ô ÇÑ´Ù.
		if ((pItem->m_dwAttribute & 0xF0F0F001) == 0) return false;  //Æ¯º°ÇÑ ¾ÆÀÌÅÛµÎ ¾Æ´Ï±¸ Æ¯¼ºÄ¡µµ ¾ø´Ù¸é º°·ç..
		else if( pItem->m_sIDnum > 30 ) return true;  //Æ¯º°ÇÑ ¾ÆÀÌÅÛÀº ¾Æ´ÏÁö¸¸ Æ¯¼ºÄ¡°¡ ÀÖ°í ´Ü°Ë·ù°¡ ¾Æ´Ï¶ó¸é ÁÁÀº ¾ÆÅÛ..
		else return false;  //Æ¯º°ÇÑ ¾ÆÀÌÅÛµÎ ¾Æ´Ï±¸ Æ¯¼ºÄ¡´Â ÀÖÁö¸¸ ´Ü°Ë·ù¶ó¸é º°·ç...
	}
}

void CGame::GetExp(int iClientH, DWORD iExp, bool bIsAttackerOwn)
{
double dV1, dV2, dV3;
int i, iH;
DWORD dwTime = timeGetTime(), iUnitValue;
int iTotalPartyMembers;

	if (m_pClientList[iClientH] == 0) return;
	if (iExp <= 0) return;

	if (m_pClientList[iClientH]->m_iLevel <= 80) {
		dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
		dV2 = dV1 * 0.025f;
		dV3 = (double)iExp;
		dV1 = (dV2 + 1.025f)*dV3;
		iExp = (DWORD)dV1;
	}
	else { //Lower exp
		if ((m_pClientList[iClientH]->m_iLevel >= 80) &&((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresdend1") == 0) || (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvined1") == 0))) {
			iExp = (iExp/10);
		 }
		else if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresdend1") == 0) || (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvined1") == 0)) {
			iExp = (iExp*1/4);
		}
	}

	//Check for party status, else give exp to player
	if ((m_pClientList[iClientH]->m_iPartyID != 0) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
		//Only divide exp if >= 1 person 
		if(m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers > 0){

			//Calc total ppl in party
			iTotalPartyMembers = 0;
			for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++){
				iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
				if ((m_pClientList[iH] != 0) && (m_pClientList[iH]->m_iHP > 0)) {
					//Newly added, Only players on same map get exp :}
					if ((strlen(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName)) == (strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName))) {
						if(memcmp(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) == 0){
							iTotalPartyMembers++;
						}
					}
				}
			}

			//Check for party bug
			if(iTotalPartyMembers > DEF_MAXPARTYMEMBERS){
				wsprintf(G_cTxt, "(X) Party Bug !! partyMember %d XXXXXXXXXX", iTotalPartyMembers);
				PutLogFileList(G_cTxt);
				iTotalPartyMembers = DEF_MAXPARTYMEMBERS;
			}

			//Figure out how much exp a player gets
			dV1 = (double)iExp;
			dV2 = dV1;

			if (iTotalPartyMembers > 1)
			{
				dV2 = (dV1 + (dV1 * (double)(iTotalPartyMembers / DEF_MAXPARTYMEMBERS))) / (double)iTotalPartyMembers;
			}

			dV3 = dV2 + 5.0e-1;
			iUnitValue = (DWORD)dV3;
 
			//Divide exp among party members
			for(i = 0; i < iTotalPartyMembers; i++){

				iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
				if ((m_pClientList[iH] != 0) && (m_pClientList[iH]->m_bSkillUsingStatus[19] != 1) && (m_pClientList[iH]->m_iHP > 0)) { // Is player alive ??
					if((m_pClientList[iH]->m_iStatus & 0x10000) != 0)  iUnitValue *= 3;
					m_pClientList[iH]->m_iExpStock += iUnitValue;  
				}
			}
		}
	}
	else {
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_bSkillUsingStatus[19] != 1) && (m_pClientList[iClientH]->m_iHP > 0)) { // Is player alive ??
			if((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0)  iExp *= 3;
			m_pClientList[iClientH]->m_iExpStock += iExp;
		}
	}
}

bool CGame::bCheckAndConvertPlusWeaponItem(int iClientH, int iItemIndex)
{
	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return false;

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
	case 4:  // Dagger +1
	case 9:  // Short Sword +1
	case 13: // Main Gauge +1
	case 16: // Gradius +1
	case 18: // Long Sword +1
	case 19: // Long Sword +2
	case 21: // Excaliber +1
	case 24: // Sabre +1
	case 26: // Scimitar +1
	case 27: // Scimitar +2
	case 29: // Falchoin +1
	case 30: // Falchion +2
	case 32: // Esterk +1
	case 33: // Esterk +2
	case 35: // Rapier +1
	case 36: // Rapier +2
	case 39: // Broad Sword +1
	case 40: // Broad Sword +2
	case 43: // Bastad Sword +1
	case 44: // Bastad Sword +2
	case 47: // Claymore +1
	case 48: // Claymore +2
	case 51: // Great Sword +1
	case 52: // Great Sword +2
	case 55: // Flameberge +1
	case 56: // Flameberge +2
	case 60: // Light Axe +1
	case 61: // Light Axe +2
	case 63: // Tomahoc +1
	case 64: // Tomohoc +2
	case 66: // Sexon Axe +1
	case 67: // Sexon Axe +2
	case 69: // Double Axe +1
	case 70: // Double Axe +2
	case 72: // War Axe +1
	case 73: // War Axe +2

	case 580: // Battle Axe +1
	case 581: // Battle Axe +2
	case 582: // Sabre +2
		return true;
		break;
	}
	return false;
}

void CGame::ArmorLifeDecrement(int iAttackerH, int iTargetH, char cOwnerType, int iValue)
{
	int iTemp;

	if (m_pClientList[iAttackerH] == 0) return ;
	// v1.3 ÇÇ°Ý´çÇßÀ¸¹Ç·Î ÀåÂøÇÏ°í ÀÖ´Â ¸öÅë ¹æ¾î±¸ÀÇ ¼ö¸íÀ» ÁÙÀÎ´Ù. 
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == 0) return;
		break;

	case DEF_OWNERTYPE_NPC:	return;
	default: return;
	}

	// v2.16 °°Àº ÆíÀÌ¸é ¼ö¸í ´ÞÁö ¾Ê°Ô 
	if (m_pClientList[iAttackerH]->m_cSide == m_pClientList[iTargetH]->m_cSide) return ;

	// ¸öÅë °©¿Ê 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {
		// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸í ÁÙÁö ¾Ê´Â´Ù.
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
			// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
			ReleaseItemHandler(iTargetH, iTemp, true);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
		}
	}

	// ¹ÙÁö È¤Àº ½Å¹ß·ù ¹æ¾î±¸
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
			// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
			ReleaseItemHandler(iTargetH, iTemp, true);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
			// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
			ReleaseItemHandler(iTargetH, iTemp, true);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
		}
	}

	// ÆÈ°©¿Ê 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
			// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
			ReleaseItemHandler(iTargetH, iTemp, true);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
		}
	}

	// Åõ±¸ 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
			// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
			ReleaseItemHandler(iTargetH, iTemp, true);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
		}
	}
}

void CGame::AdminOrder_GoTo(int iClientH, char* pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cPlayerName[11],cMapName[32];
	class  CStrTok * pStrTok;
	char *cp;
	WORD *wp;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGoto) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token == 0) {
		delete pStrTok;
		return;
	}

	if (strlen(token) > 10) {
		memcpy(cPlayerName,token,10);
	}
	else{
		memcpy(cPlayerName,token,strlen(token));
	}

	for(int i = 1; i < DEF_MAXCLIENTS; i++){
		if (m_pClientList[i] != 0) {
			if (memcmp(cPlayerName,m_pClientList[i]->m_cCharName, 10) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
					if(m_pClientList[i]->m_sX == -1 && m_pClientList[i]->m_sX == -1){
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)",m_pClientList[iClientH]->m_cCharName,m_pClientList[i]->m_cMapName);
					}
					else{
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)(%d %d)",m_pClientList[iClientH]->m_cCharName,
							     m_pClientList[i]->m_cMapName,m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
					}
					bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH,false,cBuff);
					ZeroMemory(cMapName,sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					RequestTeleportHandler(iClientH,"2   ", cMapName, m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
				}
				delete pStrTok;
				return;
			}
		}
	}
	m_pClientList[iClientH]->m_bIsAdminOrderGoto = true;

	/*ZeroMemory(cBuff,sizeof(cBuff));
	
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp,cPlayerName,10);
	cp += 10;

	memcpy(cp,m_pClientList[iClientH]->m_cCharName,10);
	cp += 10;

	bStockMsgToGateServer(cBuff,25);*/

	delete pStrTok;
}

void CGame::AdminOrder_MonsterCount(int iClientH, char* pData, DWORD dwMsgSize)
{
	int iMonsterCount;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelMonsterCount) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}
	iMonsterCount = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAliveObject;
	SendNotifyMsg(0,iClientH, DEF_NOTIFY_MONSTERCOUNT, iMonsterCount,0,0,0);
}

// v2.17 2002-7-15  ɾ ݽð Ѵ.
void CGame::AdminOrder_SetForceRecallTime(int iClientH, char *pData, DWORD dwMsgSize)
{
 class  CStrTok * pStrTok;
 char   seps[] = "= \t\n";
 char   * token, cBuff[256],* cp; 
 WORD * wp ;
 int    iTime;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetRecallTime) {
		// Admin user level Ƽ     .
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != 0) {

		if (token == 0) 
			 iTime = 0;
		else iTime = atoi(token);
	
		if (iTime < 0) iTime = 0;
	 	
		m_sForceRecallTime = iTime ;

		/*ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SETFORCERECALLTIME;
		cp++;
	
		wp = (WORD *)cp;
		*wp = iTime ;
		cp += 2;

		bStockMsgToGateServer(cBuff, 3);*/

		wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
		PutLogList(G_cTxt) ;
	}

	delete pStrTok;
	return ;
}

void CGame::AdminOrder_UnsummonBoss(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelUnsummonBoss) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	for(int i = 1; i < DEF_MAXNPCS; i++){
		if (m_pNpcList[i] != 0 && m_pNpcList[i]->m_bIsSummoned == false) {
			switch(m_pNpcList[i]->m_sType) {
			case 31: //Demon
			case 49: //Hellclaw
			case 45: //GHKABS
			case 47: //BG
			case 50: //Tigerworm
			case 52: //Gagoyle
			case 81: //Abaddon
			case 66: //Wyvern
			case 73: //Fire-Wyvern
				m_pNpcList[i]->m_bIsUnsummoned = true;
				NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
				break;
			}
		}
	}
}

void CGame::AdminOrder_ClearNpc(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelClearNpc) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	for(int i = 1; i < DEF_MAXNPCS; i++){
		if (m_pNpcList[i] != 0 && m_pNpcList[i]->m_bIsSummoned == false) {
			switch(m_pNpcList[i]->m_sType) {
			case 15:
			case 19:
			case 20:
			case 24:
			case 25:
			case 26:
			case 67:
			case 68:
			case 69:
			case 90:
			case 91:
			break;

			default:
				m_pNpcList[i]->m_bIsUnsummoned = true;
				NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
				break;
			}
		}
	}
}

// New 12/05/2004
void CGame::RemoveCrusadeNpcs(void)
{
	for(int i = 0; i < DEF_MAXNPCS; i++){
		if (m_pNpcList[i] != 0) {
			if ((m_pNpcList[i]->m_sType >= 43 && m_pNpcList[i]->m_sType <= 47) || m_pNpcList[i]->m_sType == 51) {
				NpcKilledHandler(0, 0, i, 0);
			}
		}
	}
}

void CGame::RemoveCrusadeRecallTime(void)
{
	for(int i = 1; i < DEF_MAXCLIENTS; i++){
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsWarLocation  &&
				m_pClientList[i]->m_bIsPlayerCivil  &&
				m_pClientList[i]->m_bIsInitComplete ) {
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
			}
		}
	}
}

// New 13/05/2004
bool CGame::_bCrusadeLog(int iAction,int iClientH,int iData, char * cName)
{
	char  cTxt[200];

	//  ·Î±× ³²±ä´Ù. 
	ZeroMemory(cTxt, sizeof(cTxt));

	switch (iAction) {

		case DEF_CRUSADELOG_ENDCRUSADE:
			if (cName == 0) return false;
			wsprintf(cTxt,"\tEnd Crusade\t%s",cName);
			break;

		case DEF_CRUSADELOG_SELECTDUTY :
			if (cName == 0) return false;
			if (m_pClientList[iClientH] == 0) return false;
			wsprintf(cTxt, "PC(%s)\tSelect Duty\t(%s)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,cName,m_pClientList[iClientH]->m_cGuildName);
			break ;

		case DEF_CRUSADELOG_GETEXP :
			if (m_pClientList[iClientH] == 0) return false;
			wsprintf(cTxt, "PC(%s)\tGet Exp\t(%d)\t \t(%s)", m_pClientList[iClientH]->m_cCharName, iData, m_pClientList[iClientH]->m_cGuildName);
			break ;

		case DEF_CRUSADELOG_STARTCRUSADE:
			wsprintf(cTxt,"\tStart Crusade");
			break ;

		default:
			return false;
	}

	bSendMsgToLS(MSGID_GAMECRUSADELOG, iClientH, 0,cTxt);
	return true ;
}

// Testcode, found reference to it in 3.51, InitPlayerData and RequestTeleportHandler
int CGame::iGetPlayerABSStatus(int iClientH)
{
	int iRet;

	if (m_pClientList[iClientH] == 0) return 0;

	iRet = 0;

		if (m_pClientList[iClientH]->m_iPKCount != 0) {
			iRet = 8;
		}

		if (m_pClientList[iClientH]->m_cSide != 0) {
			iRet = iRet | 4;
		}

		if (m_pClientList[iClientH]->m_cSide == 1) {
			iRet = iRet | 2;
		}

		if (m_pClientList[iClientH]->m_bIsPlayerCivil )
			iRet = iRet | 1;

		return iRet;
}

//Init item based in its ID
bool CGame::_bInitItemAttr(class CItem * pItem, int iItemID)
{
int i;

for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != 0) {
		if (m_pItemConfigList[i]->m_sIDnum == iItemID) {
			// °°Àº ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛ ¼³Á¤À» Ã£¾Ò´Ù. ¼³Á¤°ªÀ» º¹»çÇÑ´Ù.
			ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;

			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;

			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;

			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;

			return true;
		}
	}
	return false;
}

// New 16/05/2004
void CGame::ReqCreateSlateHandler(int iClientH, char* pData)
{
	int i, iRet;
	short *sp;
	char cItemID[4], ctr[4];
	char *cp, cSlateColour, cData[120];
	bool bIsSlatePresent = false;
	CItem * pItem;
	int iSlateType, iEraseReq;
	DWORD *dwp;
	WORD *wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange ) return;

	for(i = 0; i < 4; i++){
		cItemID[i] = 0;
		ctr[i] = 0;
	}

	cp = (char *)pData;
	cp += 11;

	// 14% chance of creating slates
	if (iDice(1,100) < m_sSlateSuccessRate) bIsSlatePresent = true;

    try{
	// make sure slates really exist
	for(i = 0; i < 4; i++){
		cItemID[i] = *cp;
		cp++;

		if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] == 0 || cItemID[i] >DEF_MAXITEMS){ 
			bIsSlatePresent = false;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, 0, 0, 0, 0);  			
			return; 
		}

		//No duping
		if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 868) // LU
			ctr[0] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 869) // LD
			ctr[1] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 870) // RU
			ctr[2] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 871) // RD
			ctr[3] = 1;
	}
     }
     catch(...){
	//Crash Hacker Caught
	bIsSlatePresent = false;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, 0, 0, 0, 0);  
	wsprintf(G_cTxt, "TSearch Slate Hack: (%s) Player: (%s) - creating slates without correct item!", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
	PutHackLogFileList(G_cTxt);
	DeleteClient(iClientH, true, true);
	return;
     }

	// Are all 4 slates present ??
	if (ctr[0] != 1 || ctr[1] != 1 || ctr[2] != 1 || ctr[3] != 1) {
		bIsSlatePresent = false;
		return; 
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) bIsSlatePresent = true;

	// if we failed, kill everything
	if (!bIsSlatePresent) { 
		for(i = 0; i < 4; i++){ 
			if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != 0) {
				ItemDepleteHandler(iClientH,cItemID[i], false);
			}
		} 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, 0, 0, 0, 0); 
		return; 
	}

	// make the slates
	for(i = 0; i < 4; i++){
		if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != 0) {
			ItemDepleteHandler(iClientH,cItemID[i], false);
		}
	}

	pItem = new class CItem;

	i = iDice(1,1000);

	if (i < 50) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}
	else if (i < 250) { // Bezerk slate
		iSlateType = 2;
		cSlateColour = 3;
	}
	else if (i < 750) { // Exp slate
		iSlateType = 4;
		cSlateColour = 7;
	}
	else if (i < 950) { // Mana slate
		iSlateType = 3;
		cSlateColour = 37;
	}
	else if (i <  1001) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}

	// Notify client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATESUCCESS, iSlateType, 0, 0, 0);

	ZeroMemory(cData,sizeof(cData));

	// Create slates
	if (_bInitItemAttr(pItem, 867) == false) {
		delete pItem;
		return;
	}
	else{
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		pItem->m_sTouchEffectValue3 = (short)timeGetTime();

		_bItemLog(DEF_ITEMLOG_GET, iClientH, -1, pItem);

		pItem->m_sItemSpecEffectValue2 = iSlateType;
		pItem->m_cItemColor = cSlateColour;
		if(_bAddClientItemList(iClientH, pItem, &iEraseReq) ){
			ZeroMemory(cData,sizeof(cData));
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0; //  ̹Ƿ  ʾҴ.
			cp++;

			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

			*cp = (char)pItem->m_sItemSpecEffectValue2;
			cp ++;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			if (iEraseReq == 1) delete pItem;

			//    
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ޽   ߻ߴٸ Ѵ.
					DeleteClient(iClientH, true, true);
					return;
			}
		}
		else{
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_MAGICCONFIGURATIONCONTENTS, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
										m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute);
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ޽   ߻ߴٸ Ѵ.
						DeleteClient(iClientH, true, true);
						break;
			}
		}
	}
	return;
}

void CGame::SetSlateFlag(int iClientH, short sType, bool bFlag)
{
	if (m_pClientList[iClientH] == 0) return;

	if (sType == DEF_NOTIFY_SLATECLEAR) {
		m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
		return;
	}

	if (bFlag ) {
		if (sType == 1) { // Invincible slate
			m_pClientList[iClientH]->m_iStatus |= 0x400000;
		}
		else if (sType == 3) { // Mana slate
			m_pClientList[iClientH]->m_iStatus |= 0x800000;
		}
		else if (sType == 4) { // Exp slate
			m_pClientList[iClientH]->m_iStatus |= 0x10000;
		}
	}
	else{
		if ((m_pClientList[iClientH]->m_iStatus & 0x400000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
		}
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}

// New 18/05/2004
void CGame::SetPlayingStatus(int iClientH)
{
	char cMapName[11], cLocation[11];

	if (m_pClientList[iClientH] == 0) return;

	ZeroMemory(cMapName, sizeof(cMapName));
	ZeroMemory(cLocation, sizeof(cLocation));

	strcpy(cLocation, m_pClientList[iClientH]->m_cLocation);
	strcpy(cMapName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex]->m_cName);

	m_pClientList[iClientH]->m_cSide = 0;
	m_pClientList[iClientH]->m_bIsOwnLocation = false;
	m_pClientList[iClientH]->m_bIsPlayerCivil = false;

	if (memcmp(cLocation, cMapName, 3) == 0) {
		m_pClientList[iClientH]->m_bIsOwnLocation = true;
	}

	if (memcmp(cLocation, "are", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 1;
	else if (memcmp(cLocation, "elv", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 2;
	else{ 
		if (strcmp(cMapName, "elvine") == 0 || strcmp(cMapName, "aresden") == 0) {
			m_pClientList[iClientH]->m_bIsOwnLocation = true;
		}
		m_pClientList[iClientH]->m_bIsNeutral = true;
	}

	if (memcmp(cLocation, "arehunter", 9) == 0 || memcmp(cLocation, "elvhunter", 9) == 0) {
		m_pClientList[iClientH]->m_bIsPlayerCivil = true;
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) == 0) {
		m_pClientList[iClientH]->m_bIsPlayerCivil = false;
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith", 6) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall", 7) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gshop", 5) == 0)
		m_pClientList[iClientH]->m_pIsProcessingAllowed = true;
	else
		m_pClientList[iClientH]->m_pIsProcessingAllowed = false;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus", 5) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus", 8) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus", 8) == 0)
		m_pClientList[iClientH]->m_bIsInsideWarehouse = true;
	else
		m_pClientList[iClientH]->m_bIsInsideWarehouse = false;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr", 6) == 0)
		m_pClientList[iClientH]->m_bIsInsideWizardTower = true;
	else
		m_pClientList[iClientH]->m_bIsInsideWizardTower = false;
}

void CGame::ForceChangePlayMode(int iClientH, bool bNotify)
{
	if(m_pClientList[iClientH] == 0) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "aresden");
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "elvine");

	if (m_pClientList[iClientH]->m_bIsPlayerCivil )
		m_pClientList[iClientH]->m_bIsPlayerCivil = false;

	if (bNotify) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CHANGEPLAYMODE, 0, 0, 0, m_pClientList[iClientH]->m_cLocation);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
	}
}

void CGame::ShowVersion(int iClientH)
{
	char cVerMessage[256];

	ZeroMemory(cVerMessage, sizeof(cVerMessage));
	wsprintf(cVerMessage, "Helbreath Sources %s.%s - www.xtremehb.com", DEF_UPPERVERSION, DEF_LOWERVERSION);
	ShowClientMsg(iClientH, cVerMessage);

}

// v2.15 2002-5-21
void CGame::GSM_RequestShutupPlayer(char * pGMName,WORD wReqServerID, WORD wReqClientH, WORD wTime,char * pPlayer )
{
	//char * cp, cTemp[120];
	//WORD * wp;
	//int i;

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	//	if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, pPlayer) == 0)) {
	//		// Ã£¾Ò´Ù.
	//		ZeroMemory(cTemp, sizeof(cTemp));
	//		cp = (char *)(cTemp);
	//		*cp = GSM_RESPONSE_SHUTUPPLAYER;
	//		cp++;

	//		wp = (WORD *)cp;
	//		*wp = wReqServerID;
	//		cp += 2;

	//		wp = (WORD *)cp;
	//		*wp = wReqClientH;
	//		cp += 2;

	//		memcpy(cp, pGMName, 10);
	//		cp += 10;

	//		wp = (WORD *)cp;
	//		*wp = (WORD) wTime;
	//		cp += 2;

	//		memcpy(cp, pPlayer, 10);
	//		cp += 10;

	//		// v2.14 ¼Ë¾÷½Ã°£À» ºÐÀ¸·Î ¼öÁ¤
	//		m_pClientList[i]->m_iTimeLeft_ShutUp = wTime*20; // 1ÀÌ 3ÃÊ´Ù. 20ÀÌ¸é 1ºÐ 

	//		SendNotifyMsg(0, i, DEF_NOTIFY_PLAYERSHUTUP, wTime, 0, 0, pPlayer);

	//		bStockMsgToGateServer(cTemp, 27);
	//		return;	
	//	}
}

// v2.14 05/22/2004 - Hypnotoad - adds pk log
bool CGame::_bPKLog(int iAction,int iAttackerH , int iVictumH, char * pNPC)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];

	//  ·Î±× ³²±ä´Ù. 
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	if ( m_pClientList[iVictumH] == 0) return false ;

	switch (iAction) {

		case DEF_PKLOG_REDUCECRIMINAL: 
			wsprintf(cTxt, "(%s) PC(%s)\tReduce\tCC(%d)\t%s(%d %d)\t", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_iPKCount,
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 

		case DEF_PKLOG_BYPLAYER:
			if ( m_pClientList[iAttackerH] == 0) return false ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by PC\t \t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
			break;
		case DEF_PKLOG_BYPK:
			if ( m_pClientList[iAttackerH] == 0) return false ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by PK\tCC(%d)\t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, m_pClientList[iAttackerH]->m_iPKCount,
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case DEF_PKLOG_BYENERMY:
			if ( m_pClientList[iAttackerH] == 0) return false ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by Enemy\t \t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case DEF_PKLOG_BYNPC:
			if(pNPC==0) return false ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by NPC\t \t%s(%d %d)\tNPC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,pNPC);
			break; 
		case DEF_PKLOG_BYOTHER:
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by Other\t \t%s(%d %d)\tUnknown", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 
		default:
			return false;
	}
	PutPvPLogFileList(cTxt);
	return true ;
}

void CGame::RequestResurrectPlayer(int iClientH, bool bResurrect)
{
short sX, sY;
char buff[100];

	if (m_pClientList[iClientH] == 0) return;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	if (bResurrect == false) {
		m_pClientList[iClientH]->m_bIsBeingResurrected = false;
		return;
	}

	if (m_pClientList[iClientH]->m_bIsBeingResurrected == false) {
		try
		{
			wsprintf(buff, "(!!!) Player(%s) Tried To Use Resurrection Hack", m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true, true, true);
		}
		catch(...)
		{
		}
		return;
	}

	wsprintf(buff, "(*) Resurrect Player! %s", m_pClientList[iClientH]->m_cCharName);
	PutLogList(buff);


	m_pClientList[iClientH]->m_bIsKilled = false;
	// Player's HP becomes half of the Max HP. 
	m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH)/2; 
	// Player's MP
	m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	// Player's SP
	m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);
	// Player's Hunger
	m_pClientList[iClientH]->m_iHungerStatus = 100;

	m_pClientList[iClientH]->m_bIsBeingResurrected = false;

	// !!! RequestTeleportHandler³»¿¡¼­ m_cMapNameÀ» ¾²±â ¶§¹®¿¡ ±×´ë·Î ÆÄ¶ó¹ÌÅÍ·Î ³Ñ°ÜÁÖ¸é ¿Àµ¿ÀÛ
	RequestTeleportHandler(iClientH, "2   ", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
}

bool CGame::bCheckClientAttackFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;

	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return false;

	if (m_pClientList[iClientH]->m_dwAttackFreqTime == 0) 
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwAttackFreqTime;
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;

		if (dwTimeGap < 450) {
			try
			{
				wsprintf(G_cTxt, "Swing Hack: (%s) Player: (%s) - attacking with weapon at irregular rates.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true);
			}
			catch(...)
			{
			}

			return false;
		}

		//testcode
		//wsprintf(G_cTxt, "Attack: %d", dwTimeGap);
		//PutLogList(G_cTxt);
	}

	return false;
}

bool CGame::bCheckClientMagicFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;
	
	if (m_pClientList[iClientH] == 0) return false;

	if (m_pClientList[iClientH]->m_dwMagicFreqTime == 0) 
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMagicFreqTime;
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;

		if ((dwTimeGap < 1500) && (m_pClientList[iClientH]->m_bMagicConfirm )) {
			try
			{
				wsprintf(G_cTxt, "Speed Cast: (%s) Player: (%s) - casting magic at irregular rates. ", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true);
			}
			catch(...)
			{
			}
			return false;
		}
		
		m_pClientList[iClientH]->m_iSpellCount--;
		m_pClientList[iClientH]->m_bMagicConfirm = false;
		m_pClientList[iClientH]->m_bMagicPauseTime = false;
		
		//testcode
		//wsprintf(G_cTxt, "Magic: %d", dwTimeGap);
		//PutLogList(G_cTxt);
	}

	return false;
}

bool CGame::bCheckClientMoveFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;
	
	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return false;

	if (m_pClientList[iClientH]->m_dwMoveFreqTime == 0) 
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
	else {
		if (m_pClientList[iClientH]->m_bIsMoveBlocked ) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = 0;
			m_pClientList[iClientH]->m_bIsMoveBlocked = false;
			return false;
		}

		if (m_pClientList[iClientH]->m_bIsAttackModeChange ) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = 0;
			m_pClientList[iClientH]->m_bIsAttackModeChange = false;
			return false;
		}

		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMoveFreqTime;
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
		
		if ((dwTimeGap < 200) && (dwTimeGap >= 0)) {
			try
			{
				wsprintf(G_cTxt, "Speed Hack: (%s) Player: (%s) - running too fast.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true);
			}
			catch(...)
			{
			}
			return false;
		}

		// testcode
		// wsprintf(G_cTxt, "Move: %d", dwTimeGap);
		// PutLogList(G_cTxt);
	}

	return false;
}

void CGame::CrusadeWarStarter()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bIsCrusadeMode ) return;
	if (m_bIsCrusadeWarStarter == false) return;

	//   1 
	GetLocalTime(&SysTime);
	
	for (i = 0; i < DEF_MAXSCHEDULE; i++)
	if	((m_stCrusadeWarSchedule[i].iDay == SysTime.wDayOfWeek) && 
		(m_stCrusadeWarSchedule[i].iHour == SysTime.wHour) && 
		(m_stCrusadeWarSchedule[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated crusade is being initiated!");
			GlobalStartCrusadeMode();
			return;
	}
}

void CGame::OnTimer(char cType)
{
DWORD dwTime;

dwTime = timeGetTime();

//if ((dwTime - m_dwGameTime1) > 200) {
GameProcess();
// m_dwGameTime1 = dwTime;
//}


if ((dwTime - m_dwGameTime2) > 1000) {
 CheckClientResponseTime();
 //SendMsgToGateServer(MSGID_GAMESERVERALIVE, 0);
 CheckDayOrNightMode();
 // ȭ  
 InvalidateRect(G_hWnd, 0, true);
 m_dwGameTime2 = dwTime;
 // v1.41 
 //_CheckGateSockConnection();
 
 // v1.41
 if (m_bIsGameStarted == false) {
  //   غ Ǿ. ޽ .
  PutLogList("Sending start message...");
  SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, 0, 0);
  m_bIsGameStarted = true;
 }
}
	if ((dwTime - m_dwGameTime6) > 1000) {
		DelayEventProcessor();
		//SendStockMsgToGateServer();
		m_dwGameTime6 = dwTime;

		// v2.05
		if (m_iFinalShutdownCount != 0) {
			m_iFinalShutdownCount--;
			wsprintf(G_cTxt, "Final Shutdown...%d", m_iFinalShutdownCount);
			PutLogList(G_cTxt);
			if (m_iFinalShutdownCount <= 1) {
				// 2.14 Ĵ ˴ٿ  α  
				SendMessage(m_hWnd, WM_CLOSE, 0, 0);
				return;
				
			}
		}
	}

	if ((dwTime - m_dwGameTime3) > 1000) {
		SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		NoticeHandler();
		SpecialEventHandler();
		EnergySphereProcessor();
		m_dwGameTime3 = dwTime;
	}

	if ((dwTime - m_dwGameTime4) > 600) {
	 MobGenerator();

	 // v1.432-3 Sub-Log-Socket Ѳ   ƴ϶  .
	 /*if (m_iSubLogSockInitIndex < DEF_MAXSUBLOGSOCK) {
	  m_pSubLogSock[m_iSubLogSockInitIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	  m_pSubLogSock[m_iSubLogSockInitIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iSubLogSockInitIndex + 1));
	  m_pSubLogSock[m_iSubLogSockInitIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);
	  wsprintf(G_cTxt, "(!) Try to connect sub-log-socket(%d)... Addr:%s  Port:%d", m_iSubLogSockInitIndex, m_cLogServerAddr, m_iLogServerPort);
	  PutLogList(G_cTxt);
	  m_iSubLogSockInitIndex++;
	 }*/

	 m_dwGameTime4 = dwTime;
	}



	if ((dwTime - m_dwGameTime5) > 1000*60*3) {
		
		m_dwGameTime5 = dwTime;

		// v1.41  õ尪 ʱȭ.
		srand( (unsigned)time( 0 ) );   
	}

	if ((dwTime - m_dwFishTime) > 5000) {
		FishProcessor();
		FishGenerator();
		SendCollectedMana();
		CrusadeWarStarter();
		//ApocalypseStarter();
		ApocalypseEnder();
		m_dwFishTime = dwTime;
	}
	
	if ((dwTime - m_dwWhetherTime) > 1000*20) {
		WhetherProcessor();
		m_dwWhetherTime = dwTime;
	}
	
	if ((m_bHeldenianRunning ) && (m_bIsHeldenianMode )) {
		SetHeldenianMode();
	}
	// v1.4311-3 ߰  νð   ʱȭϰ    ˷ش. 1000*60*60*2 = 7200000
	if ((dwTime - m_dwCanFightzoneReserveTime) > 7200000) {
		FightzoneReserveProcessor();
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((m_bIsServerShutdowned == false) && (m_bOnExitProcess ) && ((dwTime - m_dwExitProcessTime) > 1000*2)) {
		if (_iForcePlayerDisconect(15) == 0) {
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = true;

			// v1.41    ڵ ˴ٿ  ̶ ٽ  ⵿Ų. 
			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) {
				PutLogFileList("(!!!) AUTO-SERVER-REBOOTING!");
				bInit();
				m_iAutoRebootingCount++;
			}
			else {
				// v1.432  ˴ٿ    īƮ ٿ .  ޵  ޽ ϱ  ð δ° . v2.05
				if (m_iFinalShutdownCount == 0)	m_iFinalShutdownCount = 20;
			}
		}
		m_dwExitProcessTime = dwTime;
	}

	// v1.432-2 10ʸ   м 
	if ((dwTime - m_dwMapSectorInfoTime) > 1000*10) {
		m_dwMapSectorInfoTime = dwTime;
		UpdateMapSectorInfo();

		// v2.03   󵵼  
		MineralGenerator();

		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) {
			// ð   Ȱ  īƮ ҽŴ.
			AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
	}
}

bool CGame::bReadScheduleConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == 0) {
		// Ӽ ʱȭ    .
		PutLogList("(!) Cannot open Schedule file.");
		return false;
	}
	else {
		PutLogList("(!) Reading Schedule file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != 0 )   {
			
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule crusade total war.");
						m_bIsCrusadeWarStarter = true;
					}
					cReadModeA = 0;
					break;

				case 2:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule apocalypse.");
						m_bIsApocalypseStarter = true;
					}
					cReadModeA = 0;
					break;

				case 3:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXSCHEDULE) {
							PutLogList("(!) WARNING! Too many crusade war schedule!"); 
							return true;
						}
						m_stCrusadeWarSchedule[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stCrusadeWarSchedule[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stCrusadeWarSchedule[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 4:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXAPOCALYPSE) {
							PutLogList("(!) WARNING! Too many Apocalypse schedule!"); 
							return true;
						}
						m_stApocalypseScheduleStart[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stApocalypseScheduleStart[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stApocalypseScheduleStart[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 5:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXAPOCALYPSE) {
							PutLogList("(!) WARNING! Too many Apocalypse schedule!"); 
							return true;
						}
						m_stApocalypseScheduleEnd[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stApocalypseScheduleEnd[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stApocalypseScheduleEnd[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 6:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXHELDENIAN) {
							PutLogList("(!) WARNING! Too many Heldenians scheduled!"); 
							return true;
						}
						m_stHeldenianSchedule[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stHeldenianSchedule[iIndex].StartiHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stHeldenianSchedule[iIndex].StartiMinute = atoi(token);
						cReadModeB = 4;
						break;
					case 4:
						m_stHeldenianSchedule[iIndex].EndiHour = atoi(token);
						cReadModeB = 5;
						break;
					case 5:
						m_stHeldenianSchedule[iIndex].EndiMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;

					}
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-server-name", 19) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-server-name", 22) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
				if (memcmp(token, "crusade-schedule", 16) == 0) {
					cReadModeA = 3;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-schedule-start", 25) == 0) {
					cReadModeA = 4;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-schedule-end", 23) == 0) {
					cReadModeA = 5;
					cReadModeB = 1;
				}
				if (memcmp(token, "Heldenian-schedule", 18) == 0) {
					cReadModeA = 6;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}


void CGame::GlobalStartCrusadeMode()
{
 char * cp, cData[120];
 DWORD * dwp, dwCrusadeGUID;
 SYSTEMTIME SysTime;

	//   Ϸ翡 ι  ߻ϴ   ڵ 
	GetLocalTime(&SysTime);
	if (m_iLatestCrusadeDayOfWeek != -1) {
		if (m_iLatestCrusadeDayOfWeek == SysTime.wDayOfWeek) return;
	}
	else m_iLatestCrusadeDayOfWeek = SysTime.wDayOfWeek;

	dwCrusadeGUID = timeGetTime();

	/*ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINCRUSADE;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = dwCrusadeGUID;
	cp += 4;

	bStockMsgToGateServer(cData, 5);*/

	LocalStartCrusadeMode(dwCrusadeGUID);
}

void CGame::OnStartGameSignal()
{
 int i;
	
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != 0) 
		_bReadMapInfoFiles(i);
	
	bReadCrusadeStructureConfigFile("GameConfigs\\Crusade.cfg");
	_LinkStrikePointMapIndex();
	bReadScheduleConfigFile("GameConfigs\\Schedule.cfg");

	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");
	bReadApocalypseGUIDFile("GameData\\ApocalypseGUID.txt");
	bReadHeldenianGUIDFile("GameData\\HeldenianGUID.txt");
	
	PutLogList("");
	PutLogList("(!) Game Server Activated.");

}

void CGame::RequestGuildTeleportHandler(int iClientH)
{
 int i;
 char cMapName[11];
	
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, 0, 0, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}

	// if a guild teleport is set when its not a crusade, log the hacker
	if (!m_bIsCrusadeMode) {
		try
		{
			wsprintf(G_cTxt, "Accessing crusade teleport: (%s) Player: (%s) - setting teleport location when crusade is disabled.", 
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch(...)
		{
		}
		return;
	}

	// if a player is using guild teleport and he is not in a guild, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) {
		try
		{
			wsprintf(G_cTxt, "Accessing crusade teleport: (%s) Player: (%s) - teleporting when not in a guild", 
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch(...)
		{
		}
		return;
	}

	if ((m_pClientList[iClientH]->m_cMapIndex == m_iMiddlelandMapIndex) &&
		m_iMiddlelandMapIndex != -1)
		return;

	for (i = 0; i < DEF_MAXGUILDS; i++) 
	if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
		// 带 ãҴ.
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);

		//testcode
		wsprintf(G_cTxt, "ReqGuildTeleport: %d %d %d %s", m_pClientList[iClientH]->m_iGuildGUID, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY, cMapName);
		PutLogList(G_cTxt);

		// !!! RequestTeleportHandler m_cMapName   ״ Ķͷ Ѱָ 
		RequestTeleportHandler(iClientH, "2   ", cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
		return;
	}
	
	// 忡 Ҵ ڷƮ ǥ .  Ҽ ƴ 
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: // Ʒ Ҽ 
		break;
	case 2: //  Ҽ
		break;
	}
}


void CGame::GSM_SetGuildTeleportLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int i, iIndex;
 DWORD dwTemp, dwTime;

	// Ŭ̾Ʈκ û ƴ϶ ٸ κ ڷƮ ǥ  û.  ʿ .
	
	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	//   GUID   ڷƮ ǥ Ǿ ִ ã´.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// ̹ 尡 ִ.
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			//  ġѴ. Ÿ Է ŵ.
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			//  
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
	}
	
	//   .  Ѵ.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == 0) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			//     Ʈ ε ã´.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// ĳ   á. ̷  Ʈ      Ʈ(iIndex) ϰ Ʈ Ѵ.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;
}


void CGame::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange ) return;

	// if a player is teleporting and its not a crusade, log the hacker
	if (!m_bIsCrusadeMode) {
		try
		{
			wsprintf(G_cTxt, "Accessing Crusade Set Teleport:(%s) Player: (%s) - setting point when not a crusade.", 
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch(...)
		{

		}
		return;
	}
	
	// if a player is teleporting and its not a crusade, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) {
		try
		{
			wsprintf(G_cTxt, "Accessing Crusade Set Teleport: (%s) Player: (%s) - setting point when not a guildmaster.", 
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch(...)
		{

		}
		return;
	}

	// v2.04 ǥ  
	if (dY < 100) dY = 100;
	if (dY > 600) dY = 600;

	// Ʈ  ޽ ۼ 
	/*ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDTELEPORTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;*/
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	//   GUID   ڷƮ ǥ Ǿ ִ ã´.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// ̹ 尡 ִ.
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			//  ġѴ. Ÿ Է ŵ.
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			//   
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				
			//Ʈ   ٸ   
			//bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	//   .  Ѵ.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == 0) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;

			//Ʈ   ٸ     
			//bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			//     Ʈ ε ã´.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// ĳ   á. ̷  Ʈ      Ʈ(iIndex) ϰ Ʈ Ѵ.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;

	//Ʈ   ٸ   
	//bStockMsgToGateServer(cData, 23);
}

// New 12/05/2004 Changed
void CGame::MeteorStrikeHandler(int iMapIndex)
{
 int i, ix, iy, dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
 int iTargetArray[DEF_MAXSTRIKEPOINTS];
 short sOwnerH;
 char  cOwnerType;
 DWORD dwTime = timeGetTime();
	
	PutLogList("(!) Beginning Meteor Strike Procedure...");

	if (iMapIndex == -1) {
		PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
		return;
	}
	
	if (m_pMapList[iMapIndex] == 0) {
		PutLogList("(X) MeteorStrikeHandler Error! 0 Map!");
		return;
	}
	
	if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) {
		PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
		return;
	}
	
	for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

	iIndex = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iTargetArray[iIndex] = i; // ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ®ÀÇ ÀÎµ¦½º¸¦ ³Ö´Â´Ù.
			iIndex++;
		}
	}

	//testcode
	wsprintf(G_cTxt, "(!) Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
	PutLogList(G_cTxt);

	// °á°ú º¸°í¿ë ½ºÆ®·°Ãç Å¬¸®¾î
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;

	if (iIndex == 0) {
		// Æø°ÝÇÒ °Ç¹°ÀÌ ¾ø´Ù. ¸ðµÎ ÆÄ±«µÇ¾ú´Ù.
		PutLogList("(!) No strike points!");
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, 0, dwTime + 6000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
	}
	else {

		// ÇØ´ç ¸ÊÀÇ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ¸ÞÅ×¿À °ø°Ý È¿°ú¸¦ º¸¿©ÁÖ¶ó´Â ¸Þ½ÃÁö Àü¼Û
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete ) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
			SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKEHIT, 0, 0, 0, 0);
		}
		
		for (i = 0; i < iIndex; i++) {
			// ¸ðµç Æø°Ý ¸ñÇ¥¿¡ ´ëÇØ µ¿ÀÏÇÑ °ø°ÝÀ» °¡ÇÑ´Ù.
			iTargetIndex = iTargetArray[i];

			if (iTargetIndex == -1) {
				PutLogList("(X) Strike Point MapIndex: -1!");
				goto MSH_SKIP_STRIKE;
			}

			dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
			dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;

			// dX, dY À§Ä¡ ÁÖÀ§¿¡ ÃÖ¼Ò 2°³ ÀÌ»óÀÇ Energy Shield Generator°¡ Á¸ÀçÇÏ¸é ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ®´Â ¹«»çÇÏ´Ù. ±×·¯³ª 1°³ ÀÌÇÏÀÌ¸é °ø°Ý¹Þ¾ÒÀ»¶§ HP°¡ ÁÙ¾îµç´Ù.
			// NPC ÁÖº¯¿¡ ÀÖ´Â Àû Ä³¸¯ÅÍ¸¦ Å½ÁöÇØ °æº¸¸¦ ¿ï¸°´Ù.
			iTotalESG = 0;
			for (ix = dX-10; ix <= dX+10; ix++) 
			for (iy = dY-10; iy <= dY+10; iy++) {
				m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != 0) && (m_pNpcList[sOwnerH]->m_sType == 40)) {
					iTotalESG++;
				}
			}
			
			// testcode
			wsprintf(G_cTxt, "(!) Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
			PutLogList(G_cTxt);

			if (iTotalESG < 2) {
			
				m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (2 - iTotalESG);
				if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) {
					// °Ç¹°ÀÌ ÆÄ±«µÇ¾ú´Ù.
					m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
					// °Ç¹° ±â´É »ó½Ç
					m_pMapList[m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iMapIndex]->m_bIsDisabled = true;
					m_stMeteorStrikeResult.iCrashedStructureNum++;
				}
				else {
					// °Ç¹°ÀÌ ´ë¹ÌÁö¸¦ ¾ò¾ú´Ù.
					m_stMeteorStrikeResult.iStructureDamageAmount += (2 - iTotalESG);
					// °Ç¹° ´ë¹ÌÁö ÀÔÀº ÈÄ ºÒÅ¸´Â ÀÌ¹ÌÁö »ðÀÔ 
					iEffect = iDice(1,5)-1;
					iAddDynamicObjectList(0, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE2, iMapIndex, 
						                  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] +(iDice(1,3) -2), 
										  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] +(iDice(1,3) -2), 60*1000*50);
				}
			}
MSH_SKIP_STRIKE:;
		}

		// 1ÃÊ ÈÄ ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© °ø°Ý ´ë¹ÌÁö È¿°ú
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, 0, dwTime + 1000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
		// 4ÃÊ ÈÄ ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© °ø°Ý ´ë¹ÌÁö È¿°ú
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, 0, dwTime + 4000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
		// 6ÃÊ ÈÄ °ø°Ý °á°ú ÆÇ´Ü.
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, 0, dwTime + 6000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
	}
}

void CGame::_ClearExchangeStatus(int iToH)
{
	if ((iToH <= 0) || (iToH >= DEF_MAXCLIENTS)) return;
	if (m_pClientList[iToH] == 0) return;

	if (m_pClientList[iToH]->m_cExchangeName) 
		SendNotifyMsg(0, iToH, DEF_NOTIFY_CANCELEXCHANGEITEM, 0, 0, 0, 0, 0, 0,
						0, 0, 0, 0, 0);	

	// m_pClientList[iToH]->m_cExchangeName    = false;
	m_pClientList[iToH]->m_dwInitCCTime     = false;
	m_pClientList[iToH]->m_iAlterItemDropIndex = 0;
	//m_pClientList[iToH]->m_cExchangeItemIndex = -1;
	m_pClientList[iToH]->m_iExchangeH = 0;

	m_pClientList[iToH]->m_bIsExchangeMode = false;

	ZeroMemory(m_pClientList[iToH]->m_cExchangeName, sizeof(m_pClientList[iToH]->m_cExchangeName));

}

void CGame::CancelExchangeItem(int iClientH)
{
 int iExH;
	
	// ÇöÀç ±³È¯À» Ãë¼ÒÇÑ´Ù. »ó´ë¹æµµ ÀÚµ¿À¸·Î Ãë¼ÒµÈ´Ù. 
	iExH = m_pClientList[iClientH]->m_iExchangeH;
	_ClearExchangeStatus(iExH);
	_ClearExchangeStatus(iClientH);
}

//HBest force recall start code
void CGame::SetTimeOut(int iClientH)
{
	int forcedIn;
	time_t seconds;
	SYSTEMTIME SysTime;

	seconds = time (0);
	GetLocalTime(&SysTime);

	if (m_pClientList[iClientH] == 0) return;

	m_pClientList[iClientH]->m_iForceStart = seconds;
	m_pClientList[iClientH]->isForceSet = true;

	switch (SysTime.wDayOfWeek) {
		case 1:	forcedIn = m_sRaidTimeMonday; break;
		case 2:	forcedIn = m_sRaidTimeTuesday; break;
		case 3:	forcedIn = m_sRaidTimeWednesday; break;
		case 4:	forcedIn = m_sRaidTimeThursday; break; 
		case 5:	forcedIn = m_sRaidTimeFriday; break;
		case 6:	forcedIn = m_sRaidTimeSaturday; break;
		case 0:	forcedIn = m_sRaidTimeSunday; break;
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_FORCERECALLTIME,  forcedIn , 0, 0, 0);

}

//HBest force recall code
void CGame::CheckTimeOut(int iClientH)
{
	int forcedIn;
	time_t seconds;
	SYSTEMTIME SysTime;

	seconds = time (0);
	GetLocalTime(&SysTime);

	if (m_pClientList[iClientH] == 0) return;

	switch (SysTime.wDayOfWeek) {
		case 1:	forcedIn = m_sRaidTimeMonday; break;
		case 2:	forcedIn = m_sRaidTimeTuesday; break;
		case 3:	forcedIn = m_sRaidTimeWednesday; break;
		case 4:	forcedIn = m_sRaidTimeThursday; break; 
		case 5:	forcedIn = m_sRaidTimeFriday; break;
		case 6:	forcedIn = m_sRaidTimeSaturday; break;
		case 0:	forcedIn = m_sRaidTimeSunday; break;
	}

	if ((seconds - m_pClientList[iClientH]->m_iForceStart) > (forcedIn*60)) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
				RequestTeleportHandler(iClientH, "2   ", "aresden", -1, -1);
			}
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
				RequestTeleportHandler(iClientH, "2   ", "elvine", -1, -1);
			}
	}

}

// v2.17 2002-7-15 Ͽ   ð    ְ Ѵ.
void CGame::SetForceRecallTime(int iClientH)
{
	int iTL_ = 0 ;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return ;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
		//   ִ  ð  ش. 
		// ð Ѵ iWarPeriod Ѵ.

		//   ð Ǿ    ð  ð Ѵ.

		if (m_sForceRecallTime > 0 ) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sForceRecallTime ;
		}
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeMonday; break;  //  3 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeTuesday; break;  //ȭ  3 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeWednesday; break;  //  3 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeThursday; break;  //  3 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeFriday; break; //ݿ 15
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSaturday; break; // 45 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSunday; break; //Ͽ 60
			}
		}
	}
	else { // if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) 
		if (m_sForceRecallTime > 0 ) {
			iTL_ =  20*m_sForceRecallTime ;
		}
		else {

			// ð ִ. Ϻ ð ũ 1 ʱȭ 
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 20*m_sRaidTimeMonday; break;  //  3 2002-09-10 #1
			case 2:	iTL_ = 20*m_sRaidTimeTuesday; break;  //ȭ  3
			case 3:	iTL_ = 20*m_sRaidTimeWednesday; break;  //  3
			case 4:	iTL_ = 20*m_sRaidTimeThursday; break;  //  3
			case 5:	iTL_ = 20*m_sRaidTimeFriday; break; //ݿ 15
			case 6:	iTL_ = 20*m_sRaidTimeSaturday; break; // 45 
			case 0:	iTL_ = 20*m_sRaidTimeSunday; break; //Ͽ 60
			}
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;

	}

	m_pClientList[iClientH]->m_bIsWarLocation = true;
	return ;
}

void CGame::CheckForceRecallTime(int iClientH)
{
	SYSTEMTIME SysTime;
	int iTL_;

	if(m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
		// has admin set a recall time ??
		if (m_sForceRecallTime > 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = m_sForceRecallTime * 20;
		}
		// use standard recall time calculations
		else{
			GetLocalTime(&SysTime);
			switch(SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeMonday; break;  //  3 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeTuesday; break;  //ȭ  3 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeWednesday; break;  //  3 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeThursday; break;  //  3 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeFriday; break; //ݿ 15
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSaturday; break; // 45 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSunday; break; //Ͽ 60
			}
		}
	}
	else{
		// has admin set a recall time ??
		if (m_sForceRecallTime > 0) {
			iTL_ = m_sForceRecallTime * 20;
		}
		// use standard recall time calculations
		else{
			GetLocalTime(&SysTime);
			switch(SysTime.wDayOfWeek) {
			case 1:	iTL_ = 20*m_sRaidTimeMonday; break;  //  3 2002-09-10 #1
			case 2:	iTL_ = 20*m_sRaidTimeTuesday; break;  //ȭ  3 
			case 3:	iTL_ = 20*m_sRaidTimeWednesday; break;  //  3 
			case 4:	iTL_ = 20*m_sRaidTimeThursday; break;  //  3 
			case 5:	iTL_ = 20*m_sRaidTimeFriday; break; //ݿ 15
			case 6:	iTL_ = 20*m_sRaidTimeSaturday; break; // 45 
			case 0:	iTL_ = 20*m_sRaidTimeSunday; break; //Ͽ 60
			}
		}
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = iTL_;
	}

	m_pClientList[iClientH]->m_bIsWarLocation = true;
	return ;

}

int ITEMSPREAD_FIEXD_COORD [25][2] =
{
	{ 0,  0},	//1
	{ 1,  0},	//2
	{ 1,  1},	//3
	{ 0,  1},	//4
	{-1,  1},	//5
	{-1,  0},	//6
	{-1, -1},	//7
	{ 0, -1},	//8
	{ 1, -1},	//9
	{ 2, -1},	//10
	{ 2,  0},	//11
	{ 2,  1},	//12
	{ 2,  2},	//13
	{ 1,  2},	//14
	{ 0,  2},	//15
	{-1,  2},	//16
	{-2,  2},	//17
	{-2,  1},	//18
	{-2,  0},	//19
	{-2, -1},	//20
	{-2, -2},	//21
	{-1, -2},	//22
	{ 0, -2},	//23
	{ 1, -2},	//24
	{ 2, -2},	//25
};

bool CGame::bGetMultipleItemNamesWhenDeleteNpc(short sNpcType, int iProbability, int iMin, int iMax, short sBaseX, short sBaseY,
											   int iItemSpreadType, int iSpreadRange,
											   int *iItemIDs, POINT *BasePos, int *iNumItem)
{
	int		iProb = 100;
	float	fProb, fProbA, fProbB, fProbC;
	int		iItemID;
	int		iNum = 0;
	
	for(int i=0; i<iMax; i++ )
	{
		if( i>iMin ) iProb = iProbability;

		fProb = (float)(100 - iProb) / 10.0;	//WyvernÀÇ Æò±Õ 50
		if( fProb < 1.0 ) fProb = 1.0;

		fProbA = fProbB = fProbC = fProb;

		fProbA = fProbA * 8.0f;
		fProbB = fProbB * 4.0f;
		fProbC = fProbC;

		iItemID = 0;

		switch(sNpcType)
		{
		case 69: // Wyvern...stupid koreans
			// ֻ
			switch (iDice(1,4)) {
				case 1: if (iDice(1,(6000 * fProbA)) == 3) iItemID = 634; break; // RingofWizard
				case 2: if (iDice(1,(5000 * fProbA)) == 3) iItemID = 636; break; // RingofGrandMage
				case 3: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 614; break; // SwordofIceElemental
				case 4: if (iDice(1,(4500 * fProbA)) == 3) iItemID = 380; break; // IceStormManual
			}

			// 
			if( iItemID == 0 )
			{
				switch( iDice(1, 6) ) {	
					case  1: if (iDice(1,(500  * fProbB)) == 2) iItemID = 642; break; // KnecklaceOfIcePro
					case  2: if (iDice(1,(2000 * fProbB)) == 2) iItemID = 643; break; // KnecklaceOfIceEle
					case  3: if (iDice(1,(1000 * fProbB)) == 3) iItemID = 943; break; // IceAxe
					case  4: if (iDice(1,(1500 * fProbB)) == 3) iItemID = 734; break; // RingOfArcmage
					case  5: if (iDice(1,(500  * fProbB)) == 3) iItemID = 942; break; // IceHammer
					case  6: if (iDice(1,(500  * fProbB)) == 2) iItemID = 738; break; // BerserkWand(MS.20)
				}
			}
			break; 

		case 73: // Fire-Wyvern
			// ֻ
			switch (iDice(1, 7)) {
				case  1: if (iDice(1,(5000 * fProbA)) == 3) iItemID = 860; break; // NecklaceOfXelima
				case  2: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 630; break; // RingoftheXelima
				case  3: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 738; break; // BerserkWand(MS.20)
				case  4: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 735; break; // RingOfDragonpower
				case  5: if (iDice(1,(3000 * fProbA)) == 2) iItemID =  20; break; // Excaliber
				case  6: if (iDice(1,(3000 * fProbA)) == 3) iItemID = 382; break; // BloodyShockW.Manual
				case  7: if (iDice(1,(3000 * fProbA)) == 3) iItemID = 381; break; // MassFireStrikeManual
			}

			// 
			if( iItemID == 0 )
			{
				switch( iDice(1, 9) ) {
					case  1: if (iDice(1,(1000 * fProbB)) == 2) iItemID = 645; break; // KnecklaceOfEfreet
					case  2: if (iDice(1,(500  * fProbB)) == 2) iItemID = 638; break; // KnecklaceOfFirePro
					case  3: if (iDice(1,(1000 * fProbB)) == 3) iItemID = 636; break; // RingofGrandMage
					case  4: if (iDice(1,(800  * fProbB)) == 3) iItemID = 734; break; // RingOfArcmage
					case  5: if (iDice(1,(500  * fProbB)) == 3) iItemID = 634; break; // RingofWizard
					case  6: if (iDice(1,(500  * fProbB)) == 2) iItemID = 290; break; // Flameberge+3(LLF)
					case  7: if (iDice(1,(500  * fProbB)) == 3) iItemID = 490; break; // BloodSword
					case  8: if (iDice(1,(500  * fProbB)) == 3) iItemID = 491; break; // BloodAxe
					case  9: if (iDice(1,(500  * fProbB)) == 3) iItemID = 492; break; // BloodRapier
				}
			}

			break;

		case 81: // Abaddon

			// ֻ
			switch (iDice(1, 6)) {
				case 1: if (iDice(1,(100 * fProbA)) == 3) iItemID = 20;  break; // Excaliber
				case 2: if (iDice(1,(100 * fProbA)) == 3) iItemID = 647; break; // NecklaceOfStoneGol
				case 3: if (iDice(1,(100 * fProbA)) == 3) iItemID = 860; break; // NecklaceOfXelima
				case 4: if (iDice(1,(100 * fProbA)) == 3) iItemID = 936; break; // MerienHat
				case 5: if (iDice(1,(100 * fProbA)) == 2) iItemID = 631; break; // RingoftheAbaddon
				case 6: if (iDice(1,(100 * fProbA)) == 2) iItemID = 937; break; // MerienHelm
			}

			// 
			if( iItemID == 0 )
			{
				switch( iDice(1, 15) ) {
					case  1: if (iDice(1,(4 * fProbB)) == 3) iItemID = 650; break; // ZemstoneOfSacrifice
					case  2: if (iDice(1,(4 * fProbB)) == 3) iItemID = 490; break; // BloodSword
					case  3: if (iDice(1,(4 * fProbB)) == 3) iItemID = 491; break; // BloodAxe
					case  4: if (iDice(1,(4 * fProbB)) == 3) iItemID = 492; break; // BloodRapier
					case  5: if (iDice(1,(4 * fProbB)) == 3) iItemID = 611; break; // XelimaAxe
					case  6: if (iDice(1,(4 * fProbB)) == 3) iItemID = 610; break; // XelimaBlade
					case  7: if (iDice(1,(4 * fProbB)) == 3) iItemID = 612; break; // XelimaRapier
					case 10: if (iDice(1,(4 * fProbB)) == 3) iItemID = 645; break; // KnecklaceOfEfreet
					case 11: if (iDice(1,(4 * fProbB)) == 3) iItemID = 638; break; // BloodKlonessAxe
					case 12: if (iDice(1,(4 * fProbB)) == 3) iItemID = 382; break; // BloodyShockW.Manual
					case 13: if (iDice(1,(4 * fProbB)) == 3) iItemID = 381; break; // MassFireStrikeManual
					case 14: if (iDice(1,(4 * fProbB)) == 3) iItemID = 259; break; // MagicWand(M.Shield)
					case 15: if (iDice(1,(4 * fProbB)) == 3) iItemID = 947; break; // DragonStaff(MS.40)
				}
			}
			break;
		} // switch

		// Ϲ  ....dumb korean idiots
		if( iItemID == 0 )
		{
			switch( iDice(1, 24) ) {
				case  1: if (iDice(1,(2 * fProbC)) == 2) iItemID = 740; break; // BagOfGold-medium
				case  2: if (iDice(1,(2 * fProbC)) == 2) iItemID = 741; break; // BagOfGold-large
				case  3: if (iDice(1,(2 * fProbC)) == 2) iItemID = 742; break; // BagOfGold-largest
				case  4:
				case  5:
				case  6:
				case  7: if (iDice(1,(2 * fProbC)) == 2) iItemID = 650; break; // ZemstoneOfSacrifice
				case  8:
				case  9: if (iDice(1,(2 * fProbC)) == 2) iItemID = 656; break; // StoneOfXelima
				case 10:
				case 11:
				case 12: if (iDice(1,(2 * fProbC)) == 2) iItemID = 657; break; // StoneOfMerien
				case 13:
				case 14:
				case 15: if (iDice(1,(2 * fProbC)) == 2) iItemID = 335; break; // EmeraldRing
				case 16:
				case 17: 
				case 18: if (iDice(1,(2 * fProbC)) == 2) iItemID = 290; break; // Flameberge+3(LLF)
				case 19: 
				case 20: if (iDice(1,(2 * fProbC)) == 2) iItemID = 259; break; // MagicWand(M.Shield)
				case 21: if (iDice(1,(2 * fProbC)) == 2) iItemID = 300; break; // MagicNecklace(RM10)
				case 22: if (iDice(1,(2 * fProbC)) == 2) iItemID = 311; break; // MagicNecklace(DF+10)
				case 23: if (iDice(1,(2 * fProbC)) == 2) iItemID = 305; break; // MagicNecklace(DM+1)
				case 24: if (iDice(1,(2 * fProbC)) == 2) iItemID = 308; break; // MagicNecklace(MS10)
			}
		}

		// Ȯ 100 ε ƹ ͵  ʾҴ.
		// Gold ش. retarded koreans -_-
		if( iItemID == 0 && iProb == 100 ) iItemID = 90; // Gold

		if( iItemID != 0 )
		{
			// item id
			iItemIDs[iNum] = iItemID;

			// item position
			switch(iItemSpreadType)
			{
			case DEF_ITEMSPREAD_RANDOM:
				BasePos[iNum].x = sBaseX + iSpreadRange - iDice(1, iSpreadRange * 2 );
				BasePos[iNum].y = sBaseY + iSpreadRange - iDice(1, iSpreadRange * 2 );
				break;

			case DEF_ITEMSPREAD_FIXED:
				BasePos[iNum].x = sBaseX + ITEMSPREAD_FIEXD_COORD[iNum][0];
				BasePos[iNum].y = sBaseY + ITEMSPREAD_FIEXD_COORD[iNum][1];
				break;
			}
			iNum++;
		}

	} // for

	*iNumItem = iNum;

	return true;

} // bGetMultipleItemNamesWhenDeleteNpc... duh...korean morons

// 05/21/2004 - Hypnotoad - Balances to drop status
void CGame::NpcDeadItemGenerator(int iNpcH, short sAttackerH, char cAttackerType)
{
	class CItem * pItem;
	char  cColor, cItemName[21];
	bool  bIsGold;
	int   iGenLevel, iResult, iItemID;
	DWORD dwType, dwValue;
	double dTmp1, dTmp2, dTmp3;

	if (m_pNpcList[iNpcH] == 0) return;
	if ((cAttackerType != DEF_OWNERTYPE_PLAYER) || (m_pNpcList[iNpcH]->m_bIsSummoned )) return;
	if (m_pNpcList[iNpcH]->m_bIsUnsummoned ) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	bIsGold = false;

	switch (m_pNpcList[iNpcH]->m_sType) {
		// NPC not dropping Gold
	case 21: // Guard
	case 34: // Dummy
	case 64: // Crop
		return;
	}

	// 6500 default; the lower the greater the Weapon/Armor/Wand Drop
	if (iDice(1,10000) >= m_iPrimaryDropRate) {
		// 35% Drop 60% of that is gold
		// 35% Chance of drop (35/100)
		if (iDice(1,10000) <= 6000) {
			iItemID = 90; // Gold: (35/100) * (60/100) = 21%
			// If a non-existing itemID is given create no item
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == false) {
				delete pItem;
				return;	
			}

			pItem->m_dwCount = (DWORD)(iDice(1, (m_pNpcList[iNpcH]->m_iGoldDiceMax - m_pNpcList[iNpcH]->m_iGoldDiceMin)) + m_pNpcList[iNpcH]->m_iGoldDiceMin);

			// v1.42 Gold 
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_iAddGold != 0)) {
				dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddGold;
				dTmp2 = (double)pItem->m_dwCount;
				dTmp3 = (dTmp1/100.0f)*dTmp2;
				pItem->m_dwCount += (int)dTmp3;
			}
		}
		else {
			// 9000 default; the lower the greater the Weapon/Armor/Wand Drop
			// 35% Drop 40% of that is an Item 
			dTmp1 = m_pClientList[sAttackerH]->m_iRating*m_cRepDropModifier;
			if (dTmp1 > 1000) dTmp1 = 1000;
			if (dTmp1 < -1000) dTmp1 = -1000;
			dTmp2 = (m_iSecondaryDropRate - (dTmp1));
			if (iDice(1,10000) <= dTmp2) { 
				// 40% Drop 90% of that is a standard drop
				// Standard Drop Calculation: (35/100) * (40/100) * (90/100) = 12.6%
				iResult = iDice(1,12000);
				if ((iResult >= 1) && (iResult <= 3000))          dwValue = 1;
				else if ((iResult >= 3001) && (iResult <= 4000))  dwValue = 2;
				else if ((iResult >= 4001) && (iResult <= 5500))  dwValue = 3;
				else if ((iResult >= 5501) && (iResult <= 7000))  dwValue = 4;
				else if ((iResult >= 7001) && (iResult <= 8500))  dwValue = 5;
				else if ((iResult >= 8501) && (iResult <= 9200))  dwValue = 6;
				else if ((iResult >= 9201) && (iResult <= 9800))  dwValue = 7;
				else if ((iResult >= 9801) && (iResult <= 10000)) dwValue = 8;
				else if ((iResult >= 10001) && (iResult <= 12000)) dwValue = 9;

				switch (dwValue) {	
						case 1: iItemID = 95; break; // Green Potion
						case 2: iItemID = 91; break; // Red Potion
						case 3: iItemID = 93; break; // Blue Potion
						case 4: iItemID = 96; break; // Big Green Potion
						case 5: iItemID = 92; break; // Big Red Potion
						case 6: iItemID = 94; break; // Big Blue Potion
						case 7: switch(iDice(1,6)) {
								case 1: iItemID = 390; break; // Power Green Potion
								case 2: iItemID = 95;  break; // Green Potion
								case 3: iItemID = 780; break; // RedCandy
								case 4: iItemID = 781; break; // BlueCandy
								case 5: iItemID = 782; break; // GreenCandy
								case 6: iItemID = 970; break; // CritCandy
								}
								break;
						case 8: switch(iDice(1,10)) {
								case 1: iItemID = 391; break; // Super Power Green Potion
								case 2: iItemID = 650; break; // Zemstone of Sacrifice
								case 3: iItemID = 656; break; // Xelima Stone
								case 4: iItemID = 657; break; // Merien Stone
								case 5: iItemID = 95;  break; // Green Potion
								case 6: iItemID = 868; break; // AcientTablet(LU)
								case 7: iItemID = 869; break; // AcientTablet(LD)
								case 8: iItemID = 870; break; // AcientTablet(RU)
								case 9: iItemID = 871; break; // AcientTablet(RD)
								case 10: switch(iDice(1,5)) {
										case 1: iItemID = 651; break; // GreenBall
										case 2: iItemID = 652; break; // RedBall
										case 3: iItemID = 653; break; // YellowBall
										case 4: iItemID = 654; break; // BlueBall
										case 5: iItemID = 655; break; // PearlBall
										}
										break;
								}
								break;
						case 9: 		
							SYSTEMTIME SysTime;
							GetLocalTime(&SysTime);
							if (((short)SysTime.wMonth == 12) && (m_pNpcList[iNpcH]->m_sType == 61 || 55)) {
								switch(iDice(1,3)) {
								case 1: iItemID = 780; break; // Red Candy
								case 2: iItemID = 781; break; // Blue Candy
								case 3: iItemID = 782; break; // Green Candy
								}
							}
							break;
				}
				// If a non-existing item is created then delete the item
				pItem = new class CItem;
				if (_bInitItemAttr(pItem, iItemID) == false) {
					delete pItem;
					return;	
				}
			}
			else {
				// Valuable Drop Calculation: (35/100) * (40/100) * (10/100) = 1.4%
				// Define iGenLevel using Npc.cfg#
				switch (m_pNpcList[iNpcH]->m_sType) {

				case 10: // Slime
				case 16: // Giant-Ant
				case 22: // Amphis
				case 55: // Rabbit
				case 56: //	Cat
					iGenLevel = 1;
					break;

				case 11: // Skeleton
				case 14: // Orc, Orc-Mage
				case 17: // Scorpion
				case 18: // Zombie
					iGenLevel = 2;
					break;

				case 12: // Stone-Golem
				case 23: // Clay-Golem
					iGenLevel = 3;
					break;

				case 27: // Hellbound
				case 61: // Rudolph
					iGenLevel = 4;
					break; 

				case 72: // Claw-Turtle
				case 76: // Giant-Plant
				case 74: // Giant-Crayfish
				case 13: // Cyclops
				case 28: // Troll
				case 53: // Beholder
				case 60: // Cannibal-Plant
				case 62: // DireBoar
					iGenLevel = 5;
					break;

				case 29: // Orge
				case 33: // WereWolf
				case 48: // Stalker
				case 54: // Dark-Elf
				case 65: // Ice-Golem
			    case 78: // Minotaurus
					iGenLevel = 6;
					break;

		 	    case 70: // Balrogs
				case 71: // Centaurus
				case 30: // Liche
				case 63: // Frost
			    case 79: // Nizie
					iGenLevel = 7;
					break;

				case 31: // Demon
				case 32: // Unicorn
				case 49: // Hellclaw
				case 50: // Tigerworm
				case 52: // Gagoyle
					iGenLevel = 8;
					break; 

				case 58: // MountainGiant
					iGenLevel = 9;
					break;

			    case 77: // MasterMage-Orc
				case 59: // Ettin
				case 75: // Lizards
					iGenLevel = 10;
					break;
				}	

				if (iGenLevel == 0) return;

				// Weapon Drop: 
				// 1.4% chance Valuable Drop 60% that it is a Weapon
				if (iDice(1,10000) <= 6000) {
					if (iDice(1,10000) <= 8000) {
						// 70% the Weapon is Melee
						switch (iGenLevel) { 

				case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
					switch (iDice(1,3)) { 
				case 1: iItemID = 1;  break; // Dagger
				case 2: iItemID = 8;  break; // ShortSword
				case 3: iItemID = 59; break; // LightAxe
					}
					break; 

				case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
					switch (iDice(1,6)) {
						case 1: iItemID = 12;  break; // MainGauche
						case 2: iItemID = 15;  break; // Gradius
						case 3: iItemID = 65;  break; // SexonAxe
						case 4: iItemID = 62;  break; // Tomahoc
						case 5: iItemID = 23;  break; // Sabre
						case 6: iItemID = 31;  break; // Esterk
					}
					break;

				case 3: // Stone-Golem, Clay-Golem
					switch (iDice(1,4)) {
				case 1: iItemID = 50;  break; // GreatSword
				case 2: iItemID = 68;  break; // DoubleAxe
				case 3: iItemID = 23;  break; // Sabre
				case 4: iItemID = 31;  break; // Esterk
					}
					break;

				case 4: // Hellbound, Rudolph
					switch (iDice(1,5)) {
				case 1: iItemID = 25;  break; // Scimitar
				case 2: iItemID = 28;  break; // Falchion
				case 3: iItemID = 31;  break; // Esterk
				case 4: iItemID = 34;  break; // Rapier
				case 5: iItemID = 71;  break; // WarAxe
					}
					break;

				case 5: // Cyclops, Troll, Beholder, Cannibal-Plant, DireBoar
					    // Claw-Turtle, Giant-Plant, Giant-Crayfish
					switch (iDice(1,4)) {
				case 1: iItemID = 31;  break; // Esterk
				case 2: iItemID = 34;  break; // Rapier
				case 3: iItemID = 72;  break; // WarAxe+1
				case 4: iItemID = 844; break; // BlackShadowSword
					}
					break;

				case 6: // Orge, WereWolf, Stalker, Dark-Elf, Ice-Golem, Minotaurus
					switch (iDice(1,7)) {
				case 1: iItemID = 47;  break; // Claymore+1
				case 2: iItemID = 51;  break; // GreatSword+
				case 3: iItemID = 55;  break; // Flameberge+1
				case 4: iItemID = 34;  break; // GiantSword
				case 5: iItemID = 74;  break; // GoldenAxe
				case 6: iItemID = 848; break; // HolyBlade
				case 7: iItemID = 924; break; // MageSword
					}
					break;

				case 7: // Liche, Frost, Balrogs, Centaurus, Nizie
					switch (iDice(1,6)) {
				case 1: iItemID = 47;  break; // Claymore+1
				case 2: iItemID = 50;  break; // GreatSword
				case 3: iItemID = 54;  break; // Flameberge+1
				case 4: iItemID = 74;  break; // GoldenAxe
				case 5: iItemID = 850; break; // KlonessAxe
				case 6: iItemID = 923; break; // BMageSword
					}
					break;

				case 8: // Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
					switch (iDice(1,5)) {
				case 1: iItemID = 50;  break; // GreatSword
				case 2: iItemID = 560; break; // BattleAxe
				case 3: iItemID = 615; break; // GiantSword
				case 4: iItemID = 56;  break; // Flameberge+2
				case 5: iItemID = 846; break; // The_Devastator
					}
					break;

				case 9: // MountainGiant
					switch (iDice(1,5)) {
				case 1: iItemID = 55;  break; // Flameberge+1
				case 2: iItemID = 615; break; // GiantSword
				case 3: iItemID = 761; break; // BattleHammer
				case 4: iItemID = 762; break; // GiantBattleHammer
				case 5: iItemID = 857; break; // I.M.C Manual
					}
					break;

				case 10: // Ettin, MasterMage-Orc, Giant-Lizard
					switch (iDice(1,9)) {
					case 1: iItemID = 50;  break; // GreatSword
					case 2: iItemID = 51;  break; // GreatSword+1
					case 3: iItemID = 55;  break; // Flameberge+1
					case 4: iItemID = 56;  break; // Flameberge+2
					case 5: iItemID = 615; break; // GiantSword
					case 6: iItemID = 761; break; // BattleHammer
					case 7: iItemID = 762; break; // GiantBattleHammer
					case 8: iItemID = 843; break; // BarbarianHammer
					case 9: iItemID = 853; break; // E.S.W Manual
					}
					break;

						}
					}
					else {
						// 30% the weapon is a Wand
						switch (iGenLevel) {

						case 2: 
						case 3:
							iItemID = 258; break; // MagicWand(MS20)
						case 4: 
						case 5: 
						case 6: 
							iItemID = 257; break; // MagicWand(MS20)
						case 7:
						case 8:
							iItemID = 256; break; // MagicWand(MS20)
						case 9:
						case 10:
							break;
						}	
					}
				}
				else {
					// 1.4% chance Valuable Drop 40% that drop is an Armor/Shield
					switch (iGenLevel) {

					case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
					case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
						switch (iDice(1,2)) { 
							case 1: iItemID = 79;  break; // WoodShield
							case 2: iItemID = 81;  break; // TargeShield
						}
						break; 

					case 3: // Stone-Golem, Clay-Golem
						switch (iDice(1,5)) { 
							case 1: iItemID = 85;  break; // LagiShield
							case 2: iItemID = 454; break; // Hauberk(M)
							case 3: iItemID = 472; break; // Hauberk(W)
							case 4: iItemID = 461; break; // ChainHose(M)
							case 5: iItemID = 482; break; // ChainHose(W)
						}
						break;

					case 4: // Hellbound, Rudolph
						switch (iDice(1,5)) {
							case 1: iItemID = 454; break; // Hauberk(M)
							case 2: iItemID = 472; break; // Hauberk(W)
							case 3: iItemID = 461; break; // ChainHose(M)
							case 4: iItemID = 482; break; // ChainHose(W)
							case 5: iItemID = 86;  break; // KnightShield
						}
						break;

				case 5: // Cyclops, Troll, Beholder, Cannibal-Plant, DireBoar
					    // Claw-Turtle, Giant-Plant, Giant-Crayfish
						switch (iDice(1,7)) {
							case 1: iItemID = 455; break; // LeatherArmor(M)
							case 2: iItemID = 475; break; // LeatherArmor(W)
							case 3: iItemID = 87;  break; // TowerShield
							case 4: iItemID = 454; break; // Hauberk(M)
							case 5: iItemID = 472; break; // Hauberk(W)
							case 6: iItemID = 461; break; // ChainHose(M)
							case 7: iItemID = 482; break; // ChainHose(W)
						}
						break;

					case 6: // Orge, WereWolf, Stalker, Dark-Elf, Ice-Golem, Minotaurus
						switch (iDice(1,6)) {
						case 1: switch(iDice(1,2)) {
							case 1: iItemID = 456; break; // ChainMail(M)
							case 2: iItemID = 476; break; // ChainMail(W)
						}
						break;
						case 2: switch(iDice(1,2)) {
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
						}
						break;
						case 3: iItemID = 87; break; // TowerShield
						case 4: switch(iDice(1,8)) {
							case 1: iItemID = 750; break; // Horned-Helm(M)
							case 2: iItemID = 751; break; // Wings-Helm(M)
							case 3: iItemID = 754; break; // Horned-Helm(W)
							case 4: iItemID = 755; break; // Wings-Helm(W)
							case 5: iItemID = 752; break; // Wizard-Cap(M) 
							case 6: iItemID = 753; break; // Wizard-Hat(M)
							case 7: iItemID = 756; break; // Wizard-Cap(W) 
							case 8: iItemID = 757; break; // Wizard-Hat(W) 
						}
						break;	
						case 5: switch(iDice(1,2)) {
							case 1: iItemID = 454; break; // Hauberk(M)
							case 2: iItemID = 472; break; // Hauberk(W)
						}
						break;
						case 6: switch(iDice(1,2)) {
							case 1: iItemID = 461; break; // ChainHose(M)
							case 2: iItemID = 482; break; // ChainHose(W)
						}
						break;
						}
						break;


					case 7: // Liche, Frost, Balrogs, Centaurus, Nizie
						switch (iDice(1,6)) {
						case 1: switch(iDice(1,6)) {
							case 1: iItemID = 457; break; // ScaleMail(M)
							case 2: iItemID = 477; break; // ScaleMail(W)
							case 3: iItemID = 454; break; // Hauberk(M)
							case 4: iItemID = 472; break; // Hauberk(W)
							case 5: iItemID = 461; break; // ChainHose(M)
							case 6: iItemID = 482; break; // ChainHose(W)
							}
							break;
						case 2: switch(iDice(1,2)) {
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
							}
							break;
						case 3: iItemID = 86; break; // KnightShield
						case 4: iItemID = 87; break; // TowerShield
						case 5: switch(iDice(1,2)) {
							case 1: iItemID = 600; break; // Helm(M)
							case 2: iItemID = 602; break; // Helm(M)
							}
							break;
						case 6: switch(iDice(1,2)) {
							case 1: iItemID = 601; break; // Full-Helm(M)
							case 2: iItemID = 603; break; // Full-Helm(M)
							}
							break;
						}
						break;

					case 8: // Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
						switch(iDice(1,4)) {
							case 1: iItemID = 402; break; // Cape
							case 2: iItemID = 451; break; // Boots
							case 3: iItemID = 926; break; // ShieldOfFaith
							case 4: iItemID = 927; break; // ShieldOfBrave
							}
							break;

					case 9: // Mountain-Giant
						switch(iDice(1,2)) {
							case 1: iItemID = 402; break; // Cape
							case 2: iItemID = 451; break; // Boots
							}
							break;

					case 10: //Ettin, MasterMage-Orc, Giant-Lizard
						switch(iDice(1,4)) {
							case 1: iItemID = 457; break; // ScaleMail(M)
							case 2: iItemID = 477; break; // ScaleMail(W)
							case 4: iItemID = 600; break; // Helm(M)
							case 5: iItemID = 602; break; // Helm(W)
							}
							break;
					}
				}
				pItem = new class CItem;
				if (_bInitItemAttr(pItem, iItemID) == false) {
					delete pItem;
					return;	
				}

				if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 299)) {
						dwType = 6; 
						cColor = 2; 
					}
					else if ((iResult >= 300) && (iResult <= 999)) {
						dwType = 8; 
						cColor = 3;
					}
					else if ((iResult >= 1000) && (iResult <= 2499)) {
						dwType = 1;
						cColor = 5;
					}
					else if ((iResult >= 2500) && (iResult <= 4499)) {
						dwType = 5;
						cColor = 1;
					}
					else if ((iResult >= 4500) && (iResult <= 6499)) {
						dwType = 3;
						cColor = 7;
					}
					else if ((iResult >= 6500) && (iResult <= 8099)) {
						dwType = 2;
						cColor = 4;
					}
					else if ((iResult >= 8100) && (iResult <= 9699)) {
						dwType = 7;
						cColor = 6;
					}
					else if ((iResult >= 9700) && (iResult <= 10000)) {
						dwType = 9;
						cColor = 8;
					}

					pItem->m_cItemColor = cColor;

					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					switch (dwType) {
					case 1: 
						if (dwValue <= 5) dwValue = 5;
						break; 
					case 2: // 
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 6: // 
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: // 					
						if (dwValue <= 2) dwValue = 2;
						break; 
					}
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

					pItem->m_dwAttribute = 0;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					if (iDice(1,10000) >= 6000) {

						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10;
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11;

						iResult = iDice(1, 30000);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
						else dwValue = 1; // v2.03 906

						switch (dwType) {
						case 2: 
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: 
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: 
							dwValue = 2;
							break; 
						case 12: 
							dwValue = 5;
							break; 
						}
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						dwType  = dwType << 12;
						dwValue = dwValue << 8;

						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}

				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
					dwType = 10;
					cColor = 5;

					pItem->m_cItemColor = cColor;

					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

					pItem->m_dwAttribute = 0;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					if (iDice(1,10000) >= 6000) {

						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10;
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11;

						iResult = iDice(1, 30000);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
						else dwValue = 1; // v2.03 906

						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						switch (dwType) {
						case 2: 
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: 
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: 
							dwValue = 2;
							break; 
						case 12:
							dwValue = 5;
							break; 
						}

						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}
				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE) {

					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 5999))          dwType = 8;
					else if ((iResult >= 6000) && (iResult <= 8999))  dwType = 6;
					else if ((iResult >= 9000) && (iResult <= 9554))  dwType = 11; //dwType = 11;
					else if ((iResult >= 9555) && (iResult <= 10000)) dwType = 12; //dwType = 12;

					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					switch (dwType) {
					case 6: 
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: 
						if (dwValue <= 2) dwValue = 2;
						break; 

					case 11:
					case 12:
						// v2.04
						dwValue = (dwValue+1) / 2;
						if (dwValue < 1) dwValue = 1;
						if ((iGenLevel <= 3) && (dwValue > 2)) dwValue = 2;
						break;
					}
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

					pItem->m_dwAttribute = 0;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					if (iDice(1,10000) >= 6000) {

						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 999))           dwType = 3;
						else if ((iResult >= 1000) && (iResult <= 3999))  dwType = 1;
						else if ((iResult >= 4000) && (iResult <= 5499))  dwType = 5;
						else if ((iResult >= 5500) && (iResult <= 6499))  dwType = 4;
						else if ((iResult >= 6500) && (iResult <= 7499))  dwType = 6;
						else if ((iResult >= 7500) && (iResult <= 9399))  dwType = 7;
						else if ((iResult >= 9400) && (iResult <= 9799))  dwType = 8;
						else if ((iResult >= 9800) && (iResult <= 10000)) dwType = 9;

						iResult = iDice(1, 30000);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
						else dwValue = 1; // v2.03 906

						switch (dwType) {
						case 1: 
						case 3: 
						case 7: 
						case 8: 
						case 9: 
							if (dwValue <= 3) dwValue = 3;
							break; 
						}
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}

				_AdjustRareItemValue(pItem);
			}
		}

		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		SYSTEMTIME SysTime;
		char cTemp[256];
		GetLocalTime(&SysTime);
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);

		m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, 
			m_pNpcList[iNpcH]->m_sY, 
			pItem);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
			m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
			pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4 color

		_bItemLog(DEF_ITEMLOG_NEWGENDROP, 0, 0, pItem);
	}
}

bool CGame::bReadAdminSetConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode, cGSMode[16] = "";
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
	 return false;
	}
	else {
		 PutLogList("(!) Reading settings file...");
		 cp = new char[dwFileSize+2];
		 ZeroMemory(cp, dwFileSize+2);
		 fread(cp, dwFileSize, 1, pFile);

		 pStrTok = new class CStrTok(cp, seps);
		 token = pStrTok->pGet();
		 //token = strtok( cp, seps );   
		 while( token != 0 )   {

		 if (cReadMode != 0) {
		   switch (cReadMode) {

		   case 1:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMKill = atoi(token);
			}
			else{
				m_iAdminLevelGMKill = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 2:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMRevive = atoi(token);
			}
			else{
				m_iAdminLevelGMRevive = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 3:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMCloseconn = atoi(token);
			}
			else{
				m_iAdminLevelGMCloseconn = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 4:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMCheckRep = atoi(token);
			}
			else{
				m_iAdminLevelGMCheckRep = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 5:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelWho = atoi(token);
			}
			else{
				m_iAdminLevelWho = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 6:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelEnergySphere = atoi(token);
			}
			else{
				m_iAdminLevelEnergySphere = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 7:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelShutdown = atoi(token);
			}
			else{
				m_iAdminLevelShutdown = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 8:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelObserver = atoi(token);
			}
			else{
				m_iAdminLevelObserver = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 9:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelShutup = atoi(token);
			}
			else{
				m_iAdminLevelShutup = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 10:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCallGaurd = atoi(token);
			}
			else{
				m_iAdminLevelCallGaurd = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 11:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonDemon = atoi(token);
			}
			else{
				m_iAdminLevelSummonDemon = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------		   
		  case 12:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonDeath = atoi(token);
			}
			else{
				m_iAdminLevelSummonDeath = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 13:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelReserveFightzone = atoi(token);
			}
			else{
				m_iAdminLevelReserveFightzone = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 14:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCreateFish = atoi(token);
			}
			else{
				m_iAdminLevelCreateFish = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 15:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelTeleport = atoi(token);
			}
			else{
				m_iAdminLevelTeleport = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 16:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCheckIP = atoi(token);
			}
			else{
				m_iAdminLevelCheckIP = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 17:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelPolymorph = atoi(token);
			}
			else{
				m_iAdminLevelPolymorph = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 18:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetInvis = atoi(token);
			}
			else{
				m_iAdminLevelSetInvis = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 19:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetZerk = atoi(token);
			}
			else{
				m_iAdminLevelSetZerk = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 20:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetIce = atoi(token);
			}
			else{
				m_iAdminLevelSetIce = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 21:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGetNpcStatus = atoi(token);
			}
			else{
				m_iAdminLevelGetNpcStatus = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------				
		  case 22:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetAttackMode = atoi(token);
			}
			else{
				m_iAdminLevelSetAttackMode = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 23:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelUnsummonAll = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonAll = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 24:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelUnsummonDemon = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonDemon = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 25:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummon = atoi(token);
			}
			else{
				m_iAdminLevelSummon = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 26:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonAll = atoi(token);
			}
			else{
				m_iAdminLevelSummonAll = 4;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 27:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonPlayer = atoi(token);
			}
			else{
				m_iAdminLevelSummonPlayer = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 28:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelDisconnectAll = atoi(token);
			}
			else{
				m_iAdminLevelDisconnectAll = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 29:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelEnableCreateItem = atoi(token);
			}
			else{
				m_iAdminLevelEnableCreateItem = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 30:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCreateItem = atoi(token);
			}
			else{
				m_iAdminLevelCreateItem = 4;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 31:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelStorm = atoi(token);
			}
			else{
				m_iAdminLevelStorm = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 32:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelWeather = atoi(token);
			}
			else{
				m_iAdminLevelWeather = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 33:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetStatus = atoi(token);
			}
			else{
				m_iAdminLevelSetStatus = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 34:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGoto = atoi(token);
			}
			else{
				m_iAdminLevelGoto = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 35:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelMonsterCount = atoi(token);
			}
			else{
				m_iAdminLevelMonsterCount = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 36:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetRecallTime = atoi(token);
			}
			else{
				m_iAdminLevelSetRecallTime = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 37:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelUnsummonBoss = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonBoss = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 38:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelClearNpc = atoi(token);
			}
			else{
				m_iAdminLevelClearNpc = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------				
		  case 39:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelTime = atoi(token);
			}
			else{
				m_iAdminLevelTime = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 40:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelPushPlayer = atoi(token);
			}
			else{
				m_iAdminLevelPushPlayer = 2;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 41:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonGuild = atoi(token);
			}
			else{
				m_iAdminLevelSummonGuild = 3;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 42:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCheckStatus = atoi(token);
			}
			else{
				m_iAdminLevelCheckStatus = 1;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 43:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCleanMap = atoi(token);
			}
			else{
				m_iAdminLevelCleanMap = 1;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
			}
		  }
		  else {
			if (memcmp(token, "Admin-Level-/kill", 17) == 0)						cReadMode = 1;
			if (memcmp(token, "Admin-Level-/revive", 19) == 0)						cReadMode = 2;
			if (memcmp(token, "Admin-Level-/closecon", 21) == 0)					cReadMode = 3;
			if (memcmp(token, "Admin-Level-/checkrep", 21) == 0)					cReadMode = 4;
			if (memcmp(token, "Admin-Level-/who", 16) == 0)							cReadMode = 5;
			if (memcmp(token, "Admin-Level-/energysphere", 25) == 0)				cReadMode = 6;
			if (memcmp(token, "Admin-Level-/shutdownthisserverrightnow", 39) == 0)	cReadMode = 7;
			if (memcmp(token, "Admin-Level-/setobservermode", 28) == 0)				cReadMode = 8;
			if (memcmp(token, "Admin-Level-/shutup", 19) == 0)						cReadMode = 9;
			if (memcmp(token, "Admin-Level-/attack", 19) == 0)						cReadMode = 10;
			if (memcmp(token, "Admin-Level-/summondemon", 24) == 0)					cReadMode = 11;
			if (memcmp(token, "Admin-Level-/summondeath", 24) == 0)					cReadMode = 12;
			if (memcmp(token, "Admin-Level-/reservefightzone", 28) == 0)			cReadMode = 13;
			if (memcmp(token, "Admin-Level-/createfish", 23) == 0)					cReadMode = 14;
			if (memcmp(token, "Admin-Level-/teleport", 21) == 0)					cReadMode = 15;
			if (memcmp(token, "Admin-Level-/checkip", 20) == 0)						cReadMode = 16;
			if (memcmp(token, "Admin-Level-/polymorph", 22) == 0)					cReadMode = 17;
			if (memcmp(token, "Admin-Level-/setinvi", 20) == 0)						cReadMode = 18;
			if (memcmp(token, "Admin-Level-/setzerk", 20) == 0)						cReadMode = 19;
			if (memcmp(token, "Admin-Level-/setfreeze", 22) == 0)					cReadMode = 20;
			if (memcmp(token, "Admin-Level-/gns", 16) == 0)							cReadMode = 21;
			if (memcmp(token, "Admin-Level-/setattackmode", 26) == 0)				cReadMode = 22;
			if (memcmp(token, "Admin-Level-/unsummonall", 24) == 0)					cReadMode = 23;
			if (memcmp(token, "Admin-Level-/unsummondemon", 26) == 0)				cReadMode = 24;
			if (memcmp(token, "Admin-Level-/summonnpc", 22) == 0)					cReadMode = 25;
			if (memcmp(token, "Admin-Level-/summonall", 22) == 0)					cReadMode = 26;
			if (memcmp(token, "Admin-Level-/summonplayer", 25) == 0)				cReadMode = 27;
			if (memcmp(token, "Admin-Level-/disconnectall", 26) == 0)				cReadMode = 28;
			if (memcmp(token, "Admin-Level-/enableadmincreateitem", 34) == 0)		cReadMode = 29;
			if (memcmp(token, "Admin-Level-/createitem", 23) == 0)					cReadMode = 30;
			if (memcmp(token, "Admin-Level-/storm", 18) == 0)						cReadMode = 31;
			if (memcmp(token, "Admin-Level-/weather", 20) == 0)						cReadMode = 32;
			if (memcmp(token, "Admin-Level-/setstatus", 22) == 0)					cReadMode = 33;
			if (memcmp(token, "Admin-Level-/goto", 17) == 0)						cReadMode = 34;
			if (memcmp(token, "Admin-Level-/monstercount", 17) == 0)				cReadMode = 35;
			if (memcmp(token, "Admin-Level-/setforcerecalltime", 23) == 0)			cReadMode = 36;
			if (memcmp(token, "Admin-Level-/unsummonboss", 25) == 0)				cReadMode = 37;
			if (memcmp(token, "Admin-Level-/clearnpc", 21) == 0)					cReadMode = 38;
			if (memcmp(token, "Admin-Level-/time", 17) == 0)						cReadMode = 39;
			if (memcmp(token, "Admin-Level-/send", 17) == 0)						cReadMode = 40;
			if (memcmp(token, "Admin-Level-/summonguild", 24) == 0)					cReadMode = 41;
			if (memcmp(token, "Admin-Level-/checkstatus", 24) == 0)					cReadMode = 42;	
			if (memcmp(token, "Admin-Level-/clearmap", 21) == 0)					cReadMode = 43;	
		  }

		  token = pStrTok->pGet();
		  //token = strtok( 0, seps );
		 }
		 delete pStrTok;
		 delete cp;
		}
		if (pFile != 0) fclose(pFile);

		return true;
}

void CGame::AdminOrder_Time(int iClientH, char * pData, DWORD dwMsgSize)
{
	//Time command By ACiDx Last edit on Sept,06,04
	bool m_bManualTime;
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	int i;

		if ((dwMsgSize)	<= 0) return;
		if (m_pClientList[iClientH] == 0) return;
		if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelTime) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
			return;
		}
	
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != 0) {
			if (token[0] == '2') {
				m_cDayOrNight = 2;
				wsprintf(G_cTxt, "(%s) Admin(%s) Order: Forces night mode", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, G_cTxt);
				m_bManualTime = true;
			}
			else if (token[0] == '1') {
				m_cDayOrNight = 1;
				wsprintf(G_cTxt, "(%s) Admin(%s) Order: Forces day mode", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				m_bManualTime = true;
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, G_cTxt);
			}
			else if (token[0] == '0') {		
				wsprintf(G_cTxt, "(%s) Admin(%s) Order: Disables force time", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				m_bManualTime = false;
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, G_cTxt);
			}
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
			if ((m_pClientList[i]->m_cMapIndex >= 0) && 
				(m_pMapList[m_pClientList[i]->m_cMapIndex] != 0) &&
				(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == false))
				SendNotifyMsg(0, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, 0, 0, 0);	
		}
	}

	delete pStrTok;
}

void CGame::AdminOrder_CheckRep(int iClientH, char *pData,DWORD dwMsgSize)
{
 class  CStrTok * pStrTok;
 short m_iRating;
 char   * token, cName[11], cTargetName[11], cRepMessage[256], cTemp[256], seps[] = "= \t\n", cBuff[256];
 int i;

	if (m_pClientList[iClientH] == 0) return;
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cRepMessage, sizeof(cRepMessage));
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		wsprintf(cRepMessage, " You have %d reputation points.", m_pClientList[iClientH]->m_iRating);
		ShowClientMsg(iClientH, cRepMessage);
	} 
	else {
		if ((dwMsgSize)	<= 0) return;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		
		if (token != 0) {
			ZeroMemory(cName, sizeof(cName));
			strcpy(cName, token);
		} 
		else {
			ZeroMemory(cName, sizeof(cName));
			strcpy(cName, "null");
		}

		token = pStrTok->pGet();
		
		if (token != 0) {
			m_iRating = atoi(token);
		} 
		
		if (token == 0) { 
			token = "null"; 
		}
		
			if (cName != 0) {
			token = cName;

				if (strlen(token) > 10) 
  					memcpy(cTargetName, token, 10);
				else memcpy(cTargetName, token, strlen(token));

				for (i = 1; i < DEF_MAXCLIENTS; i++) 
  					if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
						wsprintf(cRepMessage, " %s has %d reputation points.", m_pClientList[i]->m_cCharName, m_pClientList[i]->m_iRating);
						ShowClientMsg(iClientH, cRepMessage);
					}
			}
	}
}

void CGame::AdminOrder_Pushplayer(int iClientH, char * pData, DWORD dwMsgSize)
{
//Push Player- By:ACiDx  Monday , September 2004
	//Teleports a Defined Player to Defined Destination
	// /push playername mapname sX dX
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256], cName[11], cTargetName[11];
 class  CStrTok * pStrTok;
 int dX, dY;
 int i;
 bool   bFlag;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));

	dX = dY = -1;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelPushPlayer) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	
	if (token != 0) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}
	token = pStrTok->pGet();
	if (token != 0) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != 0) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != 0) {
		dY = atoi(token);
	}

	if (token == 0) { token = "null"; }
	if (cName != 0) {
		token = cName;

	if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			bFlag = false;
			//Asks For Flag on maps
			if (strcmp("2ndmiddle", cMapName) == 0) bFlag = true;
			if (strcmp("abaddon", cMapName) == 0) bFlag = true; 
			if (strcmp("arebrk11", cMapName) == 0) bFlag = true;
			if (strcmp("arebrk12", cMapName) == 0) bFlag = true;
			if (strcmp("arebrk21", cMapName) == 0) bFlag = true;
			if (strcmp("arebrk22", cMapName) == 0) bFlag = true;
			if (strcmp("arefarm", cMapName) == 0) bFlag = true;
			if (strcmp("arejail", cMapName) == 0) bFlag = true;
			if (strcmp("aremidl", cMapName) == 0) bFlag = true;
			if (strcmp("aremidr", cMapName) == 0) bFlag = true;
			if (strcmp("aresden", cMapName) == 0) bFlag = true;
			if (strcmp("aresdend1", cMapName) == 0) bFlag = true;
			if (strcmp("areuni", cMapName) == 0) bFlag = true;
			if (strcmp("arewrhus", cMapName) == 0) bFlag = true;
			if (strcmp("bisle", cMapName) == 0)   bFlag = true;
			if (strcmp("bsmith_1", cMapName) == 0) bFlag = true;
			if (strcmp("bsmith_1f", cMapName) == 0) bFlag = true;
			if (strcmp("bsmith_2", cMapName) == 0) bFlag = true;
			if (strcmp("bsmith_2f", cMapName) == 0) bFlag = true;
			if (strcmp("BtField", cMapName) == 0) bFlag = true;
			if (strcmp("cath_1", cMapName) == 0) bFlag = true;
			if (strcmp("cath_2", cMapName) == 0)      bFlag = true;
			if (strcmp("cityhall_1", cMapName) == 0) bFlag = true;
			if (strcmp("cityhall_2", cMapName) == 0) bFlag = true;
			if (strcmp("CmdHall_1", cMapName) == 0) bFlag = true;
			if (strcmp("CmdHall_2", cMapName) == 0) bFlag = true;
			if (strcmp("default", cMapName) == 0) bFlag = true;
			if (strcmp("dglv2", cMapName) == 0) bFlag = true;
			if (strcmp("dglv3", cMapName) == 0) bFlag = true;
			if (strcmp("dglv4", cMapName) == 0) bFlag = true;
			if (strcmp("druncncity", cMapName) == 0) bFlag = true; 
			if (strcmp("elvbrk11", cMapName) == 0) bFlag = true;
			if (strcmp("elvbrk12", cMapName) == 0) bFlag = true;
			if (strcmp("elvbrk21", cMapName) == 0) bFlag = true;
			if (strcmp("elvbrk22", cMapName) == 0) bFlag = true;
			if (strcmp("elvfarm", cMapName) == 0) bFlag = true;
			if (strcmp("elvine", cMapName) == 0)  bFlag = true;
			if (strcmp("elvined1", cMapName) == 0)    bFlag = true;
			if (strcmp("elvjail", cMapName) == 0)    bFlag = true;
			if (strcmp("elvmidl", cMapName) == 0) bFlag = true;
			if (strcmp("elvmidr", cMapName) == 0) bFlag = true;
			if (strcmp("elvuni", cMapName) == 0) bFlag = true;
			if (strcmp("elvwrhus", cMapName) == 0) bFlag = true;
			if (strcmp("fightzone1", cMapName) == 0) bFlag = true;
			if (strcmp("fightzone2", cMapName) == 0) bFlag = true;
			if (strcmp("fightzone3", cMapName) == 0) bFlag = true;
			if (strcmp("fightzone4", cMapName) == 0) bFlag = true;
			if (strcmp("fightzone5", cMapName) == 0) bFlag = true;
			if (strcmp("fightzone6", cMapName) == 0) bFlag = true;
			if (strcmp("fightzone7", cMapName) == 0) bFlag = true;
			if (strcmp("fightzone8", cMapName) == 0) bFlag = true;
			if (strcmp("fightzone9", cMapName) == 0) bFlag = true;
			if (strcmp("fightzone10", cMapName) == 0) bFlag = true;
			if (strcmp("gldhall_1", cMapName) == 0) bFlag = true;
			if (strcmp("gldhall_2", cMapName) == 0)   bFlag = true;
			if (strcmp("GodH", cMapName) == 0)   bFlag = true;
			if (strcmp("gshop_1", cMapName) == 0) bFlag = true;
			if (strcmp("gshop_1f", cMapName) == 0) bFlag = true;
			if (strcmp("gshop_2", cMapName) == 0)     bFlag = true;
			if (strcmp("gshop_2f", cMapName) == 0)     bFlag = true;
			if (strcmp("HRampart", cMapName) == 0)     bFlag = true;
			if (strcmp("huntzone1", cMapName) == 0) bFlag = true;
			if (strcmp("huntzone2", cMapName) == 0) bFlag = true;
			if (strcmp("huntzone3", cMapName) == 0) bFlag = true;
			if (strcmp("huntzone4", cMapName) == 0) bFlag = true;
			if (strcmp("icebound", cMapName) == 0) bFlag = true; 
			if (strcmp("inferniaA", cMapName) == 0) bFlag = true; 
			if (strcmp("inferniaB", cMapName) == 0) bFlag = true; 
			if (strcmp("maze", cMapName) == 0) bFlag = true; 
			if (strcmp("middled1n", cMapName) == 0) bFlag = true;
			if (strcmp("middled1x", cMapName) == 0) bFlag = true;
			if (strcmp("middleland", cMapName) == 0) bFlag = true;
			if (strcmp("penalty", cMapName) == 0) bFlag = true;
			if (strcmp("procella", cMapName) == 0) bFlag = true;
			if (strcmp("resurr1", cMapName) == 0) bFlag = true;
			if (strcmp("resurr2", cMapName) == 0) bFlag = true;
			if (strcmp("toh1", cMapName) == 0) bFlag = true;
			if (strcmp("toh2", cMapName) == 0) bFlag = true;
			if (strcmp("toh3", cMapName) == 0) bFlag = true;
			if (strcmp("wrhus_1", cMapName) == 0) bFlag = true;
			if (strcmp("wrhus_1f", cMapName) == 0) bFlag = true;
			if (strcmp("wrhus_2", cMapName) == 0)     bFlag = true;
			if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = true;
			if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = true;
			if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = true;
			if (strcmp("Test", cMapName) == 0) bFlag = true;
			if (strcmp("GMMap", cMapName) == 0) bFlag = true;

			//Defines I as Max clients
				if (bFlag )
					//Reqeust the Push/Teleport
					RequestTeleportHandler(i, "2   ", cMapName, dX, dY);
   					wsprintf(G_cTxt,"(%s) GM(%s) sends (%s) Player(%s) to [%s](%d,%d)",m_pClientList[iClientH]->m_cIPaddress, 
						m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName, cMapName, dX, dY);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, G_cTxt);
				delete pStrTok;
				return;
			}
}
}
// SUMMONGUILD Deleted
/*
void CGame::AdminOrder_SummonGuild(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, * cp, cBuff[256], cMapName[11], char cGuildName[20]; 
 WORD   *wp;
 int    pX, pY, i;
 class  CStrTok * pStrTok;
 DWORD  dwGoldCount;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize) <= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonGuild) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
		// dwGoldCount = player gold
		dwGoldCount = dwGetItemCount(iClientH, "Gold");
		// if summonguildcost is greater than player gold return
		if (m_iSummonGuildCost > dwGoldCount) {
			return;
		}
		// if summonguildcost is less than player gold
		else {
			// reduce gold by summonguildcost
			SetItemCount(iClientH, "Gold", dwGoldCount - m_iSummonGuildCost);
		}
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == 0) {
		delete pStrTok;
		return;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;
	//memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

	if (strlen(token) > 20)
			memcpy(cGuildName, token, 20);
		else memcpy(cGuildName, token, strlen(token));

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cGuildName, token) == 0)) {
			RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
	}//m_pClientList[i]->m_cCharName

	wsprintf(G_cTxt,"GM Order(%s): PC(%s) Summoned to (%s)", m_pClientList[iClientH]->m_cGuildName, cGuildName, cMapName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, G_cTxt);

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONGUILD;
	cp++;

	memcpy(cp, cGuildName, 20);
	cp += 20;

	memcpy(cp, cMapName, 10);
	cp += 10;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;

	bStockMsgToGateServer(cBuff, 25);

	delete pStrTok;
}
*/

void CGame::AdminOrder_SummonGuild(int iClientH, char *pData, DWORD dwMsgSize)
{
char   seps[] = "= \t\n";
char   * cBuff[256], cLocation[11]; 
int    pX, pY, i;
// class  CStrTok * pStrTok;
char buff [100];
if (m_pClientList[iClientH] == 0) return;
if ((dwMsgSize) <= 0) return;

//if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
 // Admin user level+a+t T-TT+T-T +a+t T-+?T++U+aTC TC+TC+c++n T-+T T+T++.
//  SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
// return;
//}

ZeroMemory(cBuff, sizeof(cBuff));
memcpy(cBuff, pData, dwMsgSize);

pX = m_pClientList[iClientH]->m_sX;
pY = m_pClientList[iClientH]->m_sY;
memcpy(cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);
wsprintf(buff,"Summon-Guild: %s (%s) %s %d %d",m_pClientList[iClientH]->m_cCharName,m_pClientList[iClientH]->m_cGuildName,cLocation,pX,pY);
PutLogList(buff);
for (i = 0; i < DEF_MAXCLIENTS; i++)
 
 if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cGuildName,m_pClientList[iClientH]->m_cGuildName) == 0) && (i != iClientH)) {
  RequestTeleportHandler(i, "2   ", cLocation, pX, pY);
 }//m_pClientList[i]->m_cCharName
// delete pStrTok;
}

void CGame::SendCollectedMana()
{
 char * cp, cData[120];
 WORD * wp;

	//SendMsgToGateServer(MSGID_COLLECTEDMANA, 0);

	//   ٸ ޽  ʴ´.    ʿ ޽ ϸ ȵȴ.
	if ((m_iCollectedMana[1] == 0) && (m_iCollectedMana[2] == 0)) return;

	//testcode
	wsprintf(G_cTxt, "Sending Collected Mana: %d %d", m_iCollectedMana[1], m_iCollectedMana[2]);
	PutLogList(G_cTxt);

	/*ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp = GSM_COLLECTEDMANA;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[1];
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[2];
	cp += 2;*/

	CollectedManaHandler(m_iCollectedMana[1], m_iCollectedMana[2]);

	//bStockMsgToGateServer(cData, 5);
	
	// ׵    Ŭ.
	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
}

void CGame::CollectedManaHandler(WORD wAresdenMana, WORD wElvineMana)
{
	if (m_iAresdenMapIndex != -1) {
		m_iAresdenMana += wAresdenMana;
		//testcode
		if (wAresdenMana > 0) {
			wsprintf(G_cTxt, "Aresden Mana: %d Total:%d", wAresdenMana, m_iAresdenMana);
			PutLogList(G_cTxt);
		}
	}

	if (m_iElvineMapIndex != -1) {
		m_iElvineMana += wElvineMana;
		//testcode
		if (wElvineMana > 0) {
			wsprintf(G_cTxt, "Elvine Mana: %d Total:%d", wElvineMana, m_iElvineMana);
			PutLogList(G_cTxt);
		}
	}
}

//New Changed 11/05/2004
// v2.15 ׿   ǹ HP  ֱ  ƾ 
//   ǹ 4 쿡 缭 ƾ  Ǿ ִ.
void CGame::CalcMeteorStrikeEffectHandler(int iMapIndex)
{
 int i, iActiveStructure, iStructureHP[DEF_MAXSTRIKEPOINTS] ;
 char * cp, * cp2, cData[120], cWinnerSide, cTempData[120];
 WORD * wp;

	if (m_bIsCrusadeMode == false) return;

	// ڿ  ǹ HP ֱ   ʱȭ 
	for(i = 0 ; i < DEF_MAXSTRIKEPOINTS; i++)
		iStructureHP[i] = 0 ;

	//  ȿ Ѵ.  ǹ ıǾٸ   . ׷     Ʈ.
	iActiveStructure = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iActiveStructure++;
			iStructureHP[i] = m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP ;
		}
	}
	
	//testcode
	wsprintf(G_cTxt, "ActiveStructure:%d  MapIndex:%d AresdenMap:%d ElvineMap:%d", iActiveStructure, iMapIndex, m_iAresdenMapIndex, m_iElvineMapIndex);
	PutLogList(G_cTxt);

	if (iActiveStructure == 0) {
		// ۵ ǹ . ũ缼̵  : ٸ  ˷ش.
		// ũ缼̵     Ŭ̾Ʈ鿡 ٷ .
		if (iMapIndex == m_iAresdenMapIndex) {
			cWinnerSide = 2;
			LocalEndCrusadeMode(2); // ̱  
		}
		else if (iMapIndex == m_iElvineMapIndex) {
			cWinnerSide = 1;
			LocalEndCrusadeMode(1); // ̱  Ʒ
		}
		else {
			cWinnerSide = 0;
			LocalEndCrusadeMode(0); 
		}
		
		// ٸ  ũ缼̵ Ḧ ˸.
		/*ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_ENDCRUSADE;
		cp++;

		*cp = cWinnerSide;
		cp++;			

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		bStockMsgToGateServer(cData, 18);*/

	}
	else {
		//  Ȳ   Ʈ.
		/*ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_GRANDMAGICRESULT;
		cp++;
		
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD) iActiveStructure;
		cp += 2;*/

		//v2.15 ߰  Ż ǹ  
		ZeroMemory(cTempData, sizeof(cTempData));
		cp2 = (char *)(cTempData); 

		wp = (WORD *)cp2;
		*wp = (WORD) m_pMapList[iMapIndex]->m_iTotalStrikePoints;
		cp2 += 2;

		for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints;i++){
			wp = (WORD *)cp2;
			*wp = (WORD) iStructureHP[i];
			cp2 += 2;
		}

		//memcpy(cp,cTempData,2*(m_pMapList[iMapIndex]->m_iTotalStrikePoints+1) ) ;

		// v2.15 
		//bStockMsgToGateServer(cData, 18 + (m_pMapList[iMapIndex]->m_iTotalStrikePoints+1)*2 );
		
		//    ޽  Ƿ  Ѵ.
		// v2.15 ǹ  HP .
		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure,m_pMapList[iMapIndex]->m_iTotalStrikePoints, cTempData);
	}

	//   Ʈ Ŭ
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;
}

void CGame::_LinkStrikePointMapIndex()
{
 int i, z, x;

	//  ǹ θ ٸ   ũ ҰϹǷ ٿȴ!
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != 0) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
		// Ʈũ Ʈ ǵ ̴.  Ʈũ Ʈ   ε  Ѵ.
		for (z = 0; z < DEF_MAXSTRIKEPOINTS; z++) 
		if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
			for (x = 0; x < DEF_MAXMAPS; x++) 
			if ((m_pMapList[x] != 0) && (strcmp(m_pMapList[x]->m_cName,m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
				// ε ߴ. Ѵ.
				m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
				//testcode
				wsprintf(G_cTxt, "(!) Map(%s) Strike Point(%d) Related Map(%s) Index(%d)", m_pMapList[i]->m_cName, z, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName, x);
				PutLogList(G_cTxt);

				goto LSPMI_LOOPBREAK;
			}
LSPMI_LOOPBREAK:;
		}
	}
}

bool CGame::_bRegisterMap(char * pName)
{
 int i;
 char cTmpName[11], cTxt[120];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != 0) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
		wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) is already installed! cannot add.", cTmpName);
		PutLogList(cTxt);
		return false;
	}

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] == 0) {
		m_pMapList[i] = (class CMap *)new class CMap(this);
		wsprintf(cTxt, "(*) Add map (%s)   - Loading map info files...", pName);
		PutLogList(cTxt);
		if (m_pMapList[i]->bInit(pName) == false) {
			PutLogList("(!!!) Data file loading fail!");
			return false;	
		};
		
		PutLogList("(*) Data file loading success.");
		
		if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0)) 
			m_iMiddlelandMapIndex = i;

		if ((m_iAresdenMapIndex == -1) && (strcmp("aresden", pName) == 0)) 
			m_iAresdenMapIndex = i;

		if ((m_iElvineMapIndex == -1) && (strcmp("elvine", pName) == 0)) 
			m_iElvineMapIndex = i;

		if ((m_iBTFieldMapIndex == -1) && (strcmp("BtField", pName) == 0)) 
			m_iBTFieldMapIndex = i;

		if ((m_iGodHMapIndex == -1) && (strcmp("GodH", pName) == 0)) 
			m_iGodHMapIndex = i;

		m_iTotalMaps++;
		return true;
	}

	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) canot be added - no more map space.", pName);
	PutLogList(cTxt);
	return false;
}

//New Changed 11/05/2004
void CGame::GrandMagicResultHandler(char *cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure, int iTotalStrikePoints, char * cData)
{
 int i;
	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != 0) {
		SendNotifyMsg(0, i, DEF_NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure, 0, 0, 0, 0, iTotalStrikePoints, cData);
	}
}

void CGame::AdminOrder_CheckStats(int iClientH, char *pData,DWORD dwMsgSize)
{
 char cStatMessage[256];
 char   seps[] = "= \t\n";
 char   cBuff[256];
 class  CStrTok * pStrTok;
 char   * token, cName[11], cTargetName[11];
 int i;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}
		if ((dwMsgSize)	<= 0) return;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		
		if (token != 0) {
			ZeroMemory(cName, sizeof(cName));
			strcpy(cName, token);
		} 
		else {
			ZeroMemory(cName, sizeof(cName));
			strcpy(cName, "null");
		}

		token = pStrTok->pGet();
		
		if (token == 0) { 
			token = "null"; 
		}
		
			if (cName != 0) {
			token = cName;

				if (strlen(token) > 10) 
  					memcpy(cTargetName, token, 10);
				else memcpy(cTargetName, token, strlen(token));

				for (i = 1; i < DEF_MAXCLIENTS; i++)
  					if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
						// m_iStr, m_iInt, m_iVit, m_iDex, m_iMag, m_iCharisma
						ZeroMemory(cStatMessage, sizeof(cStatMessage));
						wsprintf(cStatMessage, "Str:%d Dex:%d Vit:%d Int:%d Mag:%d Chr:%d", m_pClientList[i]->m_iStr,  m_pClientList[i]->m_iDex, m_pClientList[i]->m_iVit, m_pClientList[i]->m_iInt,m_pClientList[i]->m_iMag, m_pClientList[i]->m_iCharisma);
						ShowClientMsg(iClientH, cStatMessage);
					}
			}
}

// v2.16 2002-5-21 °í±¤Çö Ãß°¡
bool CGame::bCheckIsItemUpgradeSuccess(int iClientH, int iItemIndex, int iSomH, bool bBonus)
{
	int iValue, iProb, iResult;

	if (m_pClientList[iClientH]->m_pItemList[iSomH] == 0) return false;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x0F0000000) >> 28;

	switch (iValue) {
	case 0: iProb = 30; break;  // +1 :90%     +1~+2
	case 1: iProb = 25; break;  // +2 :80%      +3
	case 2: iProb = 20; break;  // +3 :48%      +4 
	case 3: iProb = 15; break;  // +4 :24%      +5
	case 4: iProb = 10; break;  // +5 :9.6%     +6
	case 5: iProb = 10; break;  // +6 :2.8%     +7
	case 6: iProb =  8; break;  // +7 :0.57%    +8
	case 7: iProb =  8; break;  // +8 :0.05%    +9
	case 8: iProb =  5; break;  // +9 :0.004%   +10
	case 9: iProb =  3; break;  // +10:0.00016%
	default: iProb = 1; break;
	}

	if (((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 > 100)) {	
		if (iProb > 20) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 10);
		else if (iProb > 7) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 20);
		else
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 40);
	}
	if ( bBonus ) iProb *=2 ;

	iProb *= 100;
	iResult = iDice(1,10000);

	if (iProb >= iResult) { 
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
		return true;
	}

	_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

	return false;
}

bool CGame::bReadAdminListConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;
 char len;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == 0) {
		// Ӽ ʱȭ    .
		PutLogList("(!) Cannot open AdminList.cfg file.");
		return false;
	}
	else {
		PutLogList("(!) Reading AdminList.cfg...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != 0 )   {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
						if (iIndex >= DEF_MAXADMINS) {
							PutLogList("(!) WARNING! Too many GMs on the AdminList.cfg!"); 
							return true;
						}
						len = strlen(token);
						if(len > 10) len = 10;
						ZeroMemory(m_stAdminList[iIndex].m_cGMName, sizeof(m_stAdminList[iIndex].m_cGMName));
						memcpy(m_stAdminList[iIndex].m_cGMName, token, strlen(token));
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
				}
			}
			else {
				if (memcmp(token, "verified-admin", 14) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

bool CGame::bReadBannedListConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;
 char len;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == 0) {
		// Ӽ ʱȭ    .
		PutLogList("(!) Cannot open BannedList.cfg file.");
		return false;
	}
	else {
		PutLogList("(!) Reading BannedList.cfg...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != 0 )   {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
						if (iIndex >= DEF_MAXBANNED) {
							PutLogList("(!) WARNING! Too many banned on the BannedList.cfg!"); 
							return true;
						}
						len = strlen(token);
						if(len > 20) len = 20;
						ZeroMemory(m_stBannedList[iIndex].m_cBannedIPaddress, sizeof(m_stBannedList[iIndex].m_cBannedIPaddress));
						memcpy(m_stBannedList[iIndex].m_cBannedIPaddress, token, strlen(token));
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
				}
			}
			else {
				if (memcmp(token, "banned-ip", 9) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

/*void CGame::AdminOrder_CleanMap(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	class  CStrTok * pStrTok;
	char   * token, cMapName[11], cBuff[256];
	bool bFlag = false;	//Used to check if we are on the map we wanna clear
	int i;
	CItem *pItem;
	short sRemainItemSprite, sRemainItemSpriteFrame, dX, dY;
	char cRemainItemColor, len;


	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCleanMap) {
		// Admin user level Ƽ     .
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != 0) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);

		for (i = 0; i < DEF_MAXMAPS; i++)	//Enum all maps
			if (m_pMapList[i] != 0) {	//Is allocated map
				if (memcmp(m_pMapList[i]->m_cName, cMapName, 10) == 0) {	//is map same name
					bFlag = true; //Set flag
					//Get X and Y coords
					int m_x = m_pMapList[i]->m_sSizeX;
					int m_y = m_pMapList[i]->m_sSizeY;
					for(int j = 1; j < m_x; j++)
						for(int k = 1; k < m_y; k++){
							do {	//Delete all items on current tile
								pItem = m_pMapList[i]->pGetItem(j, k, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
								if (pItem != 0) {
									delete pItem;	//Delete item;
								}
							} while(pItem != 0);
						}
					break;	//Break outo f loop
				}
			}

		if (!bFlag) {	//Notify GM he has to be on the map he clears
		}
		else{	//Notify GM that all items have been cleared
			for(int i = 1; i < DEF_MAXCLIENTS; i++){
				if (m_pClientList[i] != 0) {
				len = strlen(cMapName);
				if(len > 10) len = 10;
				if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cMapName, len) != 0) return;
				dX = m_pClientList[i]->m_sX;
				dY = m_pClientList[i]->m_sY;
				ZeroMemory(cMapName,sizeof(cMapName));
				strcpy(cMapName, m_pClientList[i]->m_cMapName);
				RequestTeleportHandler(i,"2   ", cMapName, dX, dY);
				}
			}
		}
	}

	delete pStrTok;
	return;
}*/

void CGame::ShowClientMsg(int iClientH, char* pMsg)
{
	char * cp, cTemp[256];
	DWORD * dwp, dwMsgSize;
	WORD * wp;
	short * sp;

	ZeroMemory(cTemp, sizeof(cTemp));

	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;

	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = 0;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = 0;
	cp += 2;

	sp  = (short *)cp;
	*sp = 0;
	cp += 2;

	memcpy(cp, "HGServer", 8); // Player name :P
	cp += 10;

	*cp = 10; // chat type
	cp++;

	dwMsgSize = strlen(pMsg);
	if(dwMsgSize > 50) dwMsgSize = 50;
	memcpy(cp, pMsg, dwMsgSize);
	cp += dwMsgSize;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
}

void CGame::Command_YellowBall(int iClientH, char* pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cPlayerName[11],cMapName[32];
	class  CStrTok * pStrTok;
	char *cp;
	WORD *wp;
	int iSoxH, iSoX, i;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize)	<= 0) return;

	iSoX = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
		switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
		case 653: iSoX++; iSoxH = i; break; //    
		}
	}
	if (iSoX > 0) {	
		
		ZeroMemory(cPlayerName, sizeof(cPlayerName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		if (token == 0) {
			delete pStrTok;
			return;
		}

		if (strlen(token) > 10) {
			memcpy(cPlayerName,token,10);
		}
		else{
			memcpy(cPlayerName,token,strlen(token));
		}

		for(int i = 1; i < DEF_MAXCLIENTS; i++){
			if (m_pClientList[i] != 0) {
				if (memcmp(cPlayerName,m_pClientList[i]->m_cCharName,10) == 0) {
					if ((m_pClientList[iClientH]->m_cLocation) != (m_pClientList[i]->m_cLocation)) return;
					ZeroMemory(cMapName,sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					wsprintf(G_cTxt, "(%s) Player: (%s) - YellowBall MapName(%s)(%d %d)", m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName,m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
					PutItemLogFileList(G_cTxt);
					ItemDepleteHandler(iClientH, iSoxH, true);
					RequestTeleportHandler(iClientH,"2   ", cMapName, m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
					delete pStrTok;
					return;
				}
			}
		}
		m_pClientList[iClientH]->m_bIsAdminOrderGoto = true;

		/*ZeroMemory(cBuff,sizeof(cBuff));
		
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_FINDCHARACTER;
		cp++;

		wp = (WORD *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;

		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp,cPlayerName,10);
		cp += 10;

		memcpy(cp,m_pClientList[iClientH]->m_cCharName,10);
		cp += 10;

		bStockMsgToGateServer(cBuff,25);*/

		delete pStrTok;
	}
}

void CGame::Command_RedBall(int iClientH, char *pData,DWORD dwMsgSize)
{
 char seps[] = "= \t\n", cName[21], cNpcName[21], cNpcWaypoint[11];	
 int iNamingValue, tX, tY, i, x, iNpcID;
 int iSoxH, iSoX;
    
	if (m_pClientList[iClientH] == 0) return;
	if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone1", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone2", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone3", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone4", 9) != 0)) return;
		     
	    iSoX = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 652: iSoX++; iSoxH = i; break; //    
			}
		}
		if (iSoX > 0) {			
			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
		
			}
			else {
		
				ZeroMemory(cNpcName, sizeof(cNpcName));
				switch (iDice(1,5)) {
					case 1: strcpy(cNpcName, "Wyvern"); iNpcID = 66; break; 
					case 2: strcpy(cNpcName, "Hellclaw"); iNpcID = 49; break;
					case 3: strcpy(cNpcName, "Fire-Wyvern"); iNpcID = 73; break;
					case 4: strcpy(cNpcName, "Tigerworm"); iNpcID = 50; break;
					case 5: strcpy(cNpcName, "Gagoyle"); iNpcID = 52; break;
				}
				ZeroMemory(cName, sizeof(cName));
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;

				ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
					DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, 0, 0, -1, false, false) == false) {
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					wsprintf(G_cTxt, "(%s) Player: (%s) - RedBall used %s [%s(%d, %d)] ", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cNpcName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, tX, tY );
					PutItemLogFileList(G_cTxt);
				}
			}

		for (x = 1; x < DEF_MAXCLIENTS; x++)
		if ((m_pClientList[x] != 0) && (m_pClientList[x]->m_bIsInitComplete )) {
			SendNotifyMsg(0, x, DEF_NOTIFY_SPAWNEVENT, tX, tY, iNpcID, 0, 0, 0);
		}
		ItemDepleteHandler(iClientH, iSoxH, true);
		}
}

void CGame::Command_BlueBall(int iClientH, char *pData,DWORD dwMsgSize)

{
 char seps[] = "= \t\n";
 char   cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA; 
 int    pX, pY, j, iNum, iNamingValue, iNpcID;
 int i, x;
 bool   bMaster;
 int iSoxH, iSoX;
    
	if (m_pClientList[iClientH] == 0) return;
	if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone1", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone2", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone3", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone4", 9) != 0)) return;

		     
	    iSoX = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 654: iSoX++; iSoxH = i; break; //    
			}
		}
		if (iSoX > 0) {			
			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
		
			}
			else {
		
				ZeroMemory(cNpcName, sizeof(cNpcName));

				switch (iDice(1,38)) {
					case 1: strcpy(cNpcName, "Slime");			iNpcID = 10; break;
					case 2: strcpy(cNpcName, "Giant-Ant");		iNpcID = 15; break;
					case 3: strcpy(cNpcName, "Zombie");			iNpcID = 17; break;
					case 4: strcpy(cNpcName, "Scorpion");		iNpcID = 16; break;
					case 5: strcpy(cNpcName, "Skeleton");		iNpcID = 11; break;
					case 6: strcpy(cNpcName, "Orc-Mage");		iNpcID = 14; break;
					case 7: strcpy(cNpcName, "Clay-Golem");		iNpcID = 23; break;
					case 8: strcpy(cNpcName, "Stone-Golem");	iNpcID = 12; break;
					case 9: strcpy(cNpcName, "Hellbound");		iNpcID = 27; break;
					case 10: strcpy(cNpcName, "Giant-Frog");	iNpcID = 57; break;
					case 11: strcpy(cNpcName, "Troll");			iNpcID = 28; break;
					case 12: strcpy(cNpcName, "Cyclops");		iNpcID = 13; break;
					case 13: strcpy(cNpcName, "Ice-Golem");		iNpcID = 65; break;
					case 14: strcpy(cNpcName, "Beholder");		iNpcID = 53; break;
					case 15: strcpy(cNpcName, "Cannibal-Plant");iNpcID = 60; break;
					case 16: strcpy(cNpcName, "Orge");			iNpcID = 29; break;
			        case 17: strcpy(cNpcName, "Mountain-Giant");iNpcID = 58; break;
                    case 18: strcpy(cNpcName, "DireBoar");		iNpcID = 62; break;
			        case 19: strcpy(cNpcName, "Liche");			iNpcID = 30; break;
				    case 20: strcpy(cNpcName, "Stalker");		iNpcID = 48; break;
                    case 21: strcpy(cNpcName, "WereWolf");		iNpcID = 33; break;
				    case 22: strcpy(cNpcName, "Dark-Elf");		iNpcID = 54; break;
				    case 23: strcpy(cNpcName, "Frost");			iNpcID = 63; break;
					case 24: strcpy(cNpcName, "Orc");			iNpcID = 14; break;
					case 25: strcpy(cNpcName, "Ettin");			iNpcID = 59; break;
					case 26: strcpy(cNpcName, "Tentocle");		iNpcID = 80; break;
					case 27: strcpy(cNpcName, "Giant-Crayfish");iNpcID = 74; break;
					case 28: strcpy(cNpcName, "Giant-Plant");	iNpcID = 76; break;
					case 29: strcpy(cNpcName, "Rudolph");		iNpcID = 61; break;
					case 30: strcpy(cNpcName, "Claw-Turtle");	iNpcID = 72; break;
					case 31: strcpy(cNpcName, "Centaurus");		iNpcID = 71; break;
					case 32: strcpy(cNpcName, "Barlog");		iNpcID = 70; break;
					case 33: strcpy(cNpcName, "Giant-Lizard");	iNpcID = 75; break;
					case 34: strcpy(cNpcName, "MasterMage-Orc");iNpcID = 77; break;
					case 35: strcpy(cNpcName, "Minotaurs");		iNpcID = 78; break;
					case 36: strcpy(cNpcName, "Unicorn");		iNpcID = 32; break;
					case 37: strcpy(cNpcName, "Nizie");			iNpcID = 79; break;
				}

				iNum = 10;
	cSA = 0;
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;

	wsprintf(G_cTxt, "(!) BlueBallEvent: SummonMob (%s)-(%d)", cNpcName, iNum);
	PutLogList(G_cTxt);

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {
	
		ZeroMemory(cName_Master, sizeof(cName_Master));
		wsprintf(cName_Master, "XX%d", iNamingValue);
		cName_Master[0] = '_';
		cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
		if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false, true)) == false) {
		
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
	}		

	for (j = 0; j < (iNum - 1); j++) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// Slave Mob
			ZeroMemory(cName_Slave, sizeof(cName_Slave));
			wsprintf(cName_Slave, "XX%d", iNamingValue);
			cName_Slave[0] = '_';
			cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
		
				
			if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false) == false) {
		
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				// Slave
				bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
			}
		}
	}

	//delete pStrTok;

				}
			}

		for (x = 1; x < DEF_MAXCLIENTS; x++)
		if ((m_pClientList[x] != 0) && (m_pClientList[x]->m_bIsInitComplete )) {
			SendNotifyMsg(0, x, DEF_NOTIFY_SPAWNEVENT, pX, pY, iNpcID, 0, 0, 0);
		}
		ItemDepleteHandler(iClientH, iSoxH, true);
}


/*
at the end of client connection have a true switch
at the start of client move handler check if the switch is true
if it is not true add 1 warning, if the warning reaches 3
delete client and log him, if the true switch
*/
//and when a client walks into a map with dynamic portal
//[KLKS] - [Pretty Good Coders] says:
//u gotta inform it
//[KLKS] - [Pretty Good Coders] says:
//or else they wont see it

/*void CGame::OpenApocalypseGate(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	//m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAliveObject;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_APOCGATEOPEN, 95, 31, 0, m_pClientList[iClientH]->m_cMapName);
}*/

void CGame::GlobalEndApocalypseMode()
{
 //char * cp, cData[120];

	if (m_bIsApocalypseMode == false) return;

	/*ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_ENDAPOCALYPSE;
	cp++;*/
	
	LocalEndApocalypse();

	//bStockMsgToGateServer(cData, 5);
}

void CGame::GlobalUpdateConfigs(char cConfigType)
{
 /*char * cp, cData[120];

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_UPDATECONFIGS;
	cp++;

	*cp = (char)cConfigType;
	cp++;*/			

	LocalUpdateConfigs(cConfigType);

	//bStockMsgToGateServer(cData, 5);
}

void CGame::LocalUpdateConfigs(char cConfigType)
{
	if (cConfigType == 1) {
		bReadSettingsConfigFile("GameConfigs\\Settings.cfg");
		PutLogList("(!!!) Settings.cfg updated successfully!");
	}
	if (cConfigType == 2) {
		bReadAdminListConfigFile("GameConfigs\\AdminList.cfg");
		PutLogList("(!!!) AdminList.cfg updated successfully!");
	}
	if (cConfigType == 3) {
		bReadBannedListConfigFile("GameConfigs\\BannedList.cfg");
		PutLogList("(!!!) BannedList.cfg updated successfully!");
	}
	if (cConfigType == 4) {
		bReadAdminSetConfigFile("GameConfigs\\AdminSettings.cfg");
		PutLogList("(!!!) AdminSettings.cfg updated successfully!");
	}
}

void CGame::LocalEndApocalypse()
{
 int i;
	
	m_bIsApocalypseMode = false;

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
	if (m_pClientList[i] != 0) {		
			SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATEENDMSG, 0, 0, 0, 0);
		}
	}
	wsprintf(G_cTxt,"(!)Apocalypse Mode OFF.");
	PutLogList(G_cTxt);
}

void CGame::LocalStartApocalypse(DWORD dwApocalypseGUID)
{
 int i;
 //DWORD dwApocalypse;

	m_bIsApocalypseMode = true;

	if (dwApocalypseGUID != 0) {
		_CreateApocalypseGUID(dwApocalypseGUID);
		//m_dwApocalypseGUID = dwApocalypse;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
	if (m_pClientList[i] != 0) {		
			SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATESTARTMSG, 0, 0, 0, 0);		
			//RequestTeleportHandler(i, "0   ");
			//SendNotifyMsg(0, i, DEF_NOTIFY_APOCFORCERECALLPLAYERS, 0, 0, 0, 0);
		}
	}
	wsprintf(G_cTxt,"(!)Apocalypse Mode ON.");
	PutLogList(G_cTxt);
}

bool CGame::bReadApocalypseGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open ApocalypseGUID file.");
		return false;
	}
	else {
		PutLogList("(!) Reading ApocalypseGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != 0 )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwApocalypseGUID = atoi(token);
					wsprintf(G_cTxt, "ApocalypseGUID = %d", m_dwApocalypseGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "ApocalypseGUID", 14) == 0) cReadMode = 1;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

bool CGame::bReadHeldenianGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open HeldenianGUID file.");
		return false;
	}
	else {
		PutLogList("(!) Reading HeldenianGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != 0 )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwHeldenianGUID = atoi(token);
					wsprintf(G_cTxt, "HeldenianGUID = %d", m_dwHeldenianGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				case 2:
					m_sLastHeldenianWinner = atoi(token);
					wsprintf(G_cTxt, "HeldenianWinnerSide = %d", m_sLastHeldenianWinner);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "HeldenianGUID", 13) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

void CGame::_CreateApocalypseGUID(DWORD dwApocalypseGUID)
{
 char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;
		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"ApocalypseGUID.Txt");
		
	pFile = fopen(cFn, "wt");
	if (pFile == 0) {
		// ÆÄÀÏÀ» ¸¸µé ¼ö ¾ø°Å³ª »çÀÌÁî°¡ Áö³ªÄ¡°Ô ÀÛÀº °æ¿ì´Â . 
		wsprintf(cTxt, "(!) Cannot create ApocalypseGUID(%d) file", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "ApocalypseGUID = %d\n", dwApocalypseGUID);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) ApocalypseGUID(%d) file created", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	if (pFile != 0) fclose(pFile);
}

/*void CGame::ApocalypseStarter()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bIsApocalypseMode ) return;
	if (m_bIsApocalypseStarter == false) return;

	GetLocalTime(&SysTime);
	
	for (i = 0; i < DEF_MAXAPOCALYPSE; i++)
	if	((m_stApocalypseScheduleStart[i].iDay == SysTime.wDayOfWeek) && 
		(m_stApocalypseScheduleStart[i].iHour == SysTime.wHour) && 
		(m_stApocalypseScheduleStart[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated apocalypse is initiated!");
			GlobalStartApocalypseMode();
			return;
	}
}*/

void CGame::ApocalypseEnder()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bIsApocalypseMode == false) return;
	if (m_bIsApocalypseStarter == false) return;

	GetLocalTime(&SysTime);
	
	for (i = 0; i < DEF_MAXAPOCALYPSE; i++)
	if	((m_stApocalypseScheduleEnd[i].iDay == SysTime.wDayOfWeek) && 
		(m_stApocalypseScheduleEnd[i].iHour == SysTime.wHour) && 
		(m_stApocalypseScheduleEnd[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated apocalypse is concluded!");
			GlobalEndApocalypseMode();
			return;
	}
}	

// New 06/05/2004
// Party Code
void CGame::RequestCreatePartyHandler(int iClientH)
{
	char *cp, cData[120];
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) {
		// ÆÄÆ¼ »óÅÂ°¡ ÀÌ¹Ì Á¸ÀçÇÏ¸é ÆÄÆ¼¸¦ ¸¸µé ¼ö ¾ø´Ù.
		return;
	}

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;

	// Gate Server¿¡ ÆÄÆ¼ »ý¼ºÈÄ PartyID¸¦ ¾Ë·ÁÁÙ °ÍÀ» ¿äÃ»ÇÑ´Ù. 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;

	/*dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;*/
	wp = (WORD*)cp;
	*wp = 1; // 1, request
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;

	PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	//testcode
	wsprintf(G_cTxt, "Request Create Party: %d", iClientH);
	PutLogList(G_cTxt);
}

// Last Updated October 28, 2004 - 3.51 translation
void CGame::PartyOperationResultHandler(char *pData)
{
	char * cp, cResult, cName[12];
	WORD * wp;
	int i, iClientH, iPartyID, iTotal;

	cp = (char *)(pData);
	wp = (WORD *)cp;
	cp += 2;

	switch (*wp) {
	case 1:
		cResult = *cp;
		cp++;

		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Create(iClientH, cName, cResult, iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Create(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 2:
		wp = (WORD *)cp;
		iPartyID = *wp;
		cp += 2;

		PartyOperationResult_Delete(iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Delete(PartyID:%d)", iPartyID);
		PutLogList(G_cTxt);
		break;

	case 3:
		wp = (WORD *)cp;
		iClientH = *wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		if ((iClientH < 0) && (iClientH > DEF_MAXCLIENTS)) return;
		if (m_pClientList[iClientH] == 0) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, cName) != 0) return;

		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;

				wsprintf(G_cTxt, "PartyID:%d member:%d Out(Clear) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORH_LOOPBREAK1;
			}
PORH_LOOPBREAK1:

				for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
				if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] != 0)) {
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i]   = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1];
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] = 0;
				}

				m_pClientList[iClientH]->m_iPartyID = 0;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;

				wsprintf(G_cTxt, "Party Status 0: %s", m_pClientList[iClientH]->m_cCharName);
				PutLogList(G_cTxt);

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 8, 0, 0, 0);
				break;

	case 4:
		cResult = *cp;
		cp++;

		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Join(iClientH, cName, cResult, iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Join(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 5:
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iTotal = (int)*wp;
		cp += 2;

		PartyOperationResult_Info(iClientH, cName, iTotal, cp);

		wsprintf(G_cTxt, "party Operation Result: Info(ClientH:%d Total:%d)", iClientH, iTotal);
		PutLogList(G_cTxt);
		break;

	case 6:
		cResult = *cp;
		cp++;

		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Dismiss(iClientH, cName, cResult, iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Dismiss(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;
	}
}


void CGame::PartyOperationResult_Create(int iClientH, char *pName, int iResult, int iPartyID)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	int i;

	if (m_pClientList[iClientH] == 0) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

	switch (iResult) {
	case 0: // ÆÄÆ¼ »ý¼º ½ÇÆÐ 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = 0;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 1, 0, 0, 0);
		break;

	case 1: // ÆÄÆ¼ »ý¼º ¼º°ø 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 1, 1, 0, 0);

		// °ÔÀÓ ¼­¹öÀÇ ÆÄÆ¼ ¸®½ºÆ®¿¡ µî·Ï.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
				//testcode
				wsprintf(G_cTxt, "PartyID:%d member:%d New Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK1;
			}
PORC_LOOPBREAK1:

			// ¸¸¾à ÆÄÆ¼ °¡ÀÔÀ» ½ÅÃ»ÇÑ ÇÃ·¹ÀÌ¾î°¡ ÀÖ´Ù¸é 
			if ((m_pClientList[iClientH]->m_iReqJoinPartyClientH != 0) && (strlen(m_pClientList[iClientH]->m_cReqJoinPartyName) != 0)) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				/*dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;*/
				wp = (WORD*)cp;
				*wp = 3; // ÆÄÆ¼ ¸â¹ö Ãß°¡ ¿äÃ»
				cp += 2;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
				cp += 2;
				memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
				PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
				// ¸Þ½ÃÁö¸¦ º¸³ÂÀ¸´Ï Å¬¸®¾î
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
				ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			}
			break;
	}
}

// Last Updated October 28, 2004 - 3.51 translation
void CGame::PartyOperationResult_Join(int iClientH, char *pName, int iResult, int iPartyID)
{
	int i;

	if (m_pClientList[iClientH] == 0) return;

	switch (iResult) {
	case 0:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = 0;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 4, 0, 0, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 4, 1, 0, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));

		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;

				wsprintf(G_cTxt, "PartyID:%d member:%d In(Join) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK1;
			}
PORC_LOOPBREAK1:

			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((i != iClientH) && (m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 4, 1, 0, pName);
				}
				break;
	}
}

void CGame::PartyOperationResult_Dismiss(int iClientH, char *pName, int iResult, int iPartyID)
{
	int i;
	// iClientH´Â ÀÌ¹Ì »ç¶óÁö°í ¾ø´Â Ä³¸¯ÅÍÀÏ¼öµµ ÀÖ´Ù.

	switch (iResult) {
	case 0: // ÆÄÆ¼ Å»Åð ½ÇÆÐ ? ÀÌ·± ÀÏÀÌ?
		break;

	case 1: // ÆÄÆ¼ Å»Åð ¼º°ø 
		if (iClientH == 0) {
			// iClientH °¡ NULLÀÌ¸é ¼­¹ö ÀÌµ¿Áß Á¢¼Ó Á¾·áµÇ¾î °­Á¦ Á¦°Å ¿äÃ»µÈ °ÍÀÓ.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
					iClientH = i;
					goto PORD_LOOPBREAK;
				}
PORD_LOOPBREAK:

				// °ÔÀÓ ¼­¹öÀÇ ÆÄÆ¼ ¸®½ºÆ®¿¡¼­ ÇØÁ¦.
				for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
					if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
						m_stPartyInfo[iPartyID].iIndex[i] = 0;
						m_stPartyInfo[iPartyID].iTotalMembers--;
						//testcode
						wsprintf(G_cTxt, "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
						PutLogList(G_cTxt);
						goto PORC_LOOPBREAK1;
					}
PORC_LOOPBREAK1:
					// ¸®½ºÆ® ÀÎµ¦½ºÀÇ ºó°ø°£À» Á¦°ÅÇÑ´Ù.
					for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
						if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
							m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
							m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
						}

						if (m_pClientList[iClientH] != 0) {
							m_pClientList[iClientH]->m_iPartyID = 0;
							m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
							m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
						}

						// ¸ðµç ÆÄÆ¼¿øµé¿¡°Ô ¾Ë·ÁÁØ´Ù.
						for (i = 1; i < DEF_MAXCLIENTS; i++)
							if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
								SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 6, 1, 0, pName);
							}
							return;
		}

		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING)) return;
		if ((m_pClientList[iClientH] != 0) && (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0)) return;

		// ¸ðµç ÆÄÆ¼¿øµé¿¡°Ô ¾Ë·ÁÁØ´Ù.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
				SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 6, 1, 0, pName);
			}

			// °ÔÀÓ ¼­¹öÀÇ ÆÄÆ¼ ¸®½ºÆ®¿¡¼­ ÇØÁ¦.
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
				if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
					m_stPartyInfo[iPartyID].iIndex[i] = 0;
					m_stPartyInfo[iPartyID].iTotalMembers--;
					//testcode
					wsprintf(G_cTxt, "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
					PutLogList(G_cTxt);
					goto PORC_LOOPBREAK2;
				}
PORC_LOOPBREAK2:
				// ¸®½ºÆ® ÀÎµ¦½ºÀÇ ºó°ø°£À» Á¦°ÅÇÑ´Ù.
				for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
					if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
						m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
						m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
					}

					if (m_pClientList[iClientH] != 0) {
						m_pClientList[iClientH]->m_iPartyID = 0;
						m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
						m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
					}
					break;
	}
}

void CGame::PartyOperationResult_Delete(int iPartyID)
{
	int i;

	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
	{
		m_stPartyInfo[iPartyID].iIndex[i] = 0;
		m_stPartyInfo[iPartyID].iTotalMembers = 0;
	}

	// ÆÄÆ¼ ÇØ»êµÊ 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
			SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 2, 0, 0, 0);
			m_pClientList[i]->m_iPartyID = 0;
			m_pClientList[i]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[i]->m_iReqJoinPartyClientH = 0;
			//testcode
			wsprintf(G_cTxt, "Notify delete party: %d", i);
			PutLogList(G_cTxt);
		}
}



void CGame::RequestJoinPartyHandler(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * cp, * token, cBuff[256], cData[120], cName[12];
	class  CStrTok * pStrTok;
	DWORD * dwp;
	WORD  * wp;
	int i;

	// ÆÄÆ¼ °¡ÀÔ ¿©ºÎ¸¦ ¹¯°í ÀÖ´Ù.
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if ((m_bAdminSecurity ) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token != 0) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	}
	else return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
			// °ÔÀÌÆ® ¼­¹ö·Î ÆÄÆ¼ ¸â¹ö °¡ÀÔÀ» ½ÅÃ»ÇÑ´Ù.
			if ((m_pClientList[i]->m_iPartyID == 0) || (m_pClientList[i]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM)) {
				// ÆÄÆ¼¿¡ °¡ÀÔÇÏ°íÀÚ ÇÑ Ä³¸¯ÅÍ°¡ ÆÄÆ¼ ¸¶½ºÅÍ°¡ ¾Æ´Ï´Ù.
				return;
			}

			ZeroMemory(cData, sizeof(cData));
			
			cp = (char *)cData;
			/*dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;*/
			wp = (WORD*)cp;
			*wp = 3; // ÆÄÆ¼ ¸â¹ö Ãß°¡ ¿äÃ»
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_iPartyID;
			cp += 2;
			PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			return;
		}

		// °¡ÀÔÇÏ°íÀÚ ÇÏ´Â ÆÄÆ¼ ¸¶½ºÅÍ°¡ ÇöÀç ¼­¹ö¿¡ Á¸ÀçÇÏÁö ¾Ê´Â´Ù.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cName);
}



void CGame::RequestDismissPartyHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD  * wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	/*dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;*/
	wp = (WORD*)cp;
	*wp = 4; // ¸â¹ö Á¦°Å ¿äÃ»
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
}


void CGame::GetPartyInfoHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD  * wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	/*dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;*/
	wp = (WORD*)cp;
	*wp = 5; // ÆÄÆ¼ Á¤º¸ ¿äÃ»
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
}


void CGame::PartyOperationResult_Info(int iClientH, char * pName, int iTotal, char *pNameList)
{
	if (m_pClientList[iClientH] == 0) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 5, 1, iTotal, pNameList);
}

void CGame::RequestDeletePartyHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyID != 0) {
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		/*dwp = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;*/
		wp = (WORD*)cp;
		*wp = 4; // ¸â¹ö Á¦°Å ¿äÃ»
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_iPartyID;
		cp += 2;
		PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		// »óÅÂ º¯È¯
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
	}
}

void CGame::RequestAcceptJoinPartyHandler(int iClientH, int iResult)
{
	char *cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	int iH;

	if (m_pClientList[iClientH] == 0) return;

	switch (iResult) {
	case 0: // ÆÄÆ¼ °¡ÀÔ ½ÅÃ» °ÅºÎµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù.
		iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
		if (m_pClientList[iH] == 0) {
			// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
			return;
		}
		if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
			// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
			return;
		}
		if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
			// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾îÀÇ »óÅÂ°¡ º¯°æµÇ¾ú´Ù.
			return;
		}
		if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
			// °¡ÀÔÀ» ½ÅÃ»Çß´ø ±×¶§ ±× ÇÃ·¹ÀÌ¾î°¡ ¾Æ´Ï´Ù.
			return;
		}

		SendNotifyMsg(0, iH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
		//testcode
		wsprintf(G_cTxt, "Party join reject(3) ClientH:%d ID:%d", iH, m_pClientList[iH]->m_iPartyID);
		PutLogList(G_cTxt);

		m_pClientList[iH]->m_iPartyID = 0;
		m_pClientList[iH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iH]->m_iReqJoinPartyClientH = 0;
		ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: // ÆÄÆ¼ °¡ÀÔ ½ÅÃ» ½ÂÀÎ
		if ((m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && (m_pClientList[iClientH]->m_iPartyID != 0)) {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == 0) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾îÀÇ »óÅÂ°¡ º¯°æµÇ¾ú´Ù.
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ±×¶§ ±× ÇÃ·¹ÀÌ¾î°¡ ¾Æ´Ï´Ù.
				return;
			}

			// °¡ÀÔ Ã³¸® ÇÑ´Ù.
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			/*dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;*/
			wp = (WORD*)cp;
			*wp = 3; // ÆÄÆ¼ ¸â¹ö Ãß°¡ ¿äÃ»
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			PartyOperation(cData); //SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		else {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == 0) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾î°¡ ¼­¹ö»ó¿¡ ¾ø´Ù.
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ÇÃ·¹ÀÌ¾îÀÇ »óÅÂ°¡ º¯°æµÇ¾ú´Ù.
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				// °¡ÀÔÀ» ½ÅÃ»Çß´ø ±×¶§ ±× ÇÃ·¹ÀÌ¾î°¡ ¾Æ´Ï´Ù.
				return;
			}

			if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL) {
				// ½ÅÃ» ¹ÞÀº ÇÃ·¹ÀÌ¾î°¡ ¾Æ¹«·± ÆÄÆ¼¿¡µµ °¡ÀÔÇÏ°í ÀÖÁö ¾Ê´Ù. ÀÌ Ä³¸¯ÅÍ¸¦ ÆÄÆ¼ ¸¶½ºÅÍ·Î ½ÅÃ»ÇÑ´Ù.
				RequestCreatePartyHandler(iClientH);
			}
			else {
				// Ã³¸® ºÒ°¡
			}
		}
		break;

	case 2: // ÆÄÆ¼ °¡ÀÔ ½ÅÃ» Ãë¼Ò
		// ÀÌ ¸Þ½ÃÁö¸¦ ¹Þ±â Àü¿¡ ÀÌ¹Ì ÆÄÆ¼¿¡ °¡ÀÔµÇ¾ú´Ù¸é Å»Åð Ã³¸®¸¦ ÇÑ´Ù.
		if ((m_pClientList[iClientH]->m_iPartyID != 0) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
			// ¸â¹ö Á¦°Å¸¦ ¿äÃ»ÇÑ´Ù.
			RequestDismissPartyHandler(iClientH);
		}
		else {
			// °¡ÀÔ ½ÅÃ» »óÅÂ¿´´ø °ªµéÀ» ÃÊ±âÈ­ ÇÑ´Ù.
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;

			// ½ÅÃ»Çß´ø Ä³¸¯ÅÍ°¡ Á¢¼ÓÀ» ²÷Àº »óÅÂ¶ó¸é NULLÀÏ ¼ö ÀÖ´Ù.
			if ((m_pClientList[iH] != 0) && (m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH) && 
				(strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) == 0)) {
					// ½ÅÃ»Çß´ø Ä³¸¯ÅÍÀÇ ÆÄÆ¼ ¾ÆÀÌµð¿Í »óÅÂ´Â °Çµå¸®Áö ¾Ê´Â´Ù.
					m_pClientList[iH]->m_iReqJoinPartyClientH = 0;
					ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));
				}

				m_pClientList[iClientH]->m_iPartyID = 0;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
				ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

void CGame::PartyOperation(char* pData)
{
	char* cp, cName[12], cData[120];
	WORD* wp, wRequestType;
	int iGSCH, iPartyID;
	bool bRet;

	cp = (char*)pData;

	wp = (WORD*)cp;
	wRequestType = *wp;
	cp += 2;

	wp = (WORD*)cp;
	iGSCH = (WORD)*wp;
	cp += 2;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	wp = (WORD*)cp;
	iPartyID = (WORD)*wp;
	cp += 2;

	//testcode
	wsprintf(G_cTxt, "Party Operation Type: %d Name: %s PartyID:%d", wRequestType, cName, iPartyID);
	PutLogList(G_cTxt);

	ZeroMemory(cData, sizeof(cData));
	cp = (char*)cData;
	wp = (WORD*)cp;

	switch (wRequestType) {
	case 1: // Ƽ  û 
		iPartyID = m_pPartyManager->iCreateNewParty(cName);

		// Ƽ  ! 
		*wp = 1; // Ƽ   û  ̴.
		cp += 2;
		*cp = (int)!(iPartyID == 0); //   
		cp++;
		wp = (WORD*)cp;
		*wp = iGSCH;
		cp += 2;
		memcpy(cp, cName, 10);
		cp += 10;
		wp = (WORD*)cp;
		*wp = (WORD)iPartyID;
		cp += 2;

		PartyOperationResultHandler(cData);
		break;

	case 2: // Ƽ ػ û 
		break;

	case 3: //  ߰ û
		bRet = m_pPartyManager->bAddMember(iPartyID, cName);

		//  ߰ 
		*wp = 4; //  ߰  ̴.
		cp += 2;
		*cp = (int)bRet; // ߰  
		cp++;
		wp = (WORD*)cp;
		*wp = iGSCH;
		cp += 2;
		memcpy(cp, cName, 10);
		cp += 10;
		wp = (WORD*)cp;
		*wp = (WORD)iPartyID;
		cp += 2;

		PartyOperationResultHandler(cData);
		break;

	case 4: //   û
		bRet = m_pPartyManager->bRemoveMember(iPartyID, cName);

		//   
		*wp = 6; //  ſ  ̴.
		cp += 2;
		*cp = (int)bRet; //   
		cp++;
		wp = (WORD*)cp;
		*wp = iGSCH;
		cp += 2;
		memcpy(cp, cName, 10);
		cp += 10;
		wp = (WORD*)cp;
		*wp = (WORD)iPartyID;
		cp += 2;

		PartyOperationResultHandler(cData);
		break;

	case 5: // Ƽ  Ȯ û.  ̵ ¸ ŬѴ.
		m_pPartyManager->bCheckPartyMember(iGSCH, iPartyID, cName);
		break;

	case 6: // Ƽ   û. Ƽ    ̸ ˷ش.
		m_pPartyManager->bGetPartyInfo(iGSCH, cName, iPartyID);
		break;

	case 7: //   ̵  ȯ: ̰ õ   ð  Ȯ ȵǸ Ƽ Ѵ.
		m_pPartyManager->SetServerChangeStatus(cName, iPartyID);
		break;
	}
}

// v2.16 2002-5-21 °í±¤Çö¼öÁ¤ : ÇÔ¼ö ¸ðµÎ º¯°æµÊ 
void CGame::RequestItemUpgradeHandler(int iClientH, int iItemIndex)
{
	int i, iItemX,iItemY, iSoM, iSoX, iSomH, iSoxH, iValue; // v2.172
	DWORD dwTemp, dwSWEType;
	double dV1, dV2, dV3;
	short sItemUpgrade = 2;

	//hbest
	int bugint = 0;

	if (m_pClientList[iClientH] == 0) return;
	if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
	if (iValue >= 15 || iValue < 0 ) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, 0, 0, 0);
		return;
	}

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
	case 46: // Pendants are category 46
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType != 1)
		{
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are type 1
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cEquipPos < 11)
		{
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are left finger or more
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType != 14)
		{
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are EffectType 14
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectValue1) {
		default: // Other items are not upgradable
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are EffectType 14

		case 16: // AngelicPandent(STR)
		case 17: // AngelicPandent(DEX)
		case 18: // AngelicPandent(INT)
		case 19: // AngelicPandent(MAG)
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}
			if (iValue >= 10)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}
			switch (iValue) {
			case 0:	sItemUpgrade = 10; break;
			case 1: sItemUpgrade = 11; break;
			case 2: sItemUpgrade = 13; break;
			case 3: sItemUpgrade = 16; break;
			case 4: sItemUpgrade = 20; break;
			case 5: sItemUpgrade = 25; break;
			case 6: sItemUpgrade = 31; break;
			case 7: sItemUpgrade = 38; break;
			case 8: sItemUpgrade = 46; break;
			case 9: sItemUpgrade = 55; break;
			default:
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
				break;
			}
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1)
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2)
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
				return;
			}
			if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}
			int iDicePTA = iDice(1, 100);
			if (iDicePTA <= 70)
			{
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);
				iValue++;
				if (iValue > 10) iValue = 10;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			}
			else
			{
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
			}
			return;
			break;
		}
		break;

	case 1: // weapons upgrade
			switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
				case 703: // »ó¾îÀÇ ÇÃ·¥¹ö±× 
				case 709: // DarkKnightFlameberge 
				case 718: // DarkKnightGreatSword
				case 727: // DarkKnightFlamebergW
				case 736: // »õ·Î¿î »ó¾îÀÇ ÀÚÀÌ¾ðÆ®¼Òµå
				case 737: // DarkKnightAxe
				case 745: // DarkKnightHammer
					if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
					{ 
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0); // ÇÊ¿äÇÑ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ¼öÄ¡°¡ ¾ø½À´Ï´Ù.
						return; 
					}
					// ¾ÆÀÌÅÛ ·¹º§¾÷ÀÌ ³ô¾ÆÁú¼ö·Ï ¾ÆÀÌÅÛ ·¹º§¾÷ÇÏ±â°¡ ¾î·Æ´Ù.
					// v2.15 ÁöÁ¸ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå °ø½Ä x(x+6)/8 +2 

					sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;

					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
					{
						if (iValue != 0) {
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
							return; 
						}
					}

					if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
					{ 
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0); // ÇÊ¿äÇÑ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ¼öÄ¡°¡ ¾ø½À´Ï´Ù.
						return; 
					}

					m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade ; 

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

					if((iValue == 0) && m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 703) 
					{
						iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
						iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

						// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

						m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

						if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 709) == false) {
							// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
							return;
						}

						// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

						iValue += 1;
						if (iValue > 15) iValue = 15;
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

						SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
						_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						break ;

					} 
					else if( (iValue == 0) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 709) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 709))) 
					{

						iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
						iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

						// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

						m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

						if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 709) == false) {
							// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
							return;
						}

						// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

						iValue += 1;
						if (iValue > 15) iValue = 15;
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

						SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;

						_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						break;
					} else if( (iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 745)) 
					{

						iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
						iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

						// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

						m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

						if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 745) == false) {
							// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
							return;
						}

						// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

						iValue += 1;
						if (iValue > 15) iValue = 15;
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

						SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;

						_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						break;
					} else if( (iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 737)) 
					{

						iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
						iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

						// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

						m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

						if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 737) == false) {
							// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
							return;
						}

						// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

						iValue += 1;
						if (iValue > 15) iValue = 15;
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

						SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;

						_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						break;
					} else 
					{
						iValue += 1;
						if (iValue > 15) iValue = 15;
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
						_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					}
					break;

				default:

					// v2.16 2002-5-21 °í±¤Çö¼öÁ¤
					// °í´ëÀÇ~ Á¢µÎ»ç°¡ ºÙ´Â ¹«±â´Â ¾÷±×·¹ÀÌµå ºÒ°¡´É
					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
						dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
						if (dwSWEType == 9) {
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
							return;
						}
					}
					// ÀÏ¹Ý ¹«±â ¾ÆÀÌÅÛ
					// v2.16 2002-5-21 °í±¤Çö¼öÁ¤
					iSoX = iSoM = 0;
					for (i = 0; i < DEF_MAXITEMS; i++)
						if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
							switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
								case 656: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
								case 657: iSoM++; iSomH = i; break; // ½ºÅæ ¿Àºê ¸Þ¸®¿£ 
							}
						}
						// ½ºÅæ ¿Àºê Á¦¸®¸¶°¡ ÀÖ´Ù.
						if (iSoX > 0) {
							if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == false) {
								// ¾÷±×·¹ÀÌµå ½ÇÆÐ 
								SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
								// ½ÇÆÐÇÑ ¾ÆÀÌÅÛ ¾ø¾Ø´Ù.
								iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
								if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false); // v2.172 +1 -> +2 ´Ü°è¿¡¼­ ½ÇÆÐÇÏ¸é »ç¶óÁü 
								// ½ºÅæ ¿Àºê Á¦¸®¸¶ ¾ø¾Ø´Ù.
								ItemDepleteHandler(iClientH, iSoxH, false);	
								return;
							}

							if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) {
								// Á¦ÀÛµÈ ¹«±â ¾÷±×·¹ÀÌµå ÃÖ´ë +10
								iValue++;
								if (iValue > 10) 
									iValue = 10;
								else {
									// ¾÷±×·¹ÀÌµå ¼º°ø. ¾ÆÀÌÅÛ Æ¯¼º ¹Ù²Ù°í
									dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
									dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
									m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â	
									// ½ºÅæ ¿Àºê Á¦¸®¸¶ ¾ø¾Ø´Ù.
									ItemDepleteHandler(iClientH, iSoxH, false);
								}
							}
							else {
								// ÀÏ¹Ý ¹«±â ¾÷±×·¹ÀÌµå ÃÖ´ë +7
								iValue++;
								if (iValue > 7) 
									iValue = 7;
								else {
									// ¾÷±×·¹ÀÌµå ¼º°ø. ¾ÆÀÌÅÛ Æ¯¼º ¹Ù²Ù°í
									dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
									dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
									m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â	
									// ½ºÅæ ¿Àºê Á¦¸®¸¶ ¾ø¾Ø´Ù.
									ItemDepleteHandler(iClientH, iSoxH, false);
								}
							}
						}

						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
						break;
			}
			break;

	case 3: // È° 
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
		break;

	case 5: // ¹æÆÐ
		// ¸ðµÎ ÀÏ¹Ý ¾ÆÀÌÅÛ
		// v2.16 2002-5-21 °í±¤Çö¼öÁ¤
		// °­È­µÈ~ Á¢µÎ»ç°¡ ºÙ´Â ¹æ¾î±¸´Â ¾÷±×·¹ÀÌµå ºÒ°¡´É
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
			dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
			if (dwSWEType == 8) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
				return;
			}
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
			case 620: // ¸Þ¸®¿£-½Çµå
			case 623: // GM-½Çµå
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
				return;
			default: break;
		}


		iSoX = iSoM = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
					case 657: iSoM++; iSomH = i; break; // ½ºÅæ ¿Àºê ¸Þ¸®¿£ 
				}
			}

			// ½ºÅæ ¿Àºê ¸Þ¸®¿£ÀÌ ÀÖ´Ù.			
			if (iSoM > 0) {
				// ¾÷±×·¹ÀÌµå ¼º°ø È®·ü °è»ê.
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH,true) == false) {
					// ¾÷±×·¹ÀÌµå ½ÇÆÐ 
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false); // v2.172 +1 -> +2 ´Ü°è¿¡¼­ ½ÇÆÐÇÏ¸é »ç¶óÁü 
					// ½ºÅæ ¿Àºê ¸Þ¸®¿£ ¾ø¾Ø´Ù.
					ItemDepleteHandler(iClientH, iSomH, false);	
					return;
				}

				// ¾÷±×·¹ÀÌµå ¼º°ø!
				iValue++;
				if (iValue > 10) 
					iValue = 10; // ¾÷±×·¹ÀÌµå ÇÑ°è 
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â	

					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) {
						// Á¦ÀÛ ¹æ¾î±¸ ÀÌ¹Ç·Î ¼ö¸í +20%
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.2f * dV1;
						dV3 = dV1 + dV2;
					}
					else {
						// ÀÏ¹Ý ¹æ¾î±¸ ÀÌ¹Ç·Î ¼ö¸í +15%
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.15f * dV1;
						dV3 = dV1 + dV2;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
					// ¿¡·¯ ¹æÁö¿ë ÄÚµå 
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					// ½ºÅæ ¿Àºê ¸Þ¸®¿£ ¾ø¾Ø´Ù.
					ItemDepleteHandler(iClientH, iSomH, false);	
				}
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, 0, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break;

	case 6: // armors upgrade
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
			case 621: // 
			case 622: // 

			case 700: // 
			case 701: // 
			case 702: //
			case 704: //  
			case 706: // 
			case 707:
			case 708:
			case 710:
			case 711: // 
			case 712: // 
			case 713: // 
			case 724: // 
			case 725:
			case 726:
			case 728:
			case 729: //
			case 730:
			case 731:
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); 
				return;

			default:
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
					dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
					if (dwSWEType == 8) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); 
						return;
					}
				}
				iSoX = iSoM = 0;
				for (i = 0; i < DEF_MAXITEMS; i++)
					if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
						switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
							case 656: iSoX++; iSoxH = i; break; 
							case 657: iSoM++; iSomH = i; break;
						}
					}		
					if (iSoM > 0) {
						if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, true) == false) {
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
							iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
							if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false);
							ItemDepleteHandler(iClientH, iSomH, false);
							return;
						}
						iValue++;
						if (iValue > 10) 
							iValue = 10; 
						else {
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp & 0x0FFFFFFF; 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);	

							if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) {
								dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
								dV2 = 0.2f * dV1;
								dV3 = dV1 + dV2;
							}
							else {
								dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
								dV2 = 0.15f * dV1;
								dV3 = dV1 + dV2;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
							if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
							ItemDepleteHandler(iClientH, iSomH, false);
						}
					}
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, 0, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
					break;
		}
		break;

	case 8: // wands upgrade 
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
			case 291: // MagicWand(LLF)

			case 714: // Èæ¸¶¹ý»çÀÇ ÁöÆÎÀÌ 
			case 732: // Èæ¿©¸¶¹ý»çÀÇ ÁöÆÎÀÌ
			case 738: // Èæ¸¶¹ý»çÀÇ ¸ÅÁ÷¿øµå
			case 746:

				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
				{
					if (iValue != 0) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
						return;
					}
				}

				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
				{ 
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0); // ÇÊ¿äÇÑ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ¼öÄ¡°¡ ¾ø½À´Ï´Ù.
					return; 
				}
				// ¾ÆÀÌÅÛ ·¹º§¾÷ÀÌ ³ô¾ÆÁú¼ö·Ï ¾ÆÀÌÅÛ ·¹º§¾÷ÇÏ±â°¡ ¾î·Æ´Ù.
				// v2.15 ÁöÁ¸ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå °ø½Ä x(x+6)/8 +2 
				sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;

				if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
				{ 
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0); // ÇÊ¿äÇÑ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ¼öÄ¡°¡ ¾ø½À´Ï´Ù.
					return; 
				}

				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

				if (iValue == 0 ){
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				}

				if( (iValue == 11) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 714) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 738))) 
				{
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

					// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 738) == false) {
						// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
						return;
					}

					// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

					iValue += 1;
					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;


				} else if( (iValue == 15) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 738)) 
				{
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

					// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 746) == false) {
						// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
						return;
					}

					// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

					iValue += 1;
					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;


				} else if( (iValue == 15) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 746)) 
				{
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

					// ±âÁ¸ÀÇ ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 892) == false) {
						// ¾÷±×·¹ÀÌµå ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ¾÷±×·¹ÀÌµå°¡ ºÒ°¡´ÉÇÏ´Ù.
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
						return;
					}

					// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

					iValue += 1;
					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;


				} else
				{
					iValue += 1;
					if (iValue > 15) iValue = 15; 
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;
				}

			default:
				// ÀÏ¹Ý ¾ÆÀÌÅÛ
				// v2.16 2002-5-21 °í±¤Çö¼öÁ¤
				iSoX = iSoM = 0;
				for (i = 0; i < DEF_MAXITEMS; i++)
					if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
						switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
							case 656: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
							case 657: iSoM++; iSomH = i; break; // ½ºÅæ ¿Àºê ¸Þ¸®¿£ 
						}
					}
					// ½ºÅæ ¿Àºê Á¦¸®¸¶°¡ ÀÖ´Ù.
					if (iSoX > 0) {
						// ¾÷±×·¹ÀÌµå ¼º°ø È®·ü °è»ê.
						if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == false) {
							// ¾÷±×·¹ÀÌµå ½ÇÆÐ 
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
							iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
							if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false); // v2.172 +1 -> +2 ´Ü°è¿¡¼­ ½ÇÆÐÇÏ¸é »ç¶óÁü 
							// ½ºÅæ ¿Àºê Á¦¸®¸¶ ¾ø¾Ø´Ù.
							ItemDepleteHandler(iClientH, iSoxH, false);	
							return;
						}

						iValue++;
						if (iValue > 7) 
							iValue = 7;
						else {
							// ¾÷±×·¹ÀÌµå ¼º°ø. ¾ÆÀÌÅÛ Æ¯¼º ¹Ù²Ù°í
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â	
							// ½ºÅæ ¿Àºê Á¦¸®¸¶ ¾ø¾Ø´Ù.
							ItemDepleteHandler(iClientH, iSoxH, false);
						}
					}

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);

					break;
		}
		break;

		//hbest hero cape upgrade
		case 13:
			switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
			case 400:
			case 401:
				iSoX = iSoM = 0;
				for (i = 0; i < DEF_MAXITEMS; i++)
					if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
						switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
							case 656: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
							case 657: iSoM++; iSomH = i; break; // ½ºÅæ ¿Àºê ¸Þ¸®¿£ 
						}
					}

				if (iSoM < 1) {
					return;
				}

				bugint = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum;
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
				{
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0); // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÔ´Ï´Ù.
						return;
				}

				if ((m_pClientList[iClientH]->m_iContribution < 50) || (m_pClientList[iClientH]->m_iEnemyKillCount < 50))
				{ 
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0); // ÇÊ¿äÇÑ ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå ¼öÄ¡°¡ ¾ø½À´Ï´Ù.
					return; 
				}

				m_pClientList[iClientH]->m_iContribution -= 50;
				m_pClientList[iClientH]->m_iEnemyKillCount -= 50; 
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, 0, 0, 0);

				if(iValue == 0) 
				{
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

					if (bugint == 400) {
						if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 427) == false) {
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
							return;
						}
					} else {
						if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 428) == false) {
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
							return;
						}
					}

					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

					ItemDepleteHandler(iClientH, iSomH, false);	

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;


				}

			default: break;
			}
			break;

	default:
		// ¾÷±×·¹ÀÌµå µÈ °Í ¾øÀ½.
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
		break;
	}
}

void CGame::TimeHitPointsUp(int iClientH)
{
 int iMaxHP, iTemp, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;

	if (m_pClientList[iClientH]->m_bIsKilled ) return;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] ) return;
	
	iMaxHP = iGetMaxHP(iClientH);

	if (m_pClientList[iClientH]->m_iHP < iMaxHP) {
		
		iTemp = iDice(1, (m_pClientList[iClientH]->m_iVit));

		if (iTemp < (m_pClientList[iClientH]->m_iVit/2)) iTemp = (m_pClientList[iClientH]->m_iVit/2);

		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)

			iTemp -= (iTemp / m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

		iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;

		if (m_pClientList[iClientH]->m_iAddHP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iHP += iTotal;

		if (m_pClientList[iClientH]->m_iHP > iMaxHP) m_pClientList[iClientH]->m_iHP = iMaxHP;

		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);
	}
	m_pClientList[iClientH]->m_iHPstock = 0;
}

char CGame::_cCheckHeroItemEquipped(int iClientH)
{
	short sHeroLeggings, sHeroHauberk, sHeroArmor, sHeroHelm;

	if (m_pClientList[iClientH] == 0) return 0;

	sHeroHelm = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	sHeroArmor = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	sHeroHauberk = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	sHeroLeggings = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];

	if ((sHeroHelm < 0) || (sHeroLeggings < 0) || (sHeroArmor < 0) || (sHeroHauberk < 0)) return 0; 

	if(m_pClientList[iClientH]->m_pItemList[sHeroHelm] == 0) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroLeggings] == 0) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroArmor] == 0) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroHauberk] == 0) return 0;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 403) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 411) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 407) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 415) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 2;
	
	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 404) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 412) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 408) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 416) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 405) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 413) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 409) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 417) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 406) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 414) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 410) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 418) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 2;

	return 0;
}

bool CGame::bPlantSeedBag(int iMapIndex, int dX, int dY, int iItemEffectValue1, int iItemEffectValue2, int iClientH)
{
 int iNamingValue, tX, tY;
 short sOwnerH;
 char cOwnerType, cNpcName[21], cName[21], cNpcWaypointIndex[11];
 bool bRet;

	if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture >= 200){
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOMOREAGRICULTURE, 0, 0, 0, 0);
		return false;
	}

	if (iItemEffectValue2 > m_pClientList[iClientH]->m_cSkillMastery[2]) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_AGRICULTURESKILLLIMIT, 0, 0, 0, 0);
		return false;
	}

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();

	if (iNamingValue == -1) {
	}
	else{
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	if (sOwnerH != 0 && sOwnerH == DEF_OWNERTYPE_NPC && m_pNpcList[sOwnerH]->m_cActionLimit == 5) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, 0, 0, 0, 0);
		return false;
	}
	else{
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsFarm(dX, dY) == false) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, 0, 0, 0, 0);
		return false;
	}
	
	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, "Crops");
	ZeroMemory(cName, sizeof(cName));
	wsprintf(cName, "XX%d", iNamingValue);
	cName[0] = '_';
	cName[1] = iMapIndex+65;

	ZeroMemory(cNpcWaypointIndex,sizeof(cNpcWaypointIndex));
	tX = dX;
	tY = dY;

	bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypointIndex, 0, 0, 0, false, true);
	if (bRet == false) {
			m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
		} 
		else{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
			if (m_pNpcList[sOwnerH] == 0) return 0;
				m_pNpcList[sOwnerH]->m_cCropType = iItemEffectValue1;
					switch (iItemEffectValue1) {
					case 1: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 2: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 3: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 4: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 5: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 6: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 7: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 8: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 9: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 10: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 11: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 12: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 13: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					default: m_pNpcList[sOwnerH]->m_cCropSkill = 100; break;				
				}
				m_pNpcList[sOwnerH]->m_sAppr2 = 1;
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);
				wsprintf(G_cTxt, "(skill:%d type:%d)plant(%s) Agriculture begin(%d,%d) sum(%d)!", m_pNpcList[sOwnerH]->m_cCropSkill, m_pNpcList[sOwnerH]->m_cCropType, cNpcName, tX, tY, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture);
				PutLogList(G_cTxt);
				return true;
			}
		}
	}
	return false;
}

void CGame::_CheckFarmingAction(short sAttackerH, short sTargetH, bool bType)
{
 char cCropType;
 int iItemID;
 class CItem * pItem;

 iItemID = 0;
 cCropType = 0;

	cCropType = m_pNpcList[sTargetH]->m_cCropType;
	switch (cCropType) {
	case 1: GetExp(sAttackerH, iDice(3,10)); iItemID = 820; break; // WaterMelon
	case 2: GetExp(sAttackerH, iDice(3,10)); iItemID = 821; break; // Pumpkin
	case 3: GetExp(sAttackerH, iDice(4,10)); iItemID = 822; break; // Garlic
	case 4: GetExp(sAttackerH, iDice(4,10)); iItemID = 823; break; // Barley
	case 5: GetExp(sAttackerH, iDice(5,10)); iItemID = 824; break; // Carrot
	case 6: GetExp(sAttackerH, iDice(5,10)); iItemID = 825; break; // Radish
	case 7: GetExp(sAttackerH, iDice(6,10)); iItemID = 826; break; // Corn
	case 8: GetExp(sAttackerH, iDice(6,10)); iItemID = 827; break; // ChineseBellflower
	case 9: GetExp(sAttackerH, iDice(7,10)); iItemID = 828; break; // Melone
	case 10: GetExp(sAttackerH, iDice(7,10)); iItemID = 829; break; // Tommato
	case 11: GetExp(sAttackerH, iDice(8,10)); iItemID = 830; break; // Grapes
	case 12: GetExp(sAttackerH, iDice(8,10)); iItemID = 831; break; // BlueGrapes
	case 13: GetExp(sAttackerH, iDice(9,10)); iItemID = 832; break; // Mushroom
	default: GetExp(sAttackerH, iDice(10,10)); iItemID = 721; break; // Ginseng
	
	}
	
	pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == false) {
		delete pItem;
	}
	if (bType == 0) {
		m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->bSetItem(m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[sAttackerH]->m_cMapIndex,
			m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY,  pItem->m_sIDnum, 0, 
			pItem->m_cItemColor, pItem->m_dwAttribute);
	}
	else if (bType == 1) {
		m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bSetItem(m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[sTargetH]->m_cMapIndex,
			m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY,  pItem->m_sIDnum, 0,
			pItem->m_cItemColor, pItem->m_dwAttribute);
	} 

}

/*void CGame::CalculateEnduranceDecrement(short sTargetH, short sAttackerH, char cTargetType, int iArmorType)
{
 short sItemIndex;
 int iDownValue = 1, iHammerChance = 100;

	if (m_pClientList[sTargetH] == 0) return;

	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0 )) {
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)) {
			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
				case 14: 
					if ((31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4)) || (32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))) {
						sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
						if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 761) { // BattleHammer 
								iDownValue = 30;
								break;
							}
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
								iDownValue = 35;
								break;
							}
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 843) { // BarbarianHammer
								iDownValue = 30;
								break;
							}
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 745) { // BarbarianHammer
								iDownValue = 30;
								break;
							}
						}
					}
					else { 
						iDownValue = 20; break;
					}
				case 10: iDownValue = 3; break;
				default: iDownValue = 1; break;
				}

				if (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled ) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType)
						case 52: iDownValue = 0; iHammerChance = 0;
				}
			}
		}
		
		if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 0)) {
				m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan -= iDownValue;
		}

		if ((m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan <= 0) || (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 64000)) {
			m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan = 0;
			SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
			ReleaseItemHandler(sTargetH, iArmorType, true);
			return;
		}

	/*try
	{
		if (m_pClientList[sAttackerH] != 0) {
			if (cTargetType == DEF_OWNERTYPE_PLAYER) {
				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
					if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 617) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 618) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 619) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 873) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 874) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 75) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 76)) { 
						m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 6;
						return;
					}
				}
			}
		}*/

		/*if (m_pClientList[sAttackerH] != 0) {
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
		if ((m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14) && (iHammerChance == 100)) {
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan < 2000) {
				iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
			}
			else {
				iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
			}
			
			if ((31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4)) || (32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))) {
				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 761) { // BattleHammer 
						iHammerChance = iHammerChance/2; 
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
						iHammerChance = ((iHammerChance*10)/9);
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 843) { // GiantBattleHammer
						iHammerChance = ((iHammerChance*10)/9);
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 745) { // GiantBattleHammer
						iHammerChance = ((iHammerChance*10)/9);
					}
				}
			}
			if ((m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum == 622) || (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum == 621)) {
				iHammerChance = 0;
			}
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan < iHammerChance) {
				wsprintf(G_cTxt, "(iHammerChance (%d), target armor endurance (%d)!", iHammerChance, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan);
				PutLogList(G_cTxt);
				ReleaseItemHandler(sTargetH, iArmorType, true);
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
				return;
			}
		}
		}
		}
	//}
	//catch(...)
	{
	
	}	
}*/

bool CGame::bCalculateEnduranceDecrement(short sTargetH, short sAttackerH, char cTargetType, int iArmorType)
{
 int iDownValue = 1, iHammerChance = 100, iItemIndex;
 WORD wWeaponType;

	if (m_pClientList[sTargetH] == 0) return false;
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] == 0)) return false;
	wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)) {
		switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
		case 14: 
			if ((wWeaponType == 31) || (wWeaponType == 32)) {
				iItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((iItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[iItemIndex] != 0)) {
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 761) { // BattleHammer 
						iDownValue = 30;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
						iDownValue = 35;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 843) { // BarbarianHammer
						iDownValue = 30;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 745) { // MasterBattleHammer
						iDownValue = 30;
					}
					break;
				}
			}
			else {
				iDownValue = 20;
			}
			break;
		case 10: 
			iDownValue = 3;
			break;
		default: 
			iDownValue = 1;
			break;
		}
	}
	if (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled ) {
		switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
		case 52:
			iDownValue = 0;
			iHammerChance = 0;
			break;
		}
	}
	if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 0)) {
		m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan -= iDownValue;
		SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iArmorType, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan, 0, 0);
	}
	if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan <= 0) {
		m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan = 0;
		SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
		ReleaseItemHandler(sTargetH, iArmorType, true);
		return true;
	}
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14) && (iHammerChance == 100)) {
		if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan < 2000) {
			iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
		}
		else {
			iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
		}
		if ((wWeaponType == 31) || (wWeaponType == 32)) {
			iItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			if ((iItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[iItemIndex] != 0)) {
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 761) { // BattleHammer 
					iHammerChance -= iHammerChance >> 1; 
				}
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
					iHammerChance = (((iHammerChance*5)+7) >> 3);
				}
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 843) { // BarbarianHammer
					iHammerChance = (((iHammerChance*5)+7) >> 3);
				}
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 745) { // MasterBattleHammer
					iHammerChance = (((iHammerChance*5)+7) >> 3);
				}
			}
			else {
				iHammerChance = ((iHammerChance+3) >> 2);
			}
			switch (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum) {
			case 621:
			case 622:
				iHammerChance = 0;
				break;
			}
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan < iHammerChance) {
				ReleaseItemHandler(sTargetH, iArmorType, true);
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
			}
		}
	}
	return true;
}

DWORD CGame::iCalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType, int tdX, int tdY, int iAttackMode, bool bNearAttack, bool bIsDash, bool bArrowUse)
{
	int    iAP_SM, iAP_L, iAttackerHitRatio, iTargetDefenseRatio, iDestHitRatio, iResult, iAP_Abs_Armor, iAP_Abs_Shield;
	char   cAttackerName[21], cAttackerDir, cAttackerSide, cTargetDir, cProtect, cCropSkill, cFarmingSkill;
	short  sWeaponIndex, sAttackerWeapon, dX, dY, sX, sY, sAtkX, sAtkY, sTgtX, sTgtY;
	DWORD  dwTime;
	WORD   wWeaponType;
	double dTmp1, dTmp2, dTmp3;
	bool   bKilled;
	bool   bNormalMissileAttack;
	bool   bIsAttackerBerserk;
	int    iKilledDice, iDamage, iExp, iWepLifeOff, iSideCondition, iMaxSuperAttack, iWeaponSkill, iComboBonus, iTemp;
	int    iAttackerHP, iMoveDamage, iRepDamage;
	char   cAttackerSA;
	int    iAttackerSAvalue, iHitPoint;
	char   cDamageMoveDir;
	int    iPartyID, iConstructionPoint, iWarContribution, tX, tY, iDst1, iDst2;
	short sItemIndex;
	short sSkillUsed;

	dwTime = timeGetTime();
	bKilled = false;
	iExp = 0;
	iPartyID = 0;
	bNormalMissileAttack = false;
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	cAttackerSA      = 0;
	iAttackerSAvalue = 0;
	wWeaponType      = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sAttackerH] == 0) return 0;
		if ((m_bAdminSecurity ) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return 0;
		if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == false) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) return 0;
		if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] == 0) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap ) && (m_bIsHeldenianMode )) return 0;
		if ((m_bIsCrusadeMode == false) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil ) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return 0;

		if ((m_pClientList[sAttackerH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_PLAYER, false);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
		}
		
		if ((m_pClientList[sAttackerH]->m_sAppr2 & 0xF000) == 0) return 0;

		iAP_SM = 0;
		iAP_L  = 0;

		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);

		sSkillUsed = m_pClientList[sAttackerH]->m_sUsingWeaponSkill;
		if ((bIsDash ) && (m_pClientList[sAttackerH]->m_cSkillMastery[sSkillUsed] != 100) && (wWeaponType != 25) && (wWeaponType != 27)) {
			try
			{
				wsprintf(G_cTxt, "TSearch Fullswing Hack: (%s) Player: (%s) - dashing with only (%d) weapon skill.", m_pClientList[sAttackerH]->m_cIPaddress, m_pClientList[sAttackerH]->m_cCharName, m_pClientList[sAttackerH]->m_cSkillMastery[sSkillUsed]);
				PutHackLogFileList(G_cTxt);
				DeleteClient(sAttackerH, true, true);
			}
			catch(...)
			{

			}
			return 0;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
				
		if (wWeaponType == 0) {
			iAP_SM = iAP_L    = iDice(1, ((m_pClientList[sAttackerH]->m_iStr+ m_pClientList[sAttackerH]->m_iAngelicStr) / 12));
			if (iAP_SM <= 0) iAP_SM = 1;
			if (iAP_L  <= 0) iAP_L  = 1;
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio + m_pClientList[sAttackerH]->m_cSkillMastery[5];
			m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 5 ;

		}
		else if ((wWeaponType >= 1) && (wWeaponType < 40)) {
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;

			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;

			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 +0.5f);

			dTmp1 = (double)iAP_L;
			dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 +0.5f);
		}
		else if (wWeaponType >= 40) {
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;

			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;
			bNormalMissileAttack = true;

			iAP_SM += iDice(1, ((m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr) / 20));
			iAP_L  += iDice(1, ((m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr) / 20));
		}
	
		iAttackerHitRatio += 50;
		if (iAP_SM <= 0) iAP_SM = 1;
		if (iAP_L  <= 0) iAP_L  = 1;

		if (m_pClientList[sAttackerH]->m_iCustomItemValue_Attack != 0) {
			if ((m_pClientList[sAttackerH]->m_iMinAP_SM != 0) && (iAP_SM < m_pClientList[sAttackerH]->m_iMinAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMinAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMinAP_L != 0) && (iAP_L < m_pClientList[sAttackerH]->m_iMinAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMinAP_L;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_SM != 0) && (iAP_SM > m_pClientList[sAttackerH]->m_iMaxAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMaxAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_L != 0) && (iAP_L > m_pClientList[sAttackerH]->m_iMaxAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMaxAP_L;
			}
		}

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 1) {
			iAttackerHitRatio += 100;
			iAP_SM += 5;
			iAP_L += 5;
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 851) || // KlonessEsterk 
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863) || // KlonessWand(MS.20)
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864)) { // KlonessWand(MS.10) 
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
					if (iRepDamage < 5) iRepDamage = 5;
					if (iRepDamage > 15) iRepDamage = 15;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == 0) return 0;
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
						if (iRepDamage > 10) iRepDamage = 10;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 732) || // BerserkWand(MS.20)
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 738)) { // BerserkWand(MS.10)
					iAP_SM += 1;
					iAP_L += 1;
			}
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 847) && 
				(m_cDayOrNight == 2)) {
					iAP_SM += 4;
					iAP_L += 4;
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 848) && 
				(m_cDayOrNight == 1)) {
					iAP_SM += 4;
					iAP_L += 4;
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 849) || // KlonessBlade 
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 850)) { // KlonessAxe
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
					if (iRepDamage < 5) iRepDamage = 5;
					if (iRepDamage > 15) iRepDamage = 15;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == 0) return 0;
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
						if (iRepDamage > 10) iRepDamage = 10;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
			if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == 0) return 0;
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
						if (iRepDamage > 5) iRepDamage = 5;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
				}
			}
		}

		cAttackerDir = m_pClientList[sAttackerH]->m_cDir;
		strcpy(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);

		if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0)
			bIsAttackerBerserk = true;
		else bIsAttackerBerserk = false;
		
		if ((bArrowUse != true) && (m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {

			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_SM += iTemp;

			dTmp1 = (double)iAP_L;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_L += iTemp;

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
				case 6:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio  += 30 ; break;

				case 7:  iAP_SM *= 1; iAP_L *= 1; break;
				
				case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio += 30 ; break;
				case 10:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5) ;                           break;
				case 14:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5) ; iAttackerHitRatio += 20 ; break;
				case 21:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5); iAttackerHitRatio +=  50 ; break;
				default: break;
			}
			iAttackerHitRatio += 100;
			iAttackerHitRatio += m_pClientList[sAttackerH]->m_iCustomItemValue_Attack;
		}

		if (bIsDash ) {

			iAttackerHitRatio += 20;

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
				case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); break;
				case 10: iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5);break;
				case 14: iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5);break;
				default: break;
			}
		}

		iAttackerHP = m_pClientList[sAttackerH]->m_iHP;
		iAttackerHitRatio += m_pClientList[sAttackerH]->m_iAddAR;

		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:

		if (m_pNpcList[sAttackerH] == 0) return 0;
		if (m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == false) return 0;

		if ((m_pNpcList[sAttackerH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_NPC, false);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
			m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
		}

		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		iAP_SM = 0;
		iAP_L  = 0;

		if (m_pNpcList[sAttackerH]->m_cAttackDiceThrow != 0) 
			iAP_L = iAP_SM = iDice(m_pNpcList[sAttackerH]->m_cAttackDiceThrow, m_pNpcList[sAttackerH]->m_cAttackDiceRange);

		iAttackerHitRatio = m_pNpcList[sAttackerH]->m_iHitRatio;

		cAttackerDir = m_pNpcList[sAttackerH]->m_cDir;
		memcpy(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, 20);

		if (m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0)
			bIsAttackerBerserk = true;
		else bIsAttackerBerserk = false;

		iAttackerHP = m_pNpcList[sAttackerH]->m_iHP;
		cAttackerSA = m_pNpcList[sAttackerH]->m_cSpecialAbility;

		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == 0) return 0;
		if (m_pClientList[sTargetH]->m_bIsKilled ) return 0;
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return 0;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == false) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil )) return 0;
				
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral ) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation )) return 0;
		
		if ((m_pClientList[sTargetH]->m_sX != tdX) || (m_pClientList[sTargetH]->m_sY != tdY)) return 0;

		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return 0;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral ) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;

		if ((m_pClientList[sTargetH]->m_iPartyID != 0) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return 0;

		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode )) { 
			iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
			if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				iAP_SM = iAP_SM / 2;
				iAP_L  = iAP_L / 2;
			}
			else {
				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone ) {
					if (m_pClientList[sAttackerH]->m_iGuildGUID == m_pClientList[sTargetH]->m_iGuildGUID) return 0;
					else {
						iAP_SM = iAP_SM / 2;
						iAP_L  = iAP_L / 2;
					}
				}
				else return 0;
			}
		}

		iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR;
		


		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:

		if (m_pNpcList[sTargetH] == 0) return 0;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return 0;

		if ((m_pNpcList[sTargetH]->m_sX != tdX) || (m_pNpcList[sTargetH]->m_sY != tdY)) return 0;

		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pNpcList[sTargetH]->m_iDefenseRatio;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {		
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
				break;
			}

			if ((wWeaponType == 25) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				if ((m_pClientList[sAttackerH]->m_iCrusadeDuty != 2) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) break;
						
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 36:
				case 37:
				case 38:
				case 39:
					// administrators instantly build crusade structures
					if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0) {
						m_pNpcList[sTargetH]->m_sAppr2 = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}
				
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:
						m_pNpcList[sTargetH]->m_sAppr2 = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						switch (m_pNpcList[sTargetH]->m_sType) {
						case 36: iConstructionPoint = 700; iWarContribution = 700; break;
						case 37: iConstructionPoint = 700; iWarContribution = 700; break;
						case 38: iConstructionPoint = 500; iWarContribution = 500; break;
						case 39: iConstructionPoint = 500; iWarContribution = 500; break;
						}
										
						m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
						if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
							m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
						wsprintf(G_cTxt, "Construction Complete! WarContribution: +%d", iWarContribution);
						PutLogList(G_cTxt);
						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, 0, 0);
						break;
					case 5:
						m_pNpcList[sTargetH]->m_sAppr2 = 1;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						break;
					case 10:
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						break;
					}
					break;
				}
				
				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}
			if ((wWeaponType == 27) && (m_pNpcList[sTargetH]->m_cCropType != 0) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				cFarmingSkill = m_pClientList[sAttackerH]->m_cSkillMastery[2];
				cCropSkill = m_pNpcList[sTargetH]->m_cCropSkill;
				if (cFarmingSkill < 20) return 0;
				if (m_pClientList[sAttackerH]->m_iLevel < 20) return 0;
				switch(m_pNpcList[sTargetH]->m_sType) {
				case 64:
					switch(m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:	
						m_pNpcList[sTargetH]->m_sAppr2 = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						//sub_4B67E0
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 1);
						DeleteNpc(sTargetH);
						return 0;
					case 8:	
						m_pNpcList[sTargetH]->m_sAppr2 = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);	
						break;
					case 18:
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);	
						break;

					}
					break;
				}
				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}
		}

		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;
		break;
	}

	if ( (cAttackerType == DEF_OWNERTYPE_PLAYER) && (cTargetType == DEF_OWNERTYPE_PLAYER) ) {

		sX = m_pClientList[sAttackerH]->m_sX;
		sY = m_pClientList[sAttackerH]->m_sY;

		dX = m_pClientList[sTargetH]->m_sX;
		dY = m_pClientList[sTargetH]->m_sY;

		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) return 0;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) return 0;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if ((m_pClientList[sAttackerH]->m_iDex+ m_pClientList[sAttackerH]->m_iAngelicDex) > 50) {
			iAttackerHitRatio += ((m_pClientList[sAttackerH]->m_iDex + m_pClientList[sAttackerH]->m_iAngelicDex) - 50);
		}
	}

	if (wWeaponType >= 40) {
		switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
		case 0:	break;
		case 1:	iAttackerHitRatio -= (iAttackerHitRatio / 20); break;
		case 2:	iAttackerHitRatio -= (iAttackerHitRatio / 10); break;
		case 3:	iAttackerHitRatio -= (iAttackerHitRatio / 4);  break;
		}
	}

	if (iAttackerHitRatio < 0)   iAttackerHitRatio = 0;    
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
		break;

	case DEF_OWNERTYPE_NPC:
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]; 
		break;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] == 0) {
				m_pClientList[sAttackerH]->m_bIsItemEquipped[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] = false;
				DeleteClient(sAttackerH, true, true);
				return 0;
			}

			if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW) {
				if (m_pClientList[sAttackerH]->m_cArrowIndex == -1) {
					return 0;
				}
				else {
					if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex] == 0) 
						return 0;

					if (bArrowUse != true)
						m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount--;
					if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount <= 0) {

						ItemDepleteHandler(sAttackerH, m_pClientList[sAttackerH]->m_cArrowIndex, false);
						m_pClientList[sAttackerH]->m_cArrowIndex = _iGetArrowItemIndex(sAttackerH);
					}
					else {
						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_SETITEMCOUNT, m_pClientList[sAttackerH]->m_cArrowIndex, m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount, false, 0);
						iCalcTotalWeight(sAttackerH);
					}
				}
				if (cProtect == 1) return 0;
			}
			else {
				switch (cProtect) {
				case 3: iTargetDefenseRatio += 40;  break;
				case 4: iTargetDefenseRatio += 100; break;
				}
				if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
			}
		}
	}
	else {
		switch (cProtect) {
		case 1: 
			switch (m_pNpcList[sAttackerH]->m_sType) {
				case 54:
					if ((abs(sTgtX - m_pNpcList[sAttackerH]->m_sX) >= 1) || (abs(sTgtY - m_pNpcList[sAttackerH]->m_sY) >= 1)) return 0; 
					}
					break;
		case 3: iTargetDefenseRatio += 40;  break;
		case 4: iTargetDefenseRatio += 100; break;
		}
		if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
	}

	if (cAttackerDir == cTargetDir) iTargetDefenseRatio = iTargetDefenseRatio / 2;
	if (iTargetDefenseRatio < 1)   iTargetDefenseRatio = 1;

	dTmp1 = (double)(iAttackerHitRatio);
	dTmp2 = (double)(iTargetDefenseRatio);
	dTmp3 = (dTmp1 / dTmp2) * 50.0f;
	iDestHitRatio = (int)(dTmp3); 

	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;

	if ((bIsAttackerBerserk ) && (iAttackMode < 20)) {
		iAP_SM = iAP_SM * 2;
		iAP_L  = iAP_L  * 2;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
		iAP_L  += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
	}

	if (bNearAttack ) {
		iAP_SM = iAP_SM / 2;
		iAP_L  = iAP_L / 2;
	}

	if (cTargetType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
		iAP_L  -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (iAP_SM <= 1) iAP_SM = 1;
		if (iAP_L  <= 1) iAP_L  = 1;
	}
	else {
		if (iAP_SM <= 0) iAP_SM = 0;
		if (iAP_L  <= 0) iAP_L  = 0;
	}

	iResult = iDice(1, 100);

	if (iResult <= iDestHitRatio) {
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {

			if (((m_pClientList[sAttackerH]->m_iHungerStatus <= 10) || (m_pClientList[sAttackerH]->m_iSP <= 0)) && (iDice(1,10) == 5)) return false;	
			m_pClientList[sAttackerH]->m_iComboAttackCount++;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount < 0) m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount > 4) m_pClientList[sAttackerH]->m_iComboAttackCount = 1;
			iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
			iComboBonus = iGetComboAttackBonus(iWeaponSkill, m_pClientList[sAttackerH]->m_iComboAttackCount);

			if ((m_pClientList[sAttackerH]->m_iComboAttackCount > 1) && (m_pClientList[sAttackerH]->m_iAddCD != 0))
				iComboBonus += m_pClientList[sAttackerH]->m_iAddCD;

			iAP_SM += iComboBonus;
			iAP_L  += iComboBonus;

			switch (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectType) {
				case 0: break;
				case 1:
					if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
						iAP_SM += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
						iAP_L  += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
					}
					break;

				case 2:
					cAttackerSA = 61;
					iAttackerSAvalue = m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue*5; 
					break;

				case 3:
					cAttackerSA = 62;
					break;
			}

			if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone ) {
				iAP_SM += iAP_SM/3;
				iAP_L  += iAP_L/3;
			}

			if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
				iAP_SM += iAP_SM/3;
				iAP_L  += iAP_L/3;
			}
			
			if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode ) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
				if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
					iAP_SM += iAP_SM;
					iAP_L += iAP_L;
				}
				else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
					iAP_SM += (iAP_SM* 7)/10;
					iAP_L += (iAP_L* 7)/10;
				} else {
					iAP_SM += iAP_SM/3;
					iAP_L += iAP_L/3;
				}
			}
		}

		switch (cTargetType) {
		case DEF_OWNERTYPE_PLAYER:
			ClearSkillUsingStatus(sTargetH);
			if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) {
				return 0;
			}
			else {
				switch (cAttackerSA) {
					case 62:
						if (m_pClientList[sTargetH]->m_iRating < 0) {
							iTemp = abs(m_pClientList[sTargetH]->m_iRating)/10;
							if (iTemp > 10) iTemp = 10;
							iAP_SM += iTemp;
						}
						break;
				}

				iAP_Abs_Armor  = 0;
				iAP_Abs_Shield = 0;
				iTemp = iDice(1,10000);
				if ((iTemp >= 1) && (iTemp < 5000))           iHitPoint = 1;
				else if ((iTemp >= 5000) && (iTemp < 7500))   iHitPoint = 2;
				else if ((iTemp >= 7500) && (iTemp < 9000))   iHitPoint = 3;
				else if ((iTemp >= 9000) && (iTemp <= 10000)) iHitPoint = 4;

				switch (iHitPoint) {
				case 1:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;
						iAP_Abs_Armor = (int)dTmp3;
					}
					break;
				case 2:
					if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
						m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) > 0) {
							if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
								m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) >= 80)
								dTmp1 = 80.0f;
							else dTmp1 = (double)(m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]);
							dTmp2 = (double)iAP_SM;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;

							iAP_Abs_Armor = (int)dTmp3;
						}
						break;

				case 3: 
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 4:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;
				}

				if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield > 0) {
					if (iDice(1,100) <= (m_pClientList[sTargetH]->m_cSkillMastery[11])) {
						CalculateSSN_SkillIndex(sTargetH, 11, 1);
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield >= 80) 
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Shield;
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Shield = (int)dTmp3;

						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
							if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
								m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
								SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
							}
							if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
								SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
								ReleaseItemHandler(sTargetH, iTemp, true);
							}
						}
					}
				}

				iAP_SM = iAP_SM - (iAP_Abs_Armor + iAP_Abs_Shield);
				if (iAP_SM <= 0) iAP_SM = 1;

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0) && (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled )) {
					switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
						case 0: break;
						case 1:
							iTemp = (m_pClientList[sTargetH]->m_iHP / 2);
							if (iTemp > iAP_SM) iAP_SM = iTemp;
							if (iAP_SM <= 0) iAP_SM = 1;
							break;
						case 2:
							if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sTargetH, DEF_OWNERTYPE_PLAYER, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + 30000, 
									sTargetH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
								SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, 0);
							}
							break;
						case 3:
							if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 0) {
								m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 2;
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + 10000, 
									sTargetH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 10, 0, 0);
								SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, 10, 0, 0);
							}
							break;
						case 4:
							iAP_SM = (m_pClientList[sTargetH]->m_iHP);
							break;
						case 5:
							m_pClientList[sAttackerH]->m_iHP += iAP_SM;
							if (iGetMaxHP(sAttackerH) < m_pClientList[sAttackerH]->m_iHP) m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH);
							SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
							break;
					}
				}

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled )) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
						case 50:
							if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
								sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
							else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
							if (sWeaponIndex != -1)	m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
							break;
						case 51:
							if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
								iAP_SM = 0;
							break;
						case 52:
							iAP_SM = 0;
							break;
					}
				}

				if ((m_pClientList[sTargetH]->m_bIsLuckyEffect ) && 
					(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iAP_SM)) {
						iAP_SM = m_pClientList[sTargetH]->m_iHP - 1;
					}

				switch (iHitPoint) {
				case 1:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;

				case 2:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					else {
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
							bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
						}
					}
					break;

				case 3:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;

				case 4:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;
				}
	
				if ((cAttackerSA == 2) && (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0)) {
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT ], 0, 0);
					switch(m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
					case 1:
						SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_PLAYER, false);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_PLAYER, false);
						break;
					case 3:
					case 4:
						SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_PLAYER, false);
						break;
					}
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
				}

				if ( (m_pClientList[sTargetH]->m_bIsPoisoned == false) && 
					((cAttackerSA == 5) || (cAttackerSA == 6) || (cAttackerSA == 61)) ) {
					if (bCheckResistingPoisonSuccess(sTargetH, DEF_OWNERTYPE_PLAYER) == false) {
						m_pClientList[sTargetH]->m_bIsPoisoned = true;
						if (cAttackerSA == 5)		m_pClientList[sTargetH]->m_iPoisonLevel = 15;
						else if (cAttackerSA == 6)  m_pClientList[sTargetH]->m_iPoisonLevel = 40;
						else if (cAttackerSA == 61) m_pClientList[sTargetH]->m_iPoisonLevel = iAttackerSAvalue;

						m_pClientList[sTargetH]->m_dwPoisonTime = dwTime;
						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sTargetH]->m_iPoisonLevel, 0, 0);
						SetPoisonFlag(sTargetH, DEF_OWNERTYPE_PLAYER, true);
					}
				}

				m_pClientList[sTargetH]->m_iHP -= iAP_SM;
				if (m_pClientList[sTargetH]->m_iHP <= 0) {
					if (cAttackerType == DEF_OWNERTYPE_PLAYER)
						bAnalyzeCriminalAction(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iAP_SM);	
					bKilled     = true;
					iKilledDice = m_pClientList[sTargetH]->m_iLevel;
				}
				else {
					if (iAP_SM > 0) {
						if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
							dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
							dTmp2 = (double)iAP_SM;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iTemp = iGetMaxMP(sTargetH);
							m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
							if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
						}
						if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
							if (iDice(1,100) <= (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
									SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
							}
						}

					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);

					if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
						sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
					else sAttackerWeapon = 1;

					if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone )) 
						iMoveDamage = 60;
					else iMoveDamage = 40;

					if (iAP_SM >= iMoveDamage) {
						if (sTgtX == sAtkX) {
							if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE;
								else if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
							}
							else if (sTgtX > sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 3;
									else if (sTgtY > sAtkY) cDamageMoveDir = 4;
									else if (sTgtY < sAtkY) cDamageMoveDir = 2;
								}
								else if (sTgtX < sAtkX) {
									if (sTgtY == sAtkY)     cDamageMoveDir = 7;
										else if (sTgtY > sAtkY) cDamageMoveDir = 6;
										else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
								}
							m_pClientList[sTargetH]->m_iLastDamage = iAP_SM;

							SendNotifyMsg(0, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iAP_SM, sAttackerWeapon, 0);
						}
						else {
CAE_SKIPDAMAGEMOVE:
							int iProb;
							if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
								switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
									case 6 : iProb = 3500; break;
									case 8 : iProb = 1000; break;
									case 9 : iProb = 2900; break;
									case 10: iProb = 2500; break;
									case 14: iProb = 2000; break;
									case 21: iProb = 2000; break;
									default: iProb = 1; break;
								}
							}
							else iProb = 1;

							if (iDice(1,10000) >= iProb) 
								SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iAP_SM, sAttackerWeapon, 0);		
							}

							if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
								SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], 0, 0);
								m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
								bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
							}

							m_pClientList[sTargetH]->m_iSuperAttackCount++;
							if (m_pClientList[sTargetH]->m_iSuperAttackCount > 14) { 
								m_pClientList[sTargetH]->m_iSuperAttackCount = 0;
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
									SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
							}
						}
					}
				}
				break;				   

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return 0;
			if (m_pNpcList[sTargetH]->m_bIsKilled ) return 0;
			if (m_bIsCrusadeMode ) {
				if (cAttackerSide == m_pNpcList[sTargetH]->m_cSide) {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 40:
						case 41:
						case 43:
						case 44:
						case 45:
						case 46:
						case 47: 
						case 51:
							return 0;

						default: break;
					}
				}
				else {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 41:
							if (cAttackerSide != 0) {
								m_pNpcList[sTargetH]->m_iV1 += iAP_L;
								if (m_pNpcList[sTargetH]->m_iV1 > 500) {
									m_pNpcList[sTargetH]->m_iV1 = 0;
									m_pNpcList[sTargetH]->m_iManaStock--;
									if (m_pNpcList[sTargetH]->m_iManaStock <= 0) m_pNpcList[sTargetH]->m_iManaStock = 0;
									wsprintf(G_cTxt, "ManaStock down: %d", m_pNpcList[sTargetH]->m_iManaStock);
									PutLogList(G_cTxt);
								}
							}
							break;
					}
				}
			}
			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
				case 1:
				case 2:
				return 0;
				}

			if (m_pNpcList[sTargetH]->m_cSize == 0)	
				iDamage = iAP_SM;					
			else iDamage = iAP_L;

			if (m_pNpcList[sTargetH]->m_iAbsDamage < 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)(abs(m_pNpcList[sTargetH]->m_iAbsDamage))/100.0f;
				dTmp3 = dTmp1 * dTmp2;
				dTmp2 = dTmp1 - dTmp3;
				iDamage = (int)dTmp2;
				if (iDamage < 0) iDamage = 1;
				else if ((m_pNpcList[sTargetH]->m_sType == 31) && (cAttackerType == 1) && (m_pClientList[sAttackerH] != 0) && (m_pClientList[sAttackerH]->m_iSpecialAbilityType == 7))
					iDamage += iDice(3,2);
			}


			if ((cAttackerSA == 2) && (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0)) {
					switch(m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
					case 1:
						SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_NPC, false);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_NPC, false);
						break;
					case 3:
					case 4:
						SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_NPC, false);
						break;
					}
				m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = 0;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_PROTECT);					  
			}

			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 0:
			case 3:
			case 5:
				m_pNpcList[sTargetH]->m_iHP -= iDamage;
				break;
			}

			if (m_pNpcList[sTargetH]->m_iHP <= 0) {
				NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
				bKilled = true;
				iKilledDice = m_pNpcList[sTargetH]->m_iHitDice;
			}
			else {
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) goto CAE_SKIPCOUNTERATTACK;

				if (m_pNpcList[sTargetH]->m_cActionLimit != 0) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_bIsPermAttackMode ) goto CAE_SKIPCOUNTERATTACK;
				if ((m_pNpcList[sTargetH]->m_bIsSummoned ) && (m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_sType == 51) goto CAE_SKIPCOUNTERATTACK;

				if (iDice(1,3) == 2) {
					if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
						tX = tY = 0;
						switch (m_pNpcList[sTargetH]->m_cTargetType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex] != 0) {
									tX = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
									tY = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex] != 0) {
									tX = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
									tY = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
								}
								break;
							}

						iDst1 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);

						tX = tY = 0;
						switch (cAttackerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sAttackerH] != 0) {
									tX = m_pClientList[sAttackerH]->m_sX;
									tY = m_pClientList[sAttackerH]->m_sY;
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sAttackerH] != 0) {
									tX = m_pNpcList[sAttackerH]->m_sX;
									tY = m_pNpcList[sAttackerH]->m_sY;
								}
								break;
						}

						iDst2 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);

						if (iDst2 <= iDst1) {
							m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
							m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
							m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
						}
					}
					else {
						m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
						m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
					}
				}

CAE_SKIPCOUNTERATTACK:

				if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0))
					m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
					sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
				else sAttackerWeapon = 1;

				if ((wWeaponType < 40) && (m_pNpcList[sTargetH]->m_cActionLimit == 4)) {
 					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) goto CAE_SKIPDAMAGEMOVE2;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) goto CAE_SKIPDAMAGEMOVE2;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);

 					if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) ) {
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
							iExp = (m_pNpcList[sTargetH]->m_iExp/3);
							if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0)
								iExp += m_pNpcList[sTargetH]->m_iNoDieRemainExp;

							if (m_pClientList[sAttackerH]->m_iAddExp != 0) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}

							if ((m_bIsCrusadeMode ) && (iExp > 10)) iExp = 10;

							GetExp(sAttackerH, iExp);

							DeleteNpc(sTargetH);
							return false;
						}
					}

CAE_SKIPDAMAGEMOVE2:;
				}
				else {
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, sAttackerWeapon, 0);
				}

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}
				else if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 2) {
					if ((m_pNpcList[sTargetH]->m_iHitDice > 50) && (iDice(1, 10) == 5)) {
						m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
						bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
					}
				}

				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) && 
					(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0) ) {
						if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
							iExp = iDamage;
							m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
						}
						else {
							iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
						}

						if (m_pClientList[sAttackerH]->m_iAddExp != 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						if (m_bIsCrusadeMode ) iExp = iExp/3;

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
					}
			}
			break;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
				sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];

			if ((sWeaponIndex != -1) && (bArrowUse != true)) {
				if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != 0) &&
					(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum != 231) ) {
						if (bKilled == false)
							CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, 1);
						else {
							if (m_pClientList[sAttackerH]->m_iHP <= 3)
								CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice)*2);
							else CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice));
						}
					}

					if ( (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != 0) && 
						(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0) ) {
							iWepLifeOff = 1;
							if ((wWeaponType >= 1) && (wWeaponType < 40)) {
								switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
								case 0:	break;
								case 1:	if (iDice(1,3) == 1) iWepLifeOff++; break;
								case 2:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,2); break;
								case 3:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,3); break;
								}
							}

							if (m_pClientList[sAttackerH]->m_cSide != 0) {
								if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < iWepLifeOff) 
									m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
								else m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -= iWepLifeOff;

								SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_CURLIFESPAN, sWeaponIndex, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan, 0, 0);
							}

							if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0) {
								SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, 0, 0);
								ReleaseItemHandler(sAttackerH, sWeaponIndex, true);
							}
						}
			}
			else {
				if (wWeaponType == 0) {
					CalculateSSN_SkillIndex(sAttackerH, 5, 1);
				}
			}
		}
	}
	else {
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
		}
	}

	return iExp;
}

// October 19, 2004 - 3.51 translated
void CGame::_GrandMagicLaunchMsgSend(int iType, char cAttackerSide)
{
 /*char * cp, cBuff[120];
 WORD * wp;

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_GRANDMAGICLAUNCH;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)iType;
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)cAttackerSide;
	cp += 2;
	
	bStockMsgToGateServer(cBuff, 5);*/
}

// October 19, 2004 - 3.51 translated
bool CGame::_bNpcBehavior_ManaCollector(int iNpcH)
{
 int dX, dY, iMaxMP, iTotal;
 short sOwnerH;
 char  cOwnerType;
 double dV1, dV2, dV3;
 bool bRet;

	if (m_pNpcList[iNpcH] == 0) return false;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return false;

	bRet = false;
	for (dX = m_pNpcList[iNpcH]->m_sX-5; dX <= m_pNpcList[iNpcH]->m_sX+5; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-5; dY <= m_pNpcList[iNpcH]->m_sY+5; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if (sOwnerH != 0) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) {
					iMaxMP = iGetMaxMP(sOwnerH);
					if (m_pClientList[sOwnerH]->m_iMP < iMaxMP) {
						iTotal = iDice(1, (m_pClientList[sOwnerH]->m_iMag+ m_pClientList[sOwnerH]->m_iAngelicMag));
						if (m_pClientList[sOwnerH]->m_iAddMP != 0) {
							dV2 = (double)iTotal;
							dV3 = (double)m_pClientList[sOwnerH]->m_iAddMP;
							dV1 = (dV3 / 100.0f)*dV2;
							iTotal += (int)dV1;
						}

						m_pClientList[sOwnerH]->m_iMP += iTotal;
		
						if (m_pClientList[sOwnerH]->m_iMP > iMaxMP) 
							m_pClientList[sOwnerH]->m_iMP = iMaxMP;

						SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MP, 0, 0, 0, 0);
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if ((m_pNpcList[sOwnerH]->m_sType == 42) && (m_pNpcList[sOwnerH]->m_iV1 > 0)) {
					if (m_pNpcList[sOwnerH]->m_iV1 >= 3) {
						m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += 3;
						m_pNpcList[sOwnerH]->m_iV1 -= 3;
						bRet = true;
					}
					else {
						m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += m_pNpcList[sOwnerH]->m_iV1; 
						m_pNpcList[sOwnerH]->m_iV1 = 0;
						bRet = true;
					}
				}
				break;
			}
		}
	}
	return bRet;
}

// October 19, 2004 - 3.51 translated
void CGame::MeteorStrikeMsgHandler(char cAttackerSide)
{
 int i;
 DWORD dwTime = timeGetTime();
	
	switch (cAttackerSide) {
	case 1:
		if (m_iElvineMapIndex != -1) {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine") == 0) {
					SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 1, 0, 0, 0);
				}
				else {
					SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, 0, 0, 0);
				}
			}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, 0, dwTime + 5000, 0, 0, m_iElvineMapIndex, 0, 0, 0, 0, 0);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != 0) {
				SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, 0, 0, 0);
			}
		}
		break;

	case 2:
		if (m_iAresdenMapIndex != -1) {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete )) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden") == 0) {
					SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 3, 0, 0, 0);
				}
				else {
					SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, 0, 0, 0);
				}
			}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, 0, dwTime + 1000*5, 0, 0, m_iAresdenMapIndex, 0, 0, 0, 0, 0);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != 0) {
				SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, 0, 0, 0);
			}
		}
		break;
	}
}

// October 19, 2004 - 3.51 translated
void CGame::_NpcBehavior_GrandMagicGenerator(int iNpcH)
{
	switch (m_pNpcList[iNpcH]->m_cSide) {
	case 1:
		if (m_iAresdenMana > DEF_GMGMANACONSUMEUNIT) {
			m_iAresdenMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				_GrandMagicLaunchMsgSend(1, 1);
				MeteorStrikeMsgHandler(1);
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iAresdenMana = 0;
			}
			wsprintf(G_cTxt, "(!) Aresden GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			PutLogList(G_cTxt);
		}
		break;

	case 2:
		if (m_iElvineMana > DEF_GMGMANACONSUMEUNIT) {
			m_iElvineMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				_GrandMagicLaunchMsgSend(1, 2);
				MeteorStrikeMsgHandler(2);
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iElvineMana = 0;
			}
			wsprintf(G_cTxt, "(!) Elvine GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			PutLogList(G_cTxt);
		}
		break;
	}
}

// October 19, 2004 - 3.51 translated
bool CGame::_bNpcBehavior_Detector(int iNpcH)
{
int dX, dY;
 short sOwnerH;
 char  cOwnerType, cSide;
 bool  bFlag = false;
                       
	if (m_pNpcList[iNpcH] == 0) return false;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return false;

	for (dX = m_pNpcList[iNpcH]->m_sX-10; dX <= m_pNpcList[iNpcH]->m_sX+10; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-10; dY <= m_pNpcList[iNpcH]->m_sY+10; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		cSide = 0;
		if (sOwnerH != 0) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				cSide = m_pClientList[sOwnerH]->m_cSide;
				break;

			case DEF_OWNERTYPE_NPC:
				cSide = m_pNpcList[sOwnerH]->m_cSide;
				break;
			}
		}

		if ((cSide != 0) && (cSide != m_pNpcList[iNpcH]->m_cSide)) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) {
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = 0;
					SetInvisibilityFlag(sOwnerH, cOwnerType, false);			
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) {
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = 0;
					SetInvisibilityFlag(sOwnerH, cOwnerType, false);			
				}
				break;
			}
			
			bFlag = true;
		}
	}

	return bFlag;
}

// October 19,2004 - 3.51 translated
void CGame::NpcBehavior_Dead(int iNpcH)			   
{
 DWORD dwTime;

	if (m_pNpcList[iNpcH] == 0) return; 

	dwTime = timeGetTime();
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
	}

	if ((dwTime - m_pNpcList[iNpcH]->m_dwDeadTime) > m_pNpcList[iNpcH]->m_dwRegenTime)
		DeleteNpc(iNpcH);
}

bool CGame::bGetItemNameWhenDeleteNpc(int & iItemID, short sNpcType)
{ 
	int iResult; 

	switch (sNpcType) { 
		case 49: // Hellclaw 
			iResult = iDice(1,20000);
			if ((iResult >= 1) && (iResult <=  5000)) iItemID = 308 ;	    // MagicNecklace(MS10)
			else if ((iResult > 5000)  && (iResult <= 10000))  iItemID = 259 ;  // MagicWand(M.Shield)
			else if ((iResult > 10000) && (iResult <= 13000))  iItemID = 337 ;  // RubyRing
			else if ((iResult > 13000) && (iResult <= 15000))  iItemID = 335 ;  // EmeraldRing
			else if ((iResult > 15000) && (iResult <= 17500))  iItemID = 300 ;  // MagicNecklace(RM10)
			else if ((iResult > 17500) && (iResult <= 18750))  iItemID = 311 ;  // MagicNecklace(DF+10)
			else if ((iResult > 18750) && (iResult <= 19000))  iItemID = 305 ;  // MagicNecklace(DM+1)
			else if ((iResult > 19000) && (iResult <= 19700))  iItemID = 634 ;  // RingofWizard
			else if ((iResult > 19700) && (iResult <= 19844))  iItemID = 635 ;  // RingofMage
			else if ((iResult > 19844) && (iResult <= 19922))  iItemID = 614 ;  // SwordofIceElemental
			else if ((iResult > 19922) && (iResult <= 19961))  iItemID = 640 ;  // KnecklaceOfSufferent
			else if ((iResult > 19961) && (iResult <= 19981))  iItemID = 637 ;  // KnecklaceOfLightPro
			else if ((iResult > 19981) && (iResult <= 19991))  iItemID = 620 ;  // MerienShield
			else if ((iResult > 19991) && (iResult <= 19996))  iItemID = 644 ;  // KnecklaceOfAirEle
			else if ((iResult > 19996) && (iResult <= 19999))  iItemID = 643 ;  // KnecklaceOfIceEle
			else if ((iResult > 19999) && (iResult <= 20000))  iItemID = 636 ;  // RingofGrandMage
			return true;
		
		case 50: // Tigerworm
			iResult = iDice(1,10000);
			if ((iResult >= 1) && (iResult <= 4999)) {
				if (iDice(1,2) == 1) 
					 iItemID = 311 ;  // MagicNecklace(DF+10)
				else iItemID = 305 ;      // MagicNecklace(DM+1)
			}
			else if ((iResult > 5000) && (iResult <= 7499))  iItemID = 614 ;  // SwordofIceElemental
			else if ((iResult > 7500) && (iResult <= 8749))  iItemID = 290 ;  // Flameberge+3(LLF)
			else if ((iResult > 8750) && (iResult <= 9374))  iItemID = 633 ;  // RingofDemonpower
			else if ((iResult > 9375) && (iResult <= 9687))  iItemID = 492 ;  // BloodRapier
			else if ((iResult > 9688) && (iResult <= 9843))  iItemID = 490 ;  // BloodSword
			else if ((iResult > 9844) && (iResult <= 9921))  iItemID = 491 ;  // BloodAxe
			else if ((iResult > 9922) && (iResult <= 9960))  iItemID = 947 ;  // DragonWand(MS40)
			else if ((iResult > 9961) && (iResult <= 9980))  iItemID = 643 ;  // KnecklaceOfIceEle
			else if ((iResult > 9981) && (iResult <= 9990))  iItemID = 612 ;  // XelimaRapier
			else if ((iResult > 9991) && (iResult <= 9996))  iItemID = 610 ;  // XelimaBlade
			else if ((iResult > 9996) && (iResult <= 9998))  iItemID = 611 ;  // XelimaAxe
			else if ((iResult > 9999) && (iResult <= 10000)) iItemID = 631 ;  // RingoftheAbaddon
			return true;

			default:
		   break; 
		}

	if (iDice(1,45) == 13) {
		switch (sNpcType) {
		case 11: if (iDice(1,465) != 11) return false; break;	  // Skeleton   2 * 100	
		case 12: if (iDice(1,340) != 11) return false; break;	  // Stone-Golem 2 * 100	
		case 13: if (iDice(1,85)  != 11) return false; break;	  // Cyclops  6 * 100	
		case 14: if (iDice(1,595) != 11) return false; break;	  // Orc 4 * 100	
		case 17: if (iDice(1,510) != 11) return false; break;	  // Scorpoin 5 * 100	
		case 18: if (iDice(1,720) != 11) return false; break;	  // Zombie 1 * 100	
		case 22: if (iDice(1,510) != 11) return false; break;	  // Amphis 5 * 100	
		case 23: if (iDice(1,340) != 11) return false; break;	  // Clay-Golem 2 * 100	
		case 27: if (iDice(1,85)  != 11) return false; break;	  // Hellhound 7 * 100	
		case 28: if (iDice(1,85)  != 11) return false; break;	  // Troll 5 * 100	
		case 29: if (iDice(1,125) != 11) return false; break;	  // Orge  7 * 100	
		case 30: if (iDice(1,100) != 11) return false; break;	  // Liche 1 * 100   
		case 31: if (iDice(1,120) != 11) return false; break;	  // Demon 5 * 100
		case 32: if (iDice(1,170) != 11) return false; break;	  // Unicorn 5 * 100	
		case 33: if (iDice(1,255) != 11) return false; break;	  // WereWolf 7 * 100
		case 48: if (iDice(1,80)  != 11) return false; break;	  // Stalker 
		case 52: if (iDice(1,255) != 11) return false; break;     // Gagoyle
		case 53: if (iDice(1,425) != 11) return false; break;	  // Beholder
		case 54: if (iDice(1,200) != 11) return false; break;	  // Dark-Elf
		case 57: if (iDice(1,400) != 11) return false; break;	  // Giant-Frog
		case 63: if (iDice(1,300) != 11) return false; break;	  // Frost
		case 79: if (iDice(1,170) != 11) return false; break;	  // Nizie
		case 70: if (iDice(1,170) != 11) return false; break;	  // Barlog
		case 71: if (iDice(1,170) != 11) return false; break;	  // Centaurus
		case 74: if (iDice(1,170) != 11) return false; break;	  // Giant-Crayfish
		case 72: if (iDice(1,170) != 11) return false; break;	  // Claw-Turtle
		case 75: if (iDice(1,170) != 11) return false; break;	  // Giant-Lizard
		case 77: if (iDice(1,170) != 11) return false; break;	  // MasterMage-Orc
		case 78: if (iDice(1,170) != 11) return false; break;	  // Minotaurs
		case 59: if (iDice(1,120) != 11) return false; break;	  // Ettin
		default: return false;
		}
	}
	else return false;
//http://www.helbreath.com/down/d_patch_v2.htm

	switch (sNpcType) {
	case 11: // Skeleton
	case 17: // Scorpoin
	case 14: // Orc
	case 28: // Troll
	case 57: // Giant-Frog
		switch (iDice(1,7)) {
		case 1: iItemID = 334 ; break; // LuckyGoldRing
		case 2: iItemID = 336 ; break; // SapphireRing
		case 3: if (iDice(1,15) == 3) iItemID = 335 ; break; // EmeraldRing
		case 4: iItemID = 337 ; break; // RubyRing
		case 5: iItemID = 333 ; break; // PlatinumRing
		case 6: if (iDice(1,15) == 3) iItemID = 634 ; break; // RingofWizard
		case 7: if (iDice(1,25) == 3) iItemID = 635 ; break; // RingofMage
		}
		break;
	
	case 13: // Cyclops
	case 27: // Hellhound
	case 29: // Orge
		switch (iDice(1,7)) {
		case 1: iItemID = 311 ; break; // MagicNecklace(DF+10)
		case 2: if (iDice(1,15) == 13) iItemID = 308 ; break; // MagicNecklace(MS10)
		case 3: if (iDice(1,5) == 3) iItemID = 305 ; break; // MagicNecklace(DM+1)
		case 4: iItemID = 300 ; break; // MagicNecklace(RM10)
		case 5: if (iDice(1,25) == 13) iItemID = 632 ; break; // RingofOgrepower
		case 6: if (iDice(1,25) == 13) iItemID = 637 ; break; // KnecklaceOfLightPro
		case 7: if (iDice(1,25) == 13) iItemID = 638 ; break; // KnecklaceOfFirePro
			}
		break;

	case 18: // Zombie
	case 22: // Amphis
		switch (iDice(1,4)) {
		case 1: if (iDice(1,65) == 13) iItemID = 613 ; break; // SwordofMedusa
		case 2: if (iDice(1,15) == 13) iItemID = 639 ; break; // KnecklaceOfPoisonPro
		case 3: if (iDice(1,30) == 13) iItemID = 641 ; break; // KnecklaceOfMedusa
		case 4: if (iDice(1,25) == 13) iItemID = 640 ; break; // KnecklaceOfSufferent
		}
		break;

	case 12: // Stone-Golem
		switch (iDice(1,5)) {
		case 1: if (iDice(1,20) == 13) iItemID = 738 ; break; // BerserkWand(MS.10)
		case 2: if (iDice(1,30) == 13) iItemID = 621 ; break; // MerienPlateMailM
		case 3: if (iDice(1,30) == 13) iItemID = 622 ; break; // MerienPlateMailW
		case 4: if (iDice(1,15) == 13) iItemID = 644 ; break; // KnecklaceOfAirEle
		case 5: if (iDice(1,15) == 13) iItemID = 647 ; break; // KnecklaceOfStoneGolem
		}
		break;

	case 23: // Clay-Golem
		switch (iDice(1,4)) {
		case 1: if (iDice(1,20) == 13) iItemID = 738 ; break; // BerserkWand(MS.10)	
		case 2: if (iDice(1,30) == 13) iItemID = 621 ; break; // MerienPlateMailM
		case 3: if (iDice(1,30) == 13) iItemID = 622 ; break; // MerienPlateMailW
		case 4: if (iDice(1,15) == 13) iItemID = 647 ; break; // KnecklaceOfStoneGolem
		}
		break;

	case 32: // Unicorn
		switch (iDice(1,4)) {
		case 1: if (iDice(1,30) == 13) iItemID = 620 ; break; // MerienShield	
		case 2: if (iDice(1,30) == 13) iItemID = 621 ; break; // MerienPlateMailM
		case 3: if (iDice(1,30) == 13) iItemID = 622 ; break; // MerienPlateMailW
		case 4: if (iDice(1,15) == 13) iItemID = 644 ; break; // KnecklaceOfAirEle
		}
		break;
		
	case 33: // WereWolf
	case 48: // Stalker
		switch (iDice(1,4)) {
		case 1: if (iDice(1,20) == 13) iItemID = 852 ; break; // CancelManual
		case 2: if (iDice(1,20) == 13) iItemID = 857 ; break; // I.M.CManual
		case 3: if (iDice(1,20) == 13) iItemID = 853 ; break; // E.S.W Manual
		case 4: iItemID = 620 ; break; // MerienShield
		}
		break;

	case 30: // Liche
		switch (iDice(1,6)) {
		case 1: if (iDice(1,15) == 13) iItemID = 852 ; break; // CancelManual
		case 2: iItemID = 380 ; break; // IceStormManual
		case 3: if (iDice(1,15) == 13) iItemID = 853 ; break; // E.S.W Manual
		case 4: if (iDice(1,30) == 13) iItemID = 643 ; break; // KnecklaceOfIceEle	
		case 5: if (iDice(1,15) == 13) iItemID = 648 ; break; // NecklaceOfLiche
		case 6: if (iDice(1,20) == 13) iItemID = 734 ; break; // RingOfArcmage
		}
		break;

	case 31: // Demon 
		switch (iDice(1,8)) {
		case 1: if (iDice(1,5)  == 3) iItemID = 382 ; break; // BloodyShockW.Manual
		case 2: iItemID = 491 ; break; // BloodAxe
		case 3: if (iDice(1,5)  == 3) iItemID = 490 ; break; // BloodSword
		case 4: iItemID = 492 ; break; // BloodRapier
		case 5: if (iDice(1,5)  == 3) iItemID = 381 ; break; // MassFireStrikeManual
		case 6: if (iDice(1,15) == 3) iItemID = 633 ; break; // RingofDemonpower
		case 7: if (iDice(1,10) == 3) iItemID = 645 ; break; // KnecklaceOfEfreet
		case 8: if (iDice(1,15) == 3) iItemID = 616 ; break; // DemonSlayer
		}
		break;

	case 52: // Gagoyle
		switch (iDice(1,11)) {
		case 1: if (iDice(1,5)  == 3) iItemID = 382 ; break; // BloodyShockW.Manual	
		case 2: if (iDice(1,15) == 13) iItemID = 610 ; break; // XelimaBlade	
		case 3: if (iDice(1,15) == 13) iItemID = 611 ; break; // XelimaAxe	
		case 4: if (iDice(1,15) == 13) iItemID = 612 ; break; // XelimaRapier
		case 5: if (iDice(1,5)  == 3) iItemID = 381 ; break; // MassFireStrikeManual
		case 6: if (iDice(1,15) == 13) iItemID = 633 ; break; // RingofDemonpower
		case 7: if (iDice(1,10) == 3) iItemID = 645 ; break; // KnecklaceOfEfreet
		case 8: if (iDice(1,30) == 13) iItemID = 630 ; break; // RingoftheXelima	
		case 9: if (iDice(1,40) == 13) iItemID = 631 ; break; // RingoftheAbaddon
		case 10: if (iDice(1,20) == 13) iItemID = 735; break; // RingOfDragonpower
		case 11: if (iDice(1,30) == 13) iItemID = 20 ; break; // Excalibur
		}
		break;

	case 53: // Beholder
		if (iDice(1,10) == 11) iItemID = 380 ; break; // IceStormManual	
		break;

	case 54: // Dark-Elf
		switch (iDice(1,4)) {
		case 1: if (iDice(1,20) == 13) iItemID = 618 ; break; // DarkElfBow	
		case 2: if (iDice(1,15) == 13) iItemID = 958 ; break; // DrowBoots
		case 3: if (iDice(1,15) == 11) iItemID = 956 ; break; // DrowChainM
		case 4: if (iDice(1,15) == 11) iItemID = 957 ; break; // DrowChainW
		}
		break;

	case 63: // Frost
		switch (iDice(1,3)) {
		case 1: if (iDice(1,20) == 13) iItemID = 943 ; break; // IceAxe	
		case 2: if (iDice(1,20) == 13) iItemID = 942 ; break; // IceHammer
		case 3: if (iDice(1,30) == 11) iItemID = 732 ; break; // BerserkWand(MS.20)
		}
		break;

	case 79: // Nizie
		switch (iDice(1,3)) {
		case 1: if (iDice(1,20) == 13) iItemID = 943 ; break; // IceAxe	
		case 2: if (iDice(1,20) == 13) iItemID = 942 ; break; // IceHammer
		case 3: if (iDice(1,30) == 11) iItemID = 732 ; break; // BerserkWand(MS.20)
		}		
		break;

	case 70: // Barlog
		switch (iDice(1,3)) {
		case 1: if (iDice(1,5)  == 3) iItemID = 382 ; break; // BloodyShockW.Manual
		case 2: if (iDice(1,5)  == 3) iItemID = 381 ; break; // MassFireStrikeManual
		case 3: if (iDice(1,30) == 13) iItemID = 732 ; break; // BerserkWand(MS.20)
		}
		break;

	case 71: // Centaurus
		switch (iDice(1,2)) {
		case 1: if (iDice(1,20) == 13) iItemID = 735 ; break; // RingOfDragonpower
		case 2: if (iDice(1,30) == 13) iItemID = 732 ; break; // BerserkWand(MS.20)
		}
		break;

	case 59: // Ettin
		switch (iDice(1,3)) {
		case 1: if (iDice(1,20) == 13) iItemID = 735 ; break; // RingOfDragonpower
		case 2: if (iDice(1,10) == 13) iItemID = 853 ; break; // E.S.W.Manual
		case 3: if (iDice(1,7)  == 3) iItemID = 382 ; break; // BloodyShockW.Manual
		}
		break;

	} 

	if (iItemID == 0) 
		return false; 
	else return true; 
}

/*
void CGame::StormBringer(int iClientH, short dX, short dY)
{
	char cOwnerType;
	short sOwner, sAppr2, sAttackerWeapon;
	int  iDamage, iTemp, iV1, iV2, iV3;

	//ArchAngel Fix

	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

		iTemp = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]; 
		sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

		if (memcmp(m_pClientList[iClientH]->m_pItemList[iTemp]->m_cName, "StormBringer", 12) == 0){ 

			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner]->m_iAdminUserLevel < 3) {
					if (sAppr2 != 0) {
						iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_L;
						iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_L;
						iV3 = m_pClientList[iClientH]->m_cAttackBonus_L;

						if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0){
							iDamage = iDice(iV1*2,iV2*2)+iV3;
						}					
						else{
							iDamage = iDice(iV1,iV2)+iV3;
						}

						m_pClientList[sOwner]->m_iHP -= iDamage;
						if (m_pClientList[sOwner]->m_iHP <= 0){
							sAttackerWeapon = 1;
							m_pClientList[sOwner]->m_iHP = 0;

							m_pClientList[sOwner]->m_bIsKilled = true;
							m_pClientList[sOwner]->m_iLastDamage = iDamage;
							SendNotifyMsg(0, sOwner, DEF_NOTIFY_HP, 0, 0, 0, 0);
							SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, iDamage, sAttackerWeapon, 0);
							m_pMapList[m_pClientList[sOwner]->m_cMapIndex]->ClearOwner(14, sOwner, DEF_OWNERTYPE_PLAYER, m_pClientList[sOwner]->m_sX, m_pClientList[sOwner]->m_sY);
							m_pMapList[m_pClientList[sOwner]->m_cMapIndex]->SetDeadOwner(sOwner, DEF_OWNERTYPE_PLAYER, m_pClientList[sOwner]->m_sX, m_pClientList[sOwner]->m_sY);
						}
						else{
							SendNotifyMsg(0, sOwner, DEF_NOTIFY_HP, 0, 0, 0, 0);	
							SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
						}
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (sAppr2 != 0) {
					if (m_pNpcList[sOwner]->m_cSize == 0){
						iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_SM;
						iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_SM;
						iV3 = m_pClientList[iClientH]->m_cAttackBonus_SM;
					}
					else if (m_pNpcList[sOwner]->m_cSize == 1){
						iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_L;
						iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_L;
						iV3 = m_pClientList[iClientH]->m_cAttackBonus_L;
					}

					if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0){
						iDamage = iDice(iV1*2,iV2*2)+iV3;
					}
					else{
						iDamage = iDice(iV1,iV2)+iV3;
					}

					m_pNpcList[sOwner]->m_iHP -= iDamage;
					if (m_pNpcList[sOwner]->m_iHP <= 0){
						sAttackerWeapon = 1;
						m_pNpcList[sOwner]->m_iHP = 0;

						m_pNpcList[sOwner]->m_sBehaviorTurnCount = 0;
						m_pNpcList[sOwner]->m_cBehavior = DEF_BEHAVIOR_DEAD;
						m_pNpcList[sOwner]->m_dwDeadTime = timeGetTime();
						SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, iDamage, sAttackerWeapon, 0);
						m_pMapList[m_pNpcList[sOwner]->m_cMapIndex]->ClearOwner(10, sOwner, DEF_OWNERTYPE_NPC, m_pNpcList[sOwner]->m_sX, m_pNpcList[sOwner]->m_sY);
						m_pMapList[m_pNpcList[sOwner]->m_cMapIndex]->SetDeadOwner(sOwner, DEF_OWNERTYPE_NPC, m_pNpcList[sOwner]->m_sX, m_pNpcList[sOwner]->m_sY);
					}
					else{
						SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
					}	
				}
				break;
			}
		}
	}
}*/

bool CGame::_bCheckCharacterData(int iClientH)
{
 int i;

	if ((m_pClientList[iClientH]->m_iStr > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iVit > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iDex > m_sCharStatLimit) ||
        (m_pClientList[iClientH]->m_iMag > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iInt > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iCharisma > m_sCharStatLimit)) {
		try
		{
			wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) stat points are greater then server accepts.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch(...)
		{

		}
	}
				
	if ((m_pClientList[iClientH]->m_iLevel > m_iPlayerMaxLevel) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		try
		{
			wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) level above max server level.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch(...)
		{

		}
	}

	if (m_pClientList[iClientH]->m_iExp < 0) {
		try
		{
			wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) experience is below 0 - (Exp:%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iExp);
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch(...)
		{

		}
	}

	if ((m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		try
		{
			if(m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND])] != 0) {
				if((m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND])]->m_sIDnum == 492) || (m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND])]->m_sIDnum == 491)) {
					if (m_pClientList[iClientH]->m_iHP > (4*(iGetMaxHP(iClientH)/5))) {

					}
				}
			} else if (m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND])] != 0) {
				if((m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND])]->m_sIDnum == 490)) {
					if (m_pClientList[iClientH]->m_iHP > (4*(iGetMaxHP(iClientH)/5))) {

					}
				}
			} else {
				wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) HP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iHP, iGetMaxHP(iClientH));
				PutHackLogFileList(G_cTxt);
				return false;
			}
		}
		catch(...)
		{
			
		}
	}

	if ((m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		try
		{
			wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) MP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iMP, iGetMaxMP(iClientH));
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch(...)
		{

		}
	}

	if ((m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		try
		{
			wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) SP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iSP, iGetMaxSP(iClientH));
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch(...)
		{

		}
	}

	try
	{
		for (i = 0; i < DEF_MAXBANNED; i++) {
			if(strlen(m_stBannedList[i].m_cBannedIPaddress) == 0) break; //No more GM's on list
			if ((strlen(m_stBannedList[i].m_cBannedIPaddress)) == (strlen(m_pClientList[iClientH]->m_cIPaddress))) {
				if(memcmp(m_stBannedList[i].m_cBannedIPaddress, m_pClientList[iClientH]->m_cIPaddress, strlen(m_pClientList[iClientH]->m_cIPaddress)) == 0){
					wsprintf(G_cTxt,"Client Rejected: Banned: (%s)", m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					return false;
				}
				else {

				}
			}
			}
		}
	catch(...)
	{

	}

	return true;
}

void CGame::GlobalEndHeldenianMode()
{
 //char * cp, cData[32];

	if (m_bIsHeldenianMode == false) return;

	//ZeroMemory(cData, sizeof(cData));
	//cp = (char *)cData;
	//*cp = GSM_ENDHELDENIAN; // 22
	//cp++;
	//
	//bStockMsgToGateServer(cData, 1);
	LocalEndHeldenianMode();

}

void CGame::LocalEndHeldenianMode()
{
 int i, x, n;
	
	if (m_bIsHeldenianMode == false) return;
	m_bIsHeldenianMode = false;
	m_bHeldenianInitiated = true;
	
	m_dwHeldenianFinishTime = time(0);
	if (var_88C == 1) {
		if (m_cHeldenianModeType == 1) {
			if (m_iHeldenianAresdenLeftTower > m_iHeldenianElvineLeftTower) {
				m_cHeldenianVictoryType = 1;
			}
			else if (m_iHeldenianAresdenLeftTower < m_iHeldenianElvineLeftTower) {
				m_cHeldenianVictoryType = 2;
			}
			else if (m_iHeldenianAresdenDead < m_iHeldenianElvineDead) {
				m_cHeldenianVictoryType = 1;
			}
			else if (m_iHeldenianAresdenDead > m_iHeldenianElvineDead) {
				m_cHeldenianVictoryType = 2;
			}
			else {
				m_sLastHeldenianWinner = m_cHeldenianVictoryType;
			}
		}
		else if (m_cHeldenianModeType == 2) {
			m_sLastHeldenianWinner = m_cHeldenianVictoryType;
		}
		m_sLastHeldenianWinner = m_cHeldenianVictoryType;
		if (bNotifyHeldenianWinner() == false) {
			wsprintf(G_cTxt, "(!) HELDENIAN End. Result Report Failed");
			PutLogList(G_cTxt);
		}
	}
	wsprintf(G_cTxt, "(!) HELDENIAN End. %d", m_sLastHeldenianWinner);
	PutLogList(G_cTxt);

	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((i < 0) || (i > 100)) break;
	if (m_pMapList[i] != 0) {
		for (x = 0; x < DEF_MAXCLIENTS; x++)
		if ((m_pClientList[x] != 0) && (m_pClientList[x]->m_bIsInitComplete )) {
			SendNotifyMsg(0, x, DEF_NOTIFY_HELDENIANEND, 0, 0, 0, 0);
			if (m_pMapList[m_pClientList[x]->m_cMapIndex]->m_bIsHeldenianMap ) {
				for (n = 0; n < DEF_MAXNPCS; n++)
				if ((m_pNpcList[n] != 0) && (m_pMapList[m_pNpcList[n]->m_cMapIndex] != 0) && (m_pNpcList[n]->m_bIsSummoned )) {
					RemoveHeldenianNpc(n);
				}
				RemoveOccupyFlags(x);
			}
		}
	}
	_CreateHeldenianGUID(m_dwHeldenianGUID, m_cHeldenianVictoryType);
}

bool CGame::bNotifyHeldenianWinner()
{
	if (var_88C == 0) {
		bSendMsgToLS(MSGID_REQUEST_HELDENIAN_WINNER, 0, 1, 0);
		return true;
	}
	else {
		return false;
	}

}

void CGame::RemoveHeldenianNpc(int iNpcH)
{
	if (m_pNpcList[iNpcH] == 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled ) return;

	m_pNpcList[iNpcH]->m_bIsKilled = true;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = 0;
	m_pNpcList[iNpcH]->m_dwRegenTime = 0;
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC);
	m_pNpcList[iNpcH]->m_iTargetIndex = 0;
	m_pNpcList[iNpcH]->m_cTargetType = 0;
			
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, 1, 0);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pNpcList[iNpcH]->m_cBehavior = 4;
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();

}

void CGame::RemoveOccupyFlags(int iMapIndex)
{
 DWORD dwTime = timeGetTime();
 int i;
 short dX, dY;
 int iDynamicObjectIndex;
 class COccupyFlag * iOccupyFlagIndex;
 class CTile * pTile;
 int iy, ix;

 if (m_pMapList[iMapIndex] == 0) return;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) 
	//if (m_pMapList[iMapIndex]->m_pOccupyFlag[i]) return; // centu : wtf ?
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i]) {
		dX = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
		dY = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
		pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + dX + dY*m_pMapList[iMapIndex]->m_sSizeY);
		m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;
		iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
		if (m_pDynamicObjectList[iDynamicObjectIndex] == 0) return;

		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
			m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
			m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, 0, (short)0);

		m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);
		
		iOccupyFlagIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i];

		if (m_pDynamicObjectList[iDynamicObjectIndex] == 0) {
			for (ix = dX - 2; ix <= dX + 2; ix++)
			for (iy = dY - 2; iy <= dY + 2; iy++) {
				pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + ix + iy*m_pMapList[iMapIndex]->m_sSizeY);
				pTile->m_sOwner = 0;
			}
		}
	}
}

void CGame::_CreateHeldenianGUID(DWORD dwHeldenianGUID, int iWinnerSide)
{
 char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;
		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"HeldenianGUID.Txt");
		
	pFile = fopen(cFn, "wt");
	if (pFile == 0) {
		wsprintf(cTxt, "(!) Cannot create HeldenianGUID(%d) file", dwHeldenianGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "HeldenianGUID = %d", dwHeldenianGUID);
		strcat(cTemp, cTxt);

		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) HeldenianGUID(%d) file created", dwHeldenianGUID);
		PutLogList(cTxt);
	}
	if (pFile != 0) fclose(pFile);
}

/*********************************************************************************************************************
**  bool CGame::bCheckHeldenianMap(int sAttackerH, int iMapIndex, char cType)										**
**  description			:: checks if the player is in the specified map												**
**  last updated		:: November 22, 2004; 6:19 PM; Hypnotoad													**
**	return value		:: bool																						**
**  commentary			::	-	translated from scratch using IDA Pro												**
**						::	-	changed pTile->m_cOwner to m_iOccupyStatus											**
**						::	-	added check to prevent access violation if pTile == 0							**
**						::	-	removed 4 return(s) after "iRet = 1;" and placed at end								**
*********************************************************************************************************************/
bool CGame::bCheckHeldenianMap(int sAttackerH, int iMapIndex, char cType) 
{
 short tX, tY;
 int iRet;
 class CTile * pTile;

	iRet = 0;
	if (m_pClientList[sAttackerH] == 0) return 0;
	if ((m_bIsHeldenianMode == 1) || (m_cHeldenianType == 1)) {
		if (cType == DEF_OWNERTYPE_PLAYER) {
			if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) && (m_pClientList[sAttackerH]->m_cSide > 0)) {
				tX = m_pClientList[sAttackerH]->m_sX;
				tY = m_pClientList[sAttackerH]->m_sY;
				if ((tX < 0) || (tX >= m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeX) || 
					(tY < 0) || (tY >= m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeY)) return 0;
				pTile = (class CTile *)(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_pTile + tX + tY*m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeY);
				if (pTile == 0) return 0;
				if (pTile->m_iOccupyStatus != 0) {
					if (pTile->m_iOccupyStatus < 0) {
						if (m_pClientList[sAttackerH]->m_cSide == 1) {
							iRet = 1;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						if (m_pClientList[sAttackerH]->m_cSide == 2) {
							iRet = 1;
						}
					}
				}
			}
		} 
		else if (cType == DEF_OWNERTYPE_NPC) {
			if ((m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex] != 0) && (iMapIndex != -1) && (m_pNpcList[sAttackerH]->m_cSide > 0)) {
				tX = m_pNpcList[sAttackerH]->m_sX;
				tY = m_pNpcList[sAttackerH]->m_sY;
				pTile = (class CTile *)(m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_pTile + tX + tY*m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_sSizeY);
				if (pTile == 0) return 0;
				if (pTile->m_iOccupyStatus != 0) {
					if (pTile->m_iOccupyStatus < 0) {
						if (m_pNpcList[sAttackerH]->m_cSide == 1) {
							iRet = 1;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						if (m_pNpcList[sAttackerH]->m_cSide == 2) {
							iRet = 1;
						}
					}
				}
			}
		}
	}
	return iRet;
}

void CGame::RequestHeldenianTeleport(int iClientH, char * pData, DWORD dwMsgSize)
{
 char cTmpName[21], * cp, cTxt[512], cMapName[11];
 short tX, tY, cLoc, * sp;
 WORD wResult;
 int iRet, iWhyReturn, iProcessed;

	iProcessed = 1;
	if (m_pClientList[iClientH] == 0) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	if (strcmp(cTmpName, "Gail") == 0) {
		ZeroMemory(cTxt, sizeof(cTxt));
		if ((m_bIsHeldenianMode == 1) && (m_pClientList[iClientH]->m_bIsPlayerCivil != true) && (m_pClientList[iClientH]->m_cSide == 2 || m_pClientList[iClientH]->m_cSide ==1 )) {
			if (m_cHeldenianType == 1) {
				ZeroMemory(cMapName, sizeof(cMapName));
				memcpy(cMapName, "BtField", 10);
				if (m_pClientList[iClientH]->m_cSide == 1) {
					tX = 68;
					tY = 225;
					cLoc = 1;
				}
				else if (m_pClientList[iClientH]->m_cSide == 2) {
					tX = 202;
					tY = 70;
					cLoc = 2;
				}
			}
			else if (m_cHeldenianType == 2) {
				ZeroMemory(cMapName, sizeof(cMapName));
				memcpy(cMapName, "HRampart", 10);
				if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) {
					tX = 81;
					tY = 42;
					cLoc = 3;
				}
				else {
					tX = 156;
					tY = 153;
					cLoc = 4;
				}
			}
		wResult = DEF_MSGTYPE_CONFIRM;
		iProcessed = 1;
		iWhyReturn = 0;
		}
	}
	
	wResult = DEF_MSGTYPE_REJECT;
	iProcessed = 0;
	iWhyReturn = 0;

	sp = (short *)cp;
	*sp = 4; 
	cp += 4;

	sp = (short *)cp;
	*sp = cLoc; 
	cp += 4;

	memcpy(cp, cMapName, 10);
	cp += 10;

	sp = (short *)cp;
	*sp = tX; 
	cp += 4;

	sp = (short *)cp;
	*sp = tY; 
	cp += 4;

	sp = (short *)cp;
	*sp = iWhyReturn; 
	cp += 4;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTxt, 36);
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			break;
	}
}

void CGame::HeldenianWarStarter()
{
 SYSTEMTIME SysTime;
 int i;
	
	GetLocalTime(&SysTime);
	if (var_89C ) return;
	if (var_8A0 == false) return;

	for (i = 0; i < DEF_MAXSCHEDULE; i++) 
		if (m_bIsApocalypseMode ) return;
		if (m_bIsCrusadeMode ) return;
		if ((m_stHeldenianSchedule[i].iDay != SysTime.wDayOfWeek) &&
			(m_stHeldenianSchedule[i].StartiHour != SysTime.wHour) &&
			(m_stHeldenianSchedule[i].StartiMinute != SysTime.wMinute)) {
			wsprintf(G_cTxt,"Heldenian Start : time(%d %d:%d), index(%d)",SysTime.wDayOfWeek, SysTime.wHour, SysTime.wMinute, i);
			PutLogFileList(G_cTxt);
			var_8A0 = true;
			GlobalStartHeldenianMode();
		}
}

void CGame::HeldenianWarEnder()
{
 SYSTEMTIME SysTime;
 int i;
	
	GetLocalTime(&SysTime);

	for (i = 0; i < DEF_MAXSCHEDULE; i++) 
		if (var_89C != true) return;
		if (var_8A0 != true) return;
		if ((m_stHeldenianSchedule[i].iDay != SysTime.wDayOfWeek) &&
			(m_stHeldenianSchedule[i].EndiHour != SysTime.wHour) &&
			(m_stHeldenianSchedule[i].EndiMinute != SysTime.wMinute)) {
			wsprintf(G_cTxt,"Heldenian End : time(%d %d:%d), index(%d)",SysTime.wDayOfWeek, SysTime.wHour, SysTime.wMinute, i);
			PutLogFileList(G_cTxt);
			if (m_cHeldenianModeType == 2) {
				m_cHeldenianVictoryType = m_sLastHeldenianWinner;
			}
			GlobalEndHeldenianMode();
		}
}

void CGame::GlobalStartHeldenianMode()
{
 char cData[120], * cp;
 DWORD dwTime, * dwp;
 WORD * wp;

	dwTime = timeGetTime();
	//ZeroMemory(cData,sizeof(cData));

	//cp = (char *)cData;
	//*cp = GSM_STARTHELDENIAN; // 21
	//cp++;
	//
	//wp  = (WORD *)cp;
	//*wp = m_cHeldenianModeType;
	//cp += 2;

	//wp  = (WORD *)cp;
	//*wp = m_sLastHeldenianWinner;
	//cp += 2;

	//dwp = (DWORD *)cp;
	//*dwp = dwTime;
	//cp += 4;

	//bStockMsgToGateServer(cData, 9);
	LocalStartHeldenianMode(m_cHeldenianModeType, m_sLastHeldenianWinner, dwTime);

}

/*********************************************************************************************************************
**  void CGame::LocalStartHeldenianMode(short sV1, short sV2, DWORD dwHeldenianGUID)								**
**  description			:: localy performs all required tasks upon recieving heldenian initiate message				**
**  last updated		:: December 10, 2004; 12:02 PM; Hypnotoad													**
**	return value		:: void																						**
**  commentary			::	-	translated from scratch using official 3.51 chinese hgserver						**
*********************************************************************************************************************/
void CGame::LocalStartHeldenianMode(short sV1, short sV2, DWORD dwHeldenianGUID)
{
 int i, x, z, iNamingValue;
 char cName[11], cTmp[21], cNpcWaypointIndex[10], cSide, cOwnerType;
 short sOwnerH;
 bool bRet;
 int dX, dY;

	if (m_bIsHeldenianMode ) return;

	if ((m_cHeldenianModeType == -1) || (m_cHeldenianModeType != sV1)) m_cHeldenianModeType = sV1;
	if ((m_sLastHeldenianWinner != -1) && (m_sLastHeldenianWinner == sV2)) {
		wsprintf(G_cTxt,"Heldenian Mode : %d , Heldenian Last Winner : %d", m_cHeldenianModeType, m_sLastHeldenianWinner);
		PutLogFileList(G_cTxt);
	}

	if (dwHeldenianGUID != 0) {
		_CreateHeldenianGUID(dwHeldenianGUID, 0);
		m_dwHeldenianGUID = dwHeldenianGUID;
	}
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower = 0;
	m_iHeldenianAresdenDead = 0;
	m_iHeldenianElvineDead = 0;

	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsInitComplete != true) break;
			m_pClientList[i]->m_cVar = 2;
			SendNotifyMsg(0, i, DEF_NOTIFY_HELDENIANTELEPORT,  0 , 0, 0, 0);
			m_pClientList[i]->m_iWarContribution = 0;
			m_pClientList[i]->m_iConstructionPoint = (m_pClientList[i]->m_iCharisma * 300);
			if (m_pClientList[i]->m_iConstructionPoint > 12000) m_pClientList[i]->m_iConstructionPoint = 12000;
			SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 1, 0);
		}
	}

	for (x = 0; x < DEF_MAXMAPS; x++) {
		if (m_pMapList[x] == 0) break;
		if (m_pMapList[x]->m_bIsHeldenianMap ) {
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] == 0) break;
				if (m_pClientList[i]->m_bIsInitComplete != true) break;
				if (m_pClientList[i]->m_iAdminUserLevel >= 1) break;
				if (m_pClientList[i]->m_cMapIndex != x) break;
				SendNotifyMsg(0, i, DEF_NOTIFY_0BE8, 0 , 0, 0, 0);
				RequestTeleportHandler(i, "1   ", 0, -1, -1);
			}
			for (i = 0; i < DEF_MAXNPCS; i++) {
				if (m_pNpcList[i] == 0) break;
				if (m_pNpcList[i]->m_bIsKilled) break;
				if (m_pNpcList[i]->m_cMapIndex != x) break;
				m_pNpcList[i]->m_bIsSummoned = true;
				RemoveHeldenianNpc(i);
			}
		
			if (m_cHeldenianModeType == 1) {
				if (strcmp(m_pMapList[x]->m_cName, "BtField") == 0) {
					for (i = 0; i < MAX_HELDENIANTOWER; i++) {
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID < 1)  break;
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID > DEF_MAXNPCTYPES) break;
						if (iNamingValue != -1) {
							dX = m_pMapList[x]->m_stHeldenianTower[i].dX;
							dY = m_pMapList[x]->m_stHeldenianTower[i].dY;
 							cSide = m_pMapList[x]->m_stHeldenianTower[i].cSide;
							for (z = 0; z < DEF_MAXNPCTYPES; z++) {
								if (m_pNpcConfigList[z] == 0) break;
								if (m_pNpcConfigList[z]->m_sType == m_pMapList[x]->m_stHeldenianTower[i].sTypeID) {
									ZeroMemory(cTmp, sizeof(cTmp));
									strcpy(cTmp, m_pNpcConfigList[z]->m_cNpcName);
								}
							}
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, 0, 0, cSide, false, false, false, true, false);
							if (bRet == false) {
								m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != 0) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) {
									m_pNpcList[sOwnerH]->m_iBuildCount = 0;
								}
								if (cSide == 1)	m_iHeldenianAresdenLeftTower += 1;
								if (cSide == 2) m_iHeldenianElvineLeftTower += 1;
							}
						}
					}
					wsprintf(G_cTxt,"HeldenianAresdenLeftTower : %d , HeldenianElvineLeftTower : %d", m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower);
					PutLogFileList(G_cTxt);
					UpdateHeldenianStatus();
				}
			}
			else if (m_cHeldenianModeType == 2) {
				if (strcmp(m_pMapList[x]->m_cName, "HRampart") == 0) {
					for (i = 0; i < DEF_MAXHELDENIANDOOR; i++) {
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							dX = m_pMapList[x]->m_stHeldenianGateDoor[i].dX;
							dY = m_pMapList[x]->m_stHeldenianGateDoor[i].dY;
							cSide = m_sLastHeldenianWinner;
							for (z = 0; z < DEF_MAXNPCTYPES; z++) {
								if (m_pNpcConfigList[z] == 0) break;
								if (m_pNpcConfigList[z]->m_sType == 91) {
									ZeroMemory(cTmp, sizeof(cTmp));
									strcpy(cTmp, m_pNpcConfigList[z]->m_cNpcName);
								}
							}
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, 0, 0, cSide, false, false, false, true, false);
							if (bRet == false) {
								m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								//m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[bRet] != 0) && (bRet > 0) && (bRet < DEF_MAXNPCS)) {
									m_pNpcList[bRet]->m_iBuildCount = 0;
									m_pNpcList[bRet]->m_cDir = m_pMapList[x]->m_stHeldenianGateDoor[i].cDir;
								}
							}
						}
					}
				}
			}
		}
	}
	m_bHeldenianInitiated = true;
	m_bIsHeldenianMode = true;
	wsprintf(G_cTxt,"(!) HELDENIAN Start.");
	PutLogFileList(G_cTxt);
	m_dwHeldenianStartTime = time(0);
}

void CGame::ManualStartHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)
{
 char cHeldenianType, cBuff[256], * token, seps[] = "= \t\n";
 SYSTEMTIME SysTime;
 class CStrTok * pStrTok;
 int iV1;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3)
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);

	if (m_bIsHeldenianMode ) return;
	if (m_bIsApocalypseMode ) return;
	if (m_bIsCrusadeMode ) return;
	if ((dwMsgSize != 0) && (pData != 0)) {
		m_bHeldenianRunning = true;
		GetLocalTime(&SysTime);

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != 0) {
			iV1 = atoi(token);
			iV1 += (SysTime.wHour*24 + SysTime.wMinute*60);
			m_dwHeldenianStartHour = (iV1/24);
			m_dwHeldenianStartMinute = (iV1/60);
		}
		token = pStrTok->pGet();
		if (token != 0) {
			cHeldenianType = atoi(token);
			if ((cHeldenianType == 1) || (cHeldenianType == 2)) {
				m_cHeldenianModeType = cHeldenianType;
			}
		}
		delete pStrTok;
	}
	GlobalStartHeldenianMode();
	wsprintf(G_cTxt,"GM Order(%s): begin Heldenian", m_pClientList[iClientH]->m_cCharName);
	PutLogFileList(G_cTxt);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, G_cTxt);
}

void CGame::ManualEndHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)
{
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
	}

	if (m_bIsHeldenianMode ) {
		GlobalEndHeldenianMode();
		m_bHeldenianRunning = false;
		wsprintf(G_cTxt,"GM Order(%s): end Heldenian", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, G_cTxt);
	}
}

/*void CGame::GlobalStartApocalypseMode(int iClientH, char *pData, DWORD dwMsgSize)
{
 char * cp, cData[120], cBuff[256];
 DWORD * dwp, dwApocalypseGUID;
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, 0, 0, 0, 0);
	}
	if (m_bIsApocalypseMode ) return;
	if (m_bIsHeldenianMode ) return;
	if (m_bIsCrusadeMode ) return;
	if (dwMsgSize != 0) && (pData != 0) {
		m_bIsApocalypseGateOpen = true;
		GetLocalTime(&SysTime);
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != 0) {
			var_124 = atoi(token);
			m_dwApocalypseStartHour = SysTime.wHour;
			m_dwApocalypseStartMinute = SysTime.wMinute;
		}
		else {
			return;
		}
	}
	sub_4AD0E0();
	wsprintf(cTemp, "(%s) GM Order(%s): beginapocalypse", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
	delete pStrTok;
}*/

void CGame::AutomatedHeldenianTimer()
{
 DWORD dwTime;
 int x, i;

	dwTime = time(0);
	if ((dwTime == m_dwHeldenianStartTime - 300) && (m_bHeldenianInitiated != true) && (m_bIsHeldenianMode != true)) {
		wsprintf(G_cTxt,"Heldenian Fight Start");
		PutLogFileList(G_cTxt);
		m_bIsHeldenianMode = false;
		for (x = 0; x < DEF_MAXMAPS; x++) {
			if (m_pMapList[x] == 0) return;
			if (m_pMapList[x]->m_bIsHeldenianMap ) return;
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] == 0) return;
				if (m_pClientList[i]->m_bIsInitComplete != true) return;
				if (m_pClientList[i]->m_cMapIndex == x) {
					SendNotifyMsg(0, i, DEF_NOTIFY_HELDENIANSTART, 0 , 0, 0, 0);					
				}
			}
		}
	}
	if ((dwTime > (180 - var_A38)) && (m_bHeldenianInitiated ) && (m_bIsHeldenianMode)) {
		wsprintf(G_cTxt,"Heldenian Fight End");
		PutLogFileList(G_cTxt);
		m_bHeldenianInitiated = false;
		for (x = 0; x < DEF_MAXMAPS; x++) {
			if (m_pMapList[x] == 0) return;
			if (m_pMapList[x]->m_bIsHeldenianMap ) return;
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] == 0) return;
				if (m_pClientList[i]->m_bIsInitComplete != true) return;
				if (m_pClientList[i]->m_cMapIndex == x) {
					SendNotifyMsg(0, i, DEF_NOTIFY_0BE8, 0 , 0, 0, 0);
					RequestTeleportHandler(i, "1   ", 0, -1, -1);
				}
			}
		}
	}
}

void CGame::AdminOrder_GetFightzoneTicket(int iClientH)
{
 int iReserveTime, iFightzoneTN, iFightzoneN;
 char cTemp[21];
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fightzone", 9) == 0) {
		
		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +3);  
		
		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = atoi(cTemp);
		
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		
		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
	else {
		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +2);  
		
		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = 1;
		
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);

		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
}

void CGame::SetHeldenianMode()
{
 SYSTEMTIME SysTime;

	GetLocalTime(&SysTime);
	m_dwHeldenianStartHour = SysTime.wHour;
	m_dwHeldenianStartMinute = SysTime.wMinute;
		
	if (m_cHeldenianModeType != 2) {
		m_cHeldenianVictoryType = m_sLastHeldenianWinner;
	}
}

void CGame::CheckCrusadeResultCalculation(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_cVar == 1) return;

	if ((m_bIsCrusadeMode == false) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
		if (m_pClientList[iClientH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION) m_pClientList[iClientH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;	
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_iCrusadeWinnerSide == 0) {
				m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution/6);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, m_pClientList[iClientH]->m_iWarContribution, 0);		
				_bCrusadeLog(DEF_CRUSADELOG_GETEXP, iClientH, (m_pClientList[iClientH]->m_iWarContribution/6), 0) ;
			}
			else {
				if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) {
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*100;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*40 ;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, m_pClientList[iClientH]->m_iWarContribution, 0);
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,m_pClientList[iClientH]->m_iWarContribution,0) ;
				}
				else if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_cSide) {
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*100;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*40 ;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution/10 ;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, -1*m_pClientList[iClientH]->m_iWarContribution, 0);						
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,(m_pClientList[iClientH]->m_iWarContribution/10),0) ;
				}
			}
		}
		else {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);		
		}
		m_pClientList[iClientH]->m_iCrusadeDuty     = 0;
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwCrusadeGUID    = 0;
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = timeGetTime();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}

void CGame::CheckHeldenianResultCalculation(int iClientH)
{
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_cVar != 2) return;
	if ((m_cHeldenianType == 0) || (m_pClientList[iClientH]->m_dwHeldenianGUID == 0)) return;
	if (m_pClientList[iClientH]->m_dwHeldenianGUID == m_dwHeldenianGUID) {
		if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) {
			if (m_pClientList[iClientH]->m_iLevel <= 80) {
				m_pClientList[iClientH]->m_iWarContribution += (m_pClientList[iClientH]->m_iLevel) * 200;
			}
			else if (m_pClientList[iClientH]->m_iLevel > 80 && m_pClientList[iClientH]->m_iLevel <= 100) {
				m_pClientList[iClientH]->m_iWarContribution += (m_pClientList[iClientH]->m_iLevel) * 100;
			}
			else if (m_pClientList[iClientH]->m_iLevel > 100) {
				m_pClientList[iClientH]->m_iWarContribution += (m_pClientList[iClientH]->m_iLevel) * 30;
			}
			dV2 = (double)m_pClientList[iClientH]->m_iExp;
			dV3 = (double)m_pClientList[iClientH]->m_iWarContribution * 1.2f;
			dV1 = dV2 + dV3;
			GetExp(iClientH, (DWORD)dV1);
		}
		else {
			GetExp(iClientH, (m_pClientList[iClientH]->m_iWarContribution / 5));
		}
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwHeldenianGUID = 0;
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = timeGetTime();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}

void CGame::NotifyStartHeldenianMode()
{
 int i, x;
	
	if (m_bIsHeldenianMode ) return;
	if (m_bHeldenianInitiated ) return;
	if (var_88C != true) {
		PutLogList("Heldenian Fight Start");
		m_bHeldenianInitiated = false;
		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] == 0) return;
			if (m_pMapList[i]->m_bIsHeldenianMap != true) return;
			for (x = 0; x < DEF_MAXCLIENTS; x++) {
				if (m_pClientList[x] == 0) return;
				if (m_pClientList[x]->m_bIsInitComplete != true) return;
				if (m_pClientList[x]->m_cMapIndex == i) {
					SendNotifyMsg(0, x, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0);
				}
			}
		}
	}
}

bool CGame::UpdateHeldenianStatus()
{
 int i;
 bool bFlag;
 int iShortCutIndex, iClientH;

	if (m_bIsHeldenianMode != true) return false;
	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != 0) {
		if (m_pMapList[i]->m_bIsHeldenianMap ) {
			bFlag = true;
			iShortCutIndex = 0;
		}
		if (bFlag ) {
			iClientH = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (iClientH == 0) {
				bFlag = 0;
			}
			else {
				if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_bIsInitComplete ) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "BtField") == 0)) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANCOUNT, m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower, m_iHeldenianAresdenDead, 0, m_iHeldenianElvineDead, 0);
				}
			}
		}
	}
	return true;
}



void CGame::AddGizon(int iClientH) {
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_iPlayerMaxLevel + 1];
	m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[m_iPlayerMaxLevel];
}

void CGame::ForceRecallProcess() {
	int i;
	int iMapSide = 0;

	DWORD * dwp, dwTime;

	dwTime = timeGetTime();

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsInitComplete ) {
				//force recall in enemy buidlings at crusade
				iMapSide = iGetMapLocationSide(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName);
				if ((memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) && (iMapSide==2) && (m_pClientList[i]->m_iAdminUserLevel == 0) && (m_bIsCrusadeMode )) {
					RequestTeleportHandler(i, "2   ", "aresden", -1, -1);
				}
				if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) && (iMapSide==1) && (m_pClientList[i]->m_iAdminUserLevel == 0) && (m_bIsCrusadeMode )) {
					RequestTeleportHandler(i, "2   ", "elvine", -1, -1);
				}
				
				//remove mim in building
					if ((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "wrhus", 5) == 0) 
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gshop_1") == 0) 
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "bsmith_1") == 0) 
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cath_1") == 0) 
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "CmdHall_1") == 0) 
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cityhall_1") == 0) 
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gshop_2") == 0) 
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "bsmith_2") == 0) 
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cath_2") == 0) 
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "CmdHall_2") == 0) 
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cityhall_2") == 0) 
					|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "wzdtwr", 6) == 0) 
					|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gldhall", 7) == 0) ) 
					{
						//SetIllusionFlag(i, DEF_OWNERTYPE_PLAYER, false);
						if (m_pClientList[i]->m_iStatus & 0x00200000) {
							SetIllusionMovementFlag(i, DEF_OWNERTYPE_PLAYER, false);
							bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime+2, i, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 4, 0, 0);
						}
					}
			}
			//check gizon errors
			if (m_pClientList[i]->m_iLevel < 180)  {
				if (m_pClientList[i]->m_iGizonItemUpgradeLeft > 0) {
					m_pClientList[i]->m_iGizonItemUpgradeLeft = 0;
				}
			}
		}
	}
}

//in stat change, check skillpoints
void CGame::SkillCheck(int sTargetH) {
	//magic
	while ((m_pClientList[sTargetH]->m_iMag*2) < m_pClientList[sTargetH]->m_cSkillMastery[4]) {
		m_pClientList[sTargetH]->m_cSkillMastery[4]--;
	}
	//hand attack
	while ((m_pClientList[sTargetH]->m_iStr*2) < m_pClientList[sTargetH]->m_cSkillMastery[5]) {
		m_pClientList[sTargetH]->m_cSkillMastery[5]--;
	}
	//hammer
	while ((m_pClientList[sTargetH]->m_iDex*2) < m_pClientList[sTargetH]->m_cSkillMastery[14]) {
		m_pClientList[sTargetH]->m_cSkillMastery[14]--;
	}
	//shield
	while ((m_pClientList[sTargetH]->m_iDex*2) < m_pClientList[sTargetH]->m_cSkillMastery[11]) {
		m_pClientList[sTargetH]->m_cSkillMastery[11]--;
	}
	//axe
	while ((m_pClientList[sTargetH]->m_iDex*2) < m_pClientList[sTargetH]->m_cSkillMastery[10]) {
		m_pClientList[sTargetH]->m_cSkillMastery[10]--;
	}
	//fencing
	while ((m_pClientList[sTargetH]->m_iDex*2) < m_pClientList[sTargetH]->m_cSkillMastery[9]) {
		m_pClientList[sTargetH]->m_cSkillMastery[9]--;
	}
	//LS
	while ((m_pClientList[sTargetH]->m_iDex*2) < m_pClientList[sTargetH]->m_cSkillMastery[8]) {
		m_pClientList[sTargetH]->m_cSkillMastery[8]--;
	}
	//SS
	while ((m_pClientList[sTargetH]->m_iDex*2) < m_pClientList[sTargetH]->m_cSkillMastery[7]) {
		m_pClientList[sTargetH]->m_cSkillMastery[7]--;
	}
	//archery
	while ((m_pClientList[sTargetH]->m_iDex*2) < m_pClientList[sTargetH]->m_cSkillMastery[6]) {
		m_pClientList[sTargetH]->m_cSkillMastery[6]--;
	}
	//staff
	while ((m_pClientList[sTargetH]->m_iMag*2) < m_pClientList[sTargetH]->m_cSkillMastery[21]) {
		m_pClientList[sTargetH]->m_cSkillMastery[21]--;
	}
	//alc
	while ((m_pClientList[sTargetH]->m_iInt*2) < m_pClientList[sTargetH]->m_cSkillMastery[12]) {
		m_pClientList[sTargetH]->m_cSkillMastery[12]--;
	}
	//manu
	while ((m_pClientList[sTargetH]->m_iStr*2) < m_pClientList[sTargetH]->m_cSkillMastery[13]) {
		m_pClientList[sTargetH]->m_cSkillMastery[13]--;
	}
	//pr
	while ((m_pClientList[sTargetH]->m_iVit*2) < m_pClientList[sTargetH]->m_cSkillMastery[23]) {
		m_pClientList[sTargetH]->m_cSkillMastery[23]--;
	}
	//pc
	while ((m_pClientList[sTargetH]->m_iInt*2) < m_pClientList[sTargetH]->m_cSkillMastery[19]) {
		m_pClientList[sTargetH]->m_cSkillMastery[19]--;
	}
	//farming
	while ((m_pClientList[sTargetH]->m_iInt*2) < m_pClientList[sTargetH]->m_cSkillMastery[2]) {
		m_pClientList[sTargetH]->m_cSkillMastery[2]--;
	}
	//fishing
	while ((m_pClientList[sTargetH]->m_iDex*2) < m_pClientList[sTargetH]->m_cSkillMastery[1]) {
		m_pClientList[sTargetH]->m_cSkillMastery[1]--;
	}
	//mining
	while ((m_pClientList[sTargetH]->m_iStr*2) < m_pClientList[sTargetH]->m_cSkillMastery[0]) {
		m_pClientList[sTargetH]->m_cSkillMastery[0]--;
	}
}

bool CGame::IsEnemyZone(int i) {
	if (memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) {
		if ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresdend1") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "areuni") == 0) ||  (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone2") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone4") == 0)) {
			return true;
		}
	}
	else if (memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) {
		if ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvined1") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvuni") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone1") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone3") == 0)) {
			return true;	
		}
	}
	return false;
}

void CGame::LoteryHandler(int iClientH)
{
	class  CItem * pItem;
	int     iItemID;
	if (m_pClientList[iClientH] == 0) return;
	switch (iDice(1,22)) {
		case 1:iItemID=656;break; // XelimaStone
		case 2:iItemID=657;break; // MerienStone
		case 3:iItemID=650;break; // ZemstoneOfSacrifice
		case 4:iItemID=652;break; // RedBall
		case 5:iItemID=654;break; // BlueBall
		case 6:iItemID=881;break; // ArmorDye(Indigo)
		case 7:iItemID=882;break; // ArmorDye(CrimsonRed)
		case 8:iItemID=883;break; // ArmorDye(Gold)
		case 9:iItemID=884;break; // ArmorDye(Aqua)
		case 10:iItemID=885;break; // ArmorDye(Pink)
		case 11:iItemID=886;break; // ArmorDye(Violet)
		case 12:iItemID=887;break; // ArmorDye(Blue) 
		case 13:iItemID=888;break; // ArmorDye(Khaki) 
		case 14:iItemID=889;break; // ArmorDye(Yellow) 
		case 15:iItemID=890;break; // ArmorDye(Red) 
		case 16:iItemID=971;break; // ArmorDye(Green)
		case 17:iItemID=972;break; // ArmorDye(Black) 
		case 18:iItemID=973;break; // ArmorDye(Knight) 
		case 19:iItemID=970;break; // CritCandy
		case 20:iItemID=651;break; // GreenBall
		case 21:iItemID=653;break; // YellowBall
		case 22:iItemID=655;break; // PearlBall
	}

	//chance
	if (iDice(1,120) <= 3) iItemID=650;//ZemstoneOfSacrifice
	//chance

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == false) {
	delete pItem;
	}
	else {
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
		m_pClientList[iClientH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
		pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute);
	}


}

void CGame::SetSkillAll(int iClientH,char * pData, DWORD dwMsgSize)
//SetSkillAll Acidx Command,  Added July 04, 2005 INDEPENDENCE BABY Fuck YEA
{
if (m_pClientList[iClientH] == 0) return;
//Magic
if  (m_pClientList[iClientH]->m_cSkillMastery[4]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[4] = m_pClientList[iClientH]->m_iMag *2;
if (m_pClientList[iClientH]->m_cSkillMastery[4] > 100)
{
m_pClientList[iClientH]->m_cSkillMastery[4] = 100;
}
if (m_pClientList[iClientH]->m_iMag > 50) 
{
m_pClientList[iClientH]->m_cSkillMastery[4] = 100;
}
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], 0, 0);
	
	}
//LongSword
if  (m_pClientList[iClientH]->m_cSkillMastery[8]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[8] = m_pClientList[iClientH]->m_iDex *2;

if (m_pClientList[iClientH]->m_cSkillMastery[8] > 100)
{
m_pClientList[iClientH]->m_cSkillMastery[8] = 100;
}
if (m_pClientList[iClientH]->m_iDex > 50) 
{
m_pClientList[iClientH]->m_cSkillMastery[8] = 100;
}
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 8, m_pClientList[iClientH]->m_cSkillMastery[8], 0, 0);
	
	}
//Hammer
if  (m_pClientList[iClientH]->m_cSkillMastery[14]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[14] = m_pClientList[iClientH]->m_iDex *2;
if (m_pClientList[iClientH]->m_cSkillMastery[14] > 100)
{
m_pClientList[iClientH]->m_cSkillMastery[14] = 100;
}
if (m_pClientList[iClientH]->m_iDex > 50) 
{
m_pClientList[iClientH]->m_cSkillMastery[14] = 100;
}
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 14, m_pClientList[iClientH]->m_cSkillMastery[14], 0, 0);
	
	}
//Axes
if  (m_pClientList[iClientH]->m_cSkillMastery[10]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[10] = m_pClientList[iClientH]->m_iDex *2;
if (m_pClientList[iClientH]->m_cSkillMastery[10] > 100)
{
m_pClientList[iClientH]->m_cSkillMastery[10] = 100;
}
if (m_pClientList[iClientH]->m_iDex > 50) 
{
m_pClientList[iClientH]->m_cSkillMastery[10] = 100;
}
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 10, m_pClientList[iClientH]->m_cSkillMastery[10], 0, 0);
	
	}
//hand attack
if  (m_pClientList[iClientH]->m_cSkillMastery[5]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[5] = m_pClientList[iClientH]->m_iStr *2;
if (m_pClientList[iClientH]->m_cSkillMastery[5] > 100)
{
m_pClientList[iClientH]->m_cSkillMastery[5] = 100;
}
if (m_pClientList[iClientH]->m_iStr > 50) 
{
m_pClientList[iClientH]->m_cSkillMastery[5] = 100;
}
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 5, m_pClientList[iClientH]->m_cSkillMastery[5], 0, 0);
	
	}
//ShortSword
if  (m_pClientList[iClientH]->m_cSkillMastery[7]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[7] = m_pClientList[iClientH]->m_iDex *2;
if (m_pClientList[iClientH]->m_cSkillMastery[7] > 100)
{
m_pClientList[iClientH]->m_cSkillMastery[7] = 100;
}
if (m_pClientList[iClientH]->m_iDex > 50) 
{
m_pClientList[iClientH]->m_cSkillMastery[7] = 100;
}
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 7, m_pClientList[iClientH]->m_cSkillMastery[7], 0, 0);
	
	}
//archery
if  (m_pClientList[iClientH]->m_cSkillMastery[6]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[6] = m_pClientList[iClientH]->m_iDex *2;
if (m_pClientList[iClientH]->m_cSkillMastery[6] > 100)
{
m_pClientList[iClientH]->m_cSkillMastery[6] = 100;
}
if (m_pClientList[iClientH]->m_iDex > 50) 
{
m_pClientList[iClientH]->m_cSkillMastery[6] = 100;
}
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 6, m_pClientList[iClientH]->m_cSkillMastery[6], 0, 0);
	
	}
//Fencing
if  (m_pClientList[iClientH]->m_cSkillMastery[9]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[9] = m_pClientList[iClientH]->m_iDex *2;
if (m_pClientList[iClientH]->m_cSkillMastery[9] > 100)
{
m_pClientList[iClientH]->m_cSkillMastery[9] = 100;
}
if (m_pClientList[iClientH]->m_iDex > 50) 
{
m_pClientList[iClientH]->m_cSkillMastery[9] = 100;
}
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 9, m_pClientList[iClientH]->m_cSkillMastery[9], 0, 0);
	
	}
//Staff Attack
if  (m_pClientList[iClientH]->m_cSkillMastery[21]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[21] = m_pClientList[iClientH]->m_iInt *2;
if (m_pClientList[iClientH]->m_cSkillMastery[21] > 100)
{
m_pClientList[iClientH]->m_cSkillMastery[21] = 100;
}
if (m_pClientList[iClientH]->m_iInt > 50) 
{
m_pClientList[iClientH]->m_cSkillMastery[21] = 100;
}
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 21, m_pClientList[iClientH]->m_cSkillMastery[21], 0, 0);
	
	}
//shield
if  (m_pClientList[iClientH]->m_cSkillMastery[11]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[11] = m_pClientList[iClientH]->m_iDex *2;
if (m_pClientList[iClientH]->m_cSkillMastery[11] > 100)
{
m_pClientList[iClientH]->m_cSkillMastery[11] = 100;
}
if (m_pClientList[iClientH]->m_iDex > 50) 
{
m_pClientList[iClientH]->m_cSkillMastery[11] = 100;
}
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 11, m_pClientList[iClientH]->m_cSkillMastery[11], 0, 0);
	
	}
//mining
if  (m_pClientList[iClientH]->m_cSkillMastery[0]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[0] = 100;
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 0, m_pClientList[iClientH]->m_cSkillMastery[0], 0, 0);
	
	}
//fishing
if  (m_pClientList[iClientH]->m_cSkillMastery[1]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[1] = 100;
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 1, m_pClientList[iClientH]->m_cSkillMastery[1], 0, 0);
	
	}
//farming
if  (m_pClientList[iClientH]->m_cSkillMastery[2]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[2] = 100;
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 2, m_pClientList[iClientH]->m_cSkillMastery[2], 0, 0);
	
	}
//alchemy
if  (m_pClientList[iClientH]->m_cSkillMastery[12]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[12] = 100;
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 12, m_pClientList[iClientH]->m_cSkillMastery[12], 0, 0);
	
	}
//manufacturing
if  (m_pClientList[iClientH]->m_cSkillMastery[13]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[13] = 100;
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 13, m_pClientList[iClientH]->m_cSkillMastery[13], 0, 0);
	
	}
//poison resistance
if  (m_pClientList[iClientH]->m_cSkillMastery[23]< 20)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[23] = 20;
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 23, m_pClientList[iClientH]->m_cSkillMastery[23], 0, 0);
	
	}
//pretend corpse
if  (m_pClientList[iClientH]->m_cSkillMastery[19]< 100)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[19] = m_pClientList[iClientH]->m_iInt *2;
if (m_pClientList[iClientH]->m_cSkillMastery[19] > 100)
{
m_pClientList[iClientH]->m_cSkillMastery[19] = 100;
}
if (m_pClientList[iClientH]->m_iInt > 50) 
{
m_pClientList[iClientH]->m_cSkillMastery[19] = 100;
}
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 19, m_pClientList[iClientH]->m_cSkillMastery[19], 0, 0);
	
	}
//magic resistance
if  (m_pClientList[iClientH]->m_cSkillMastery[3]< 20)
{
		// now we add skills
m_pClientList[iClientH]->m_cSkillMastery[3] = 20;
//Send a notify to update the client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 3, m_pClientList[iClientH]->m_cSkillMastery[3], 0, 0);
	
	}
}

//Angel Code By SlammeR(I dont know if it works)
/*void CGame::GetAngelMantleHandler(int iClientH,int iItemID,char * pString) 
{ 
 int   i, iNum, iRet, iEraseReq; 
 char  * cp, cData[256], cItemName[21]; 
 class CItem * pItem; 
 DWORD * dwp; 
 short * sp; 
 WORD  * wp; 

	if (m_pClientList[iClientH] == 0) return; 
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 5) return; 
	if (m_pClientList[iClientH]->m_cSide == 0) return; 
	if (_iGetItemSpaceLeft(iClientH) == 0) {
		SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
		return;
	}

	//Prevents a crash if item dosent exist
	if (m_pItemConfigList[iItemID] == 0)  return;
 
	switch(iItemID) { 
	//Angels
	case 908: //AngelicPandent(STR)
	case 909: //AngelicPandent(DEX)
        case 910: //AngelicPandent(INT)
        case 911: //AngelicPandent(MAG)
		if(m_pClientList[iClientH]->m_iGizonItemUpgradeLeft<5) return; 
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 5; 
		break; 


  default: 
     return; 
     break; 
  } 

  ZeroMemory(cItemName, sizeof(cItemName)); 
  memcpy(cItemName,m_pItemConfigList[iItemID]->m_cName,20); 

  iNum = 1; 
  for (i = 1; i <= iNum; i++) 
  { 
     pItem = new class CItem; 
     if (_bInitItemAttr(pItem, cItemName) == false) 
     { 
        delete pItem; 
     } 
     else { 
                                 
        if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) { 
           if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0; 
            
           wsprintf(G_cTxt, "(*) Get Angel : Char(%s) Player-Majestic-Points(%d) Angel Obtained(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, cItemName); 
           PutLogFileList(G_cTxt); 

           pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER; 
           pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1; 
           pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2; 
           pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3; 

           dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
           *dwp = MSGID_NOTIFY; 
           wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
           *wp  = DEF_NOTIFY_ITEMOBTAINED; 
           cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 

           *cp = 1; 
           cp++; 
            
           memcpy(cp, pItem->m_cName, 20); 
           cp += 20; 
            
           dwp  = (DWORD *)cp; 
           *dwp = pItem->m_dwCount; 
           cp += 4; 
            
           *cp = pItem->m_cItemType; 
           cp++; 
            
           *cp = pItem->m_cEquipPos; 
           cp++; 
            
           *cp = (char)0;
           cp++; 
            
           sp  = (short *)cp; 
           *sp = pItem->m_sLevelLimit; 
           cp += 2; 
            
           *cp = pItem->m_cGenderLimit; 
           cp++; 
            
           wp = (WORD *)cp; 
           *wp = pItem->m_wCurLifeSpan; 
           cp += 2; 
            
           wp = (WORD *)cp; 
           *wp = pItem->m_wWeight; 
           cp += 2; 
            
           sp  = (short *)cp; 
           *sp = pItem->m_sSprite; 
           cp += 2; 
            
           sp  = (short *)cp; 
           *sp = pItem->m_sSpriteFrame; 
           cp += 2; 

           *cp = pItem->m_cItemColor; 
           cp++; 

           *cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
           cp++; 
            
           dwp = (DWORD *)cp; 
           *dwp = pItem->m_dwAttribute; 
           cp += 4;  
           //*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item??? ?? 
           //cp++; 
                                 
           if (iEraseReq == 1) delete pItem; 
            
           iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53); 
            
           iCalcTotalWeight(iClientH); 
            
           switch (iRet) { 
           case DEF_XSOCKEVENT_QUENEFULL: 
           case DEF_XSOCKEVENT_SOCKETERROR: 
           case DEF_XSOCKEVENT_CRITICALERROR: 
           case DEF_XSOCKEVENT_SOCKETCLOSED: 
              DeleteClient(iClientH, true, true); 
              return; 
           } 

           SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0); 
        } 
        else 
        { 
           delete pItem; 

           iCalcTotalWeight(iClientH); 

           dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
           *dwp = MSGID_NOTIFY; 
           wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
           *wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM; 
            
           iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6); 
           switch (iRet) { 
           case DEF_XSOCKEVENT_QUENEFULL: 
           case DEF_XSOCKEVENT_SOCKETERROR: 
           case DEF_XSOCKEVENT_CRITICALERROR: 
           case DEF_XSOCKEVENT_SOCKETCLOSED: 

              DeleteClient(iClientH, true, true); 
              return; 
           } 
        } 
     } 
   } 
}*/

/*int CGame::iAngelEquip(int iClientH)
{
 int iTemp;
 CItem * cAngelTemp;
	iTemp = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LFINGER];
	cAngelTemp = m_pClientList[iClientH]->m_pItemList[iTemp];
	if ((iTemp != -1) && (cAngelTemp != 0)) {
		if(cAngelTemp->m_sIDnum >= 908){ //AngelicPandent(STR)
                if(cAngelTemp->m_sIDnum >= 909){ //AngelicPandent(DEX)
                if(cAngelTemp->m_sIDnum >= 910){ //AngelicPandent(INT)
                if(cAngelTemp->m_sIDnum >= 911){ //AngelicPandent(MAG)
			                        
				return cAngelTemp->m_sIDnum;
			} else {
				return 0;
				}
				}
				}
		}
	}
}*/

/*void CGame::CheckAngelUnequip(int iClientH,int iAngelID)
{
 int iTemp;
 CItem * cAngelTemp;

   	iTemp = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LFINGER];
	cAngelTemp = m_pClientList[iClientH]->m_pItemList[iTemp];
	if ((iTemp != -1) && (cAngelTemp->m_sIDnum != iAngelID)) {
		cAngelTemp->m_sIDnum = iAngelID;
	}

}*/

/*********************************************************************************************************************
**  bool CGame::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, iTemp)		Snoopy			**
** description	  :: Sets the staus to send or not Angels to every client							**
*********************************************************************************************************************/
void CGame::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, int iTemp)
{
	if (cOwnerType != DEF_OWNERTYPE_PLAYER) return;
	if (m_pClientList[sOwnerH] == 0) return;
	switch (iStatus) {
	case 1: // STR Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00001000;
		break;
	case 2: // DEX Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00002000;
		break;
	case 3: // INT Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00004000;
		break;
	case 4: // MAG Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00008000;
		break;
	default:
	case 0: // Remove all Angels
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFF00FF;
		break;
	}
	if (iTemp > 4)
	{
		int iAngelicStars = (iTemp / 3) * (iTemp / 5);
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | (iAngelicStars << 8);
	}
	SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}

/*********************************************************************************************************************
**  bool CGame::GetAngelHandler(int iClientH, char * pData, DWORD dwMsgSize)										**
** description	  :: Reversed and coded by Snoopy																	**
*********************************************************************************************************************/
void CGame::GetAngelHandler(int iClientH, char* pData, DWORD dwMsgSize)
{
	char* cp, cData[256], cTmpName[21];
	int   iAngel;
	class CItem* pItem;
	int   iRet, iEraseReq;
	char  cItemName[21];
	short* sp;
	WORD* wp;
	int* ip;
	DWORD* dwp;
	if (m_pClientList[iClientH] == 0)					 return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (_iGetItemSpaceLeft(iClientH) == 0)
	{
		SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
		return;
	}
	cp = (char*)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	ip = (int*)cp;
	iAngel = (int)*ip; // 0x00 l a i
	cp += 2;
	wsprintf(G_cTxt, "PC(%s) obtained an Angel (%d).   %s(%d %d)"
		, m_pClientList[iClientH]->m_cCharName
		, iAngel
		, m_pClientList[iClientH]->m_cMapName
		, m_pClientList[iClientH]->m_sX
		, m_pClientList[iClientH]->m_sY);
	PutLogList(G_cTxt);
	switch (iAngel) {
	case 1: // STR
		//iItemNbe = 1108;
		wsprintf(cItemName, "AngelicPandent(STR)");
		break;
	case 2: // DEX
		//iItemNbe = 1109;
		wsprintf(cItemName, "AngelicPandent(DEX)");
		break;
	case 3: // INT
		//iItemNbe = 1110;
		wsprintf(cItemName, "AngelicPandent(INT)");
		break;
	case 4: // MAG
		//iItemNbe = 1111;
		wsprintf(cItemName, "AngelicPandent(MAG)");
		break;
	default:
		PutLogList("Gail asked to create a wrong item!");
		break;
	}
	// Them create the summonScroll
	pItem = 0;
	pItem = new class CItem;
	if (pItem == 0) return;
	if ((_bInitItemAttr(pItem, cItemName) ))
	{
		pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) )
		{
			ZeroMemory(cData, sizeof(cData));
			dwp = (DWORD*)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp = (WORD*)(cData + DEF_INDEX2_MSGTYPE);
			*wp = DEF_NOTIFY_ITEMOBTAINED;
			cp = (char*)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp = 1;
			cp++;
			memcpy(cp, pItem->m_cName, 20);
			cp += 20;
			dwp = (DWORD*)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;
			*cp = pItem->m_cItemType;
			cp++;
			*cp = pItem->m_cEquipPos;
			cp++;
			*cp = (char)0;
			cp++;
			sp = (short*)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;
			*cp = pItem->m_cGenderLimit;
			cp++;
			wp = (WORD*)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;
			wp = (WORD*)cp;
			*wp = pItem->m_wWeight;
			cp += 2;
			sp = (short*)cp;
			*sp = pItem->m_sSprite;
			cp += 2;
			sp = (short*)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;
			*cp = pItem->m_cItemColor;
			cp++;
			*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
			cp++;
			dwp = (DWORD*)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			if (iEraseReq == 1) delete pItem;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				break;
			}
		}
		else
		{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
				m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4			
			dwp = (DWORD*)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp = (WORD*)(cData + DEF_INDEX2_MSGTYPE);
			*wp = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				break;
			}
		}
	}
	else
	{
		delete pItem;
		pItem = 0;
	}
}

void CGame::RequestEnchantUpgradeHandler(int client, DWORD type, DWORD lvl, int iType)
{
	auto& player = m_pClientList[client];
	if (player == 0 || type == 0) return;

	if (lvl < 2 || lvl >= 17) return; // nivel mayor a 1 y menor a 17

	int req = GetRequiredLevelForUpgrade(lvl);

	switch (iType) {
		// Upgrade one
	case UPGRADEONE_SHARD:
		// descuenta los shards necesarios
		if (player->m_pShards[type][lvl] != 0 && player->m_pShards[type][lvl]->iCount >= req)
		{
			player->m_pShards[type][lvl]->iCount -= req;
			SendNotifyMsg(0, client, msg_shard, type, lvl + 1, player->m_pShards[type][lvl]->iCount, player->m_pShards[type][lvl]->cName, 0, 0, 0, 0, 0, 0, player->m_pShards[type][lvl]->cDesc);

			// agrego uno al nivel siguiente
			if (player->m_pShards[type][lvl + 1] == 0)
			{
				player->m_pShards[type][lvl + 1] = new class CEnchanting;

				strcpy(player->m_pShards[type][lvl + 1]->cName, GetShardName(type));
				strcpy(player->m_pShards[type][lvl + 1]->cDesc, GetShardDesc(type));
				player->m_pShards[type][lvl + 1]->dwType = type;
				player->m_pShards[type][lvl + 1]->dwValue = lvl + 2;
			}

			player->m_pShards[type][lvl + 1]->iCount++;

			SendNotifyMsg(0, client, msg_shard, type, lvl + 2, player->m_pShards[type][lvl + 1]->iCount, player->m_pShards[type][lvl + 1]->cName, 0, 0, 0, 0, 0, 0, player->m_pShards[type][lvl + 1]->cDesc);
		}
		break;
	case UPGRADEONE_FRAGMENT:
		// descuenta los fragments necesarios
		if (player->m_pFragments[type][lvl] != 0 && player->m_pFragments[type][lvl]->iCount >= req)
		{
			player->m_pFragments[type][lvl]->iCount -= req;
			SendNotifyMsg(0, client, msg_fragment, type, lvl + 1, player->m_pFragments[type][lvl]->iCount, player->m_pFragments[type][lvl]->cName, 0, 0, 0, 0, 0, 0, player->m_pFragments[type][lvl]->cDesc);

			// agrego uno al nivel siguiente
			if (player->m_pFragments[type][lvl + 1] == 0)
			{
				player->m_pFragments[type][lvl + 1] = new class CEnchanting;

				strcpy(player->m_pFragments[type][lvl + 1]->cName, GetFragmentName(type));
				strcpy(player->m_pFragments[type][lvl + 1]->cDesc, GetFragmentDesc(type));
				player->m_pFragments[type][lvl + 1]->dwType = type;
				player->m_pFragments[type][lvl + 1]->dwValue = lvl + 2;
			}

			player->m_pFragments[type][lvl + 1]->iCount++;

			SendNotifyMsg(0, client, msg_fragment, type, lvl + 2, player->m_pFragments[type][lvl + 1]->iCount, player->m_pFragments[type][lvl + 1]->cName, 0, 0, 0, 0, 0, 0, player->m_pFragments[type][lvl + 1]->cDesc);
		}
		break;

		// Upgrade all
	case UPGRADEALL_SHARD:
		// descuenta los shards necesarios
		if (player->m_pShards[type][lvl] != 0)
		{
			while (player->m_pShards[type][lvl]->iCount >= req)
			{
				player->m_pShards[type][lvl]->iCount -= req;
				SendNotifyMsg(0, client, msg_shard, type, lvl + 1, player->m_pShards[type][lvl]->iCount, player->m_pShards[type][lvl]->cName, 0, 0, 0, 0, 0, 0, player->m_pShards[type][lvl]->cDesc);

				// agrego uno al nivel siguiente
				if (player->m_pShards[type][lvl + 1] == 0)
				{
					player->m_pShards[type][lvl + 1] = new class CEnchanting;

					strcpy(player->m_pShards[type][lvl + 1]->cName, GetShardName(type));
					strcpy(player->m_pShards[type][lvl + 1]->cDesc, GetShardDesc(type));
					player->m_pShards[type][lvl + 1]->dwType = type;
					player->m_pShards[type][lvl + 1]->dwValue = lvl + 2;
				}

				player->m_pShards[type][lvl + 1]->iCount++;

				SendNotifyMsg(0, client, msg_shard, type, lvl + 2, player->m_pShards[type][lvl + 1]->iCount, player->m_pShards[type][lvl + 1]->cName, 0, 0, 0, 0, 0, 0, player->m_pShards[type][lvl + 1]->cDesc);
			}
		}
		break;
	case UPGRADEALL_FRAGMENT:
		// descuenta los fragments necesarios
		if (player->m_pFragments[type][lvl] != 0)
		{
			while (player->m_pFragments[type][lvl]->iCount >= req)
			{
				player->m_pFragments[type][lvl]->iCount -= req;
				SendNotifyMsg(0, client, msg_fragment, type, lvl + 1, player->m_pFragments[type][lvl]->iCount, player->m_pFragments[type][lvl]->cName, 0, 0, 0, 0, 0, 0, player->m_pFragments[type][lvl]->cDesc);

				// agrego uno al nivel siguiente
				if (player->m_pFragments[type][lvl + 1] == 0)
				{
					player->m_pFragments[type][lvl + 1] = new class CEnchanting;

					strcpy(player->m_pFragments[type][lvl + 1]->cName, GetFragmentName(type));
					strcpy(player->m_pFragments[type][lvl + 1]->cDesc, GetFragmentDesc(type));
					player->m_pFragments[type][lvl + 1]->dwType = type;
					player->m_pFragments[type][lvl + 1]->dwValue = lvl + 2;
				}

				player->m_pFragments[type][lvl + 1]->iCount++;

				SendNotifyMsg(0, client, msg_fragment, type, lvl + 2, player->m_pFragments[type][lvl + 1]->iCount, player->m_pFragments[type][lvl + 1]->cName, 0, 0, 0, 0, 0, 0, player->m_pFragments[type][lvl + 1]->cDesc);
			}
		}
		break;
	}
}
int CGame::GetRequiredLevelForUpgrade(DWORD value)
{
	if (value >= 1 && value <= 5)
	{
		return 4;
	}
	else if (value > 5 && value <= 10)
	{
		return 3;
	}

	return 2;

}
void CGame::RequestItemEnchantHandler(int iClientH, int sDestItemID, int iType)
{
	auto player = m_pClientList[iClientH];

	if (sDestItemID < 0 || sDestItemID > DEF_MAXITEMS) return;
	if (player == 0 || player->m_pItemList[sDestItemID] == 0) return;

	auto& dst_attr = player->m_pItemList[sDestItemID]->m_dwAttribute;

	auto dst_dwType1 = (dst_attr & 0x00F00000) >> 20;
	auto dst_dwValue1 = (dst_attr & 0x000F0000) >> 16;
	auto dst_dwType2 = (dst_attr & 0x0000F000) >> 12;
	auto dst_dwValue2 = (dst_attr & 0x00000F00) >> 8;

	for (int i = 0; i < 13; i++)
	{
		for (int x = 0; x < 17; x++)
		{
			if (iType == 0)
			{
				if (player->m_pShards[i][x] == 0 || player->m_pShards[i][x]->iCount == 0) continue;
				if (dst_dwType1 == 0 || dst_dwType1 != player->m_pShards[i][x]->dwType) continue; // no es del mismo tipo
				if (dst_dwValue1 != player->m_pShards[i][x]->dwValue) continue; // no es del mismo level

				auto dst_value = dst_dwValue1 + 1;

				dst_attr = 0;
				dst_dwType1 = dst_dwType1 << 20;
				dst_dwValue1 = dst_value << 16;
				dst_attr = dst_attr | dst_dwType1 | dst_dwValue1;

				if (dst_dwType2 != 0) // mantengo los mismos stats
				{
					dst_dwType2 = dst_dwType2 << 12;
					dst_dwValue2 = dst_dwValue2 << 8;
					dst_attr = dst_attr | dst_dwType2 | dst_dwValue2;
				}

				player->m_pShards[i][x]->iCount--;
				SendNotifyMsg(0, iClientH, msg_shard, player->m_pShards[i][x]->dwType, player->m_pShards[i][x]->dwValue, player->m_pShards[i][x]->iCount, player->m_pShards[i][x]->cName, 0, 0, 0, 0, 0, 0, player->m_pShards[i][x]->cDesc);
			}
			else
			{
				if (player->m_pFragments[i][x] == 0 || player->m_pFragments[i][x]->iCount == 0) continue;
				if (dst_dwType2 == 0 || dst_dwType2 != player->m_pFragments[i][x]->dwType) continue; // no es del mismo tipo
				if (dst_dwValue2 != player->m_pFragments[i][x]->dwValue) continue; // no es del mismo level

				auto dst_value = dst_dwValue2 + 1;

				dst_attr = 0;
				dst_dwType1 = dst_dwType1 << 20;
				dst_dwValue1 = dst_dwValue1 << 16;
				dst_dwType2 = dst_dwType2 << 12;
				dst_dwValue2 = dst_value << 8;
				dst_attr = dst_attr | dst_dwType1 | dst_dwValue1;
				dst_attr = dst_attr | dst_dwType2 | dst_dwValue2;

				player->m_pFragments[i][x]->iCount--;
				SendNotifyMsg(0, iClientH, msg_fragment, player->m_pFragments[i][x]->dwType, player->m_pFragments[i][x]->dwValue, player->m_pFragments[i][x]->iCount, player->m_pFragments[i][x]->cName, 0, 0, 0, 0, 0, 0, player->m_pFragments[i][x]->cDesc);
			}

			CalculateSSN_SkillIndex(iClientH, 20, 1);
			goto BREAK_LOOP;
		}
	}
	return;
BREAK_LOOP:
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, sDestItemID, player->m_pItemList[sDestItemID]->m_dwAttribute, 0, 0);
}

void CGame::RequestItemDisenchantHandler(int iClientH, int iItemIndex)
{
	auto player = m_pClientList[iClientH];

	if (player == 0) return;
	if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
	if (player->m_pItemList[iItemIndex] == 0) return;

	if ((player->m_pItemList[iItemIndex]->m_sTouchEffectValue1 == player->m_sCharIDnum1)
		&& (player->m_pItemList[iItemIndex]->m_sTouchEffectValue2 == player->m_sCharIDnum2)
		&& (player->m_pItemList[iItemIndex]->m_sTouchEffectValue3 == player->m_sCharIDnum3))
	{
		return; // si es un item unico no se puede
	}

	auto attr = player->m_pItemList[iItemIndex]->m_dwAttribute;
	auto dwType1 = (attr & 0x00F00000) >> 20;
	auto dwValue1 = (attr & 0x000F0000) >> 16;
	auto dwType2 = (attr & 0x0000F000) >> 12;
	auto dwValue2 = (attr & 0x00000F00) >> 8;

	if (dwType1 != 0)
	{
		DWORD type = dwType1;
		DWORD value = dwValue1 - 1;
		if (player->m_pShards[type][value] == 0)
		{
			player->m_pShards[type][value] = new class CEnchanting;

			strcpy(player->m_pShards[type][value]->cName, GetShardName(dwType1));
			strcpy(player->m_pShards[type][value]->cDesc, GetShardDesc(dwType1));
			player->m_pShards[type][value]->dwType = dwType1;
			player->m_pShards[type][value]->dwValue = dwValue1;
		}

		player->m_pShards[type][value]->iCount++;

		SendNotifyMsg(0, iClientH, msg_shard, dwType1, dwValue1, player->m_pShards[type][value]->iCount, player->m_pShards[type][value]->cName, 0, 0, 0, 0, 0, 0, player->m_pShards[type][value]->cDesc);
	}

	if (dwType2 != 0)
	{
		DWORD type = dwType2;
		DWORD value = dwValue2 - 1;
		if (player->m_pFragments[type][value] == 0)
		{
			player->m_pFragments[type][value] = new class CEnchanting;

			strcpy(player->m_pFragments[type][value]->cName, GetFragmentName(dwType2));
			strcpy(player->m_pFragments[type][value]->cDesc, GetFragmentDesc(dwType2));
			player->m_pFragments[type][value]->dwType = dwType2;
			player->m_pFragments[type][value]->dwValue = dwValue2;
		}

		player->m_pFragments[type][value]->iCount++;

		SendNotifyMsg(0, iClientH, msg_fragment, dwType2, dwValue2, player->m_pFragments[type][value]->iCount, player->m_pFragments[type][value]->cName, 0, 0, 0, 0, 0, 0, player->m_pFragments[type][value]->cDesc);
	}

	ItemDepleteHandler(iClientH, iItemIndex, true); // destruye el item
}


char* CGame::GetShardDesc(DWORD dwType)
{
	switch (dwType) {
	case SHARD_CRITICAL:
	case SHARD_CRITICAL2:
		return "crit";
	case SHARD_POISONING:
		return "pd";
	case SHARD_RIGHTEOUS:
		return "right";
	case SHARD_AGILE:
		return "agile";
	case SHARD_LIGHT:
		return "light";
	case SHARD_SHARP:
		return "sharp";
	case SHARD_STRONG:
		return "str";
	case SHARD_ANCIENT:
		return "anc";
	case SHARD_CASTPROB:
		return "cp";
	case SHARD_MANACONV:
		return "mana";
	}

	return "";
}

char* CGame::GetFragmentDesc(DWORD dwType)
{
	switch (dwType) {
	case FRAGMENT_PSNRES:
		return "pr";
	case FRAGMENT_HITPROB:
		return "hr";
	case FRAGMENT_DEF:
		return "dr";
	case FRAGMENT_HPREC:
		return "hp";
	case FRAGMENT_SPREC:
		return "sp";
	case FRAGMENT_MPREC:
		return "mp";
	case FRAGMENT_MR:
		return "mr";
	case FRAGMENT_PA:
		return "pa";
	case FRAGMENT_MA:
		return "ma";
	case FRAGMENT_CAD:
		return "cad";
	case FRAGMENT_EXP:
		return "exp";
	case FRAGMENT_GOLD:
		return "gold";
	}

	return "";
}


char* CGame::GetShardName(DWORD dwType)
{
	switch (dwType) {
	case SHARD_CRITICAL:
		return "Critical Hit Damage";
	case SHARD_CRITICAL2:
		return "Crit. Increase Chance";
	case SHARD_POISONING:
		return "Poisoning";
	case SHARD_RIGHTEOUS:
		return "Righteous";
	case SHARD_AGILE:
		return "Agile";
	case SHARD_LIGHT:
		return "Light";
	case SHARD_SHARP:
		return "Sharp";
	case SHARD_STRONG:
		return "Endurance";
	case SHARD_ANCIENT:
		return "Ancient";
	case SHARD_CASTPROB:
		return "Magic Casting Probability";
	case SHARD_MANACONV:
		return "Mana Converting";
	}

	return "";
}

char* CGame::GetFragmentName(DWORD dwType)
{
	switch (dwType) {
	case FRAGMENT_PSNRES:
		return "Poison Resistance";
	case FRAGMENT_HITPROB:
		return "Hitting Probability";
	case FRAGMENT_DEF:
		return "Defense Ratio";
	case FRAGMENT_HPREC:
		return "HP Recovery";
	case FRAGMENT_SPREC:
		return "SP Recovery";
	case FRAGMENT_MPREC:
		return "MP Recovery";
	case FRAGMENT_MR:
		return "Magic Resistance";
	case FRAGMENT_PA:
		return "Physical Absorption";
	case FRAGMENT_MA:
		return "Magic Absorption";
	case FRAGMENT_CAD:
		return "Consecutive Attack Damage";
	case FRAGMENT_EXP:
		return "Experience";
	case FRAGMENT_GOLD:
		return "Gold";
	}

	return "";
}

//50Cent - Repair All
void CGame::RequestRepairAllItemsHandler(int iClientH)
{
	int i, price;
	double d1, d2, d3;
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	m_pClientList[iClientH]->totalItemRepair = 0;

	for (i = 0; i < DEF_MAXITEMS; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			
			if (((m_pClientList[iClientH]->m_pItemList[i]->m_cCategory >= 1) && (m_pClientList[iClientH]->m_pItemList[i]->m_cCategory <= 12)) ||
				((m_pClientList[iClientH]->m_pItemList[i]->m_cCategory >= 43) && (m_pClientList[iClientH]->m_pItemList[i]->m_cCategory <= 50)))
			{
				if (m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan == m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan)
					continue;
				if (m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan <= 0)
					price = (m_pClientList[iClientH]->m_pItemList[i]->m_wPrice / 2);
				else
				{
					d1 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan);
					if (m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan != 0)
						d2 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan);
					else
						d2 = (double)1.0f;
					d3 = (double)((d1 / d2) * 0.5f);
					d2 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wPrice);
					d3 = (d3 * d2);
					price = ((m_pClientList[iClientH]->m_pItemList[i]->m_wPrice / 2) - (short)(d3));
				}
				m_pClientList[iClientH]->m_stRepairAll[m_pClientList[iClientH]->totalItemRepair].index = i;
				m_pClientList[iClientH]->m_stRepairAll[m_pClientList[iClientH]->totalItemRepair].price = price;
				m_pClientList[iClientH]->totalItemRepair++;
			}
		}
	}
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRALLPRICES, 0, 0, 0, 0);
}

void CGame::RequestRepairAllItemsDeleteHandler(int iClientH, int index)
{
	int i;
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	for (i = index; i < m_pClientList[iClientH]->totalItemRepair; i++) {
		m_pClientList[iClientH]->m_stRepairAll[i] = m_pClientList[iClientH]->m_stRepairAll[i + 1];
	}
	m_pClientList[iClientH]->totalItemRepair--;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRALLPRICES, 0, 0, 0, 0);
}

void CGame::RequestRepairAllItemsConfirmHandler(int iClientH)
{
	char* cp, cData[120];
	DWORD* dwp;
	WORD* wp;
	int      iRet, i, totalPrice = 0;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	for (i = 0; i < m_pClientList[iClientH]->totalItemRepair; i++) {
		totalPrice += m_pClientList[iClientH]->m_stRepairAll[i].price;
	}

	if (dwGetItemCount(iClientH, "Gold") < (DWORD)totalPrice)
	{
		dwp = (DWORD*)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp = (WORD*)(cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_NOTIFY_NOTENOUGHGOLD;
		cp = (char*)(cData + DEF_INDEX2_MSGTYPE + 2);
		*cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			break;
		}

	}
	else
	{
		for (i = 0; i < m_pClientList[iClientH]->totalItemRepair; i++)
		{
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index] != 0) {
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wMaxLifeSpan;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMREPAIRED, m_pClientList[iClientH]->m_stRepairAll[i].index, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wCurLifeSpan, 0, 0);
			}
		}
		iCalcTotalWeight(SetItemCount(iClientH, "Gold", dwGetItemCount(iClientH, "Gold") - totalPrice));
	}
}